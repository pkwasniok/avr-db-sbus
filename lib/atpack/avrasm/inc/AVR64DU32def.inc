;***** THIS IS A MACHINE GENERATED FILE - DO NOT EDIT ********************

;*************************************************************************
;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
;*
;* Number            : AVR000
;* File Name         : AVR64DU32def.inc
;* Title             : Register/Bit Definitions for the AVR64DU32
;* Created           : 2024-04-23 15:45
;* Version           : 1.00
;* Support           : https://microchipsupport.force.com/
;* Target MCU        : AVR64DU32
;*
;* DESCRIPTION
;* When including this file in the assembly program file, all I/O register
;* names and I/O register bit names appearing in the data book can be used.
;* In addition, the six registers forming the three data pointers X, Y and
;* Z have been assigned names XL - ZH. Highest RAM address for Internal
;* SRAM is also defined
;*
;*************************************************************************

#ifndef _AVR64DU32DEF_INC_
#define _AVR64DU32DEF_INC_


#pragma partinc 0

; ***** SPECIFY DEVICE ***************************************************
.device	AVR64DU32

#pragma AVRPART ADMIN PART_NAME AVR64DU32

.equ	SIGNATURE_000	= 0x1E
.equ	SIGNATURE_001	= 0x96
.equ	SIGNATURE_002	= 0x21

#pragma AVRPART CORE CORE_VERSION V4S

.equ	USB_MAX_ENDPOINTS	= 16


; ***** ABSOLUTE I/O REGISTER LOCATIONS **********************************


;*************************************************************************
;** AC0 - Analog Comparator
;*************************************************************************

.equ AC0_CTRLA = 0x0680                  ; Control A
.equ AC0_MUXCTRL = 0x0682                ; Mux Control A
.equ AC0_DACREF = 0x0685                 ; DAC Voltage Reference
.equ AC0_INTCTRL = 0x0686                ; Interrupt Control
.equ AC0_STATUS = 0x0687                 ; Status

;*************************************************************************
;** ADC0 - Analog to Digital Converter
;*************************************************************************

.equ ADC0_CTRLA = 0x0600                 ; Control A
.equ ADC0_CTRLB = 0x0601                 ; Control C
.equ ADC0_CTRLC = 0x0602                 ; Control B
.equ ADC0_CTRLD = 0x0603                 ; Control E
.equ ADC0_CTRLE = 0x0604                 ; Control F
.equ ADC0_CTRLF = 0x0605                 ; Control D
.equ ADC0_INTCTRL = 0x0606               ; Interrupt Control
.equ ADC0_INTFLAGS = 0x0607              ; Interrupt Flags
.equ ADC0_STATUS = 0x0608                ; Status
.equ ADC0_DBGCTRL = 0x0609               ; Debug Control
.equ ADC0_COMMAND = 0x060A               ; Command
.equ ADC0_MUXPOS = 0x060B                ; Positive mux input
.equ ADC0_RESULT = 0x060C                ; ADC Accumulator Result
.equ ADC0_RESULTL = 0x060C               ; ADC Accumulator Result low byte
.equ ADC0_RESULTH = 0x060D               ; ADC Accumulator Result hi byte
.equ ADC0_SAMPLE = 0x060E                ; ADC Sample
.equ ADC0_SAMPLEL = 0x060E               ; ADC Sample low byte
.equ ADC0_SAMPLEH = 0x060F               ; ADC Sample hi byte
.equ ADC0_WINLT = 0x0610                 ; Window comparator low threshold
.equ ADC0_WINLTL = 0x0610                ; Window comparator low threshold low byte
.equ ADC0_WINLTH = 0x0611                ; Window comparator low threshold hi byte
.equ ADC0_WINHT = 0x0612                 ; Window comparator high threshold
.equ ADC0_WINHTL = 0x0612                ; Window comparator high threshold low byte
.equ ADC0_WINHTH = 0x0613                ; Window comparator high threshold hi byte
.equ ADC0_TEMP = 0x0614                  ; Temporary Data

;*************************************************************************
;** BOD - Bod interface
;*************************************************************************

.equ BOD_CTRLA = 0x00A0                  ; Control A
.equ BOD_CTRLB = 0x00A1                  ; Control B
.equ BOD_VLMCTRLA = 0x00A8               ; Voltage level monitor Control
.equ BOD_INTCTRL = 0x00A9                ; Voltage level monitor interrupt Control
.equ BOD_INTFLAGS = 0x00AA               ; Voltage level monitor interrupt Flags
.equ BOD_STATUS = 0x00AB                 ; Voltage level monitor status

;*************************************************************************
;** BOOTROW - Boot Row
;*************************************************************************

.equ BOOTROW_BOOTROW0 = 0x1100           ; Boot row 0
.equ BOOTROW_BOOTROW1 = 0x1101           ; Boot row 1
.equ BOOTROW_BOOTROW2 = 0x1102           ; Boot row 2
.equ BOOTROW_BOOTROW3 = 0x1103           ; Boot row 3
.equ BOOTROW_BOOTROW4 = 0x1104           ; Boot row 4
.equ BOOTROW_BOOTROW5 = 0x1105           ; Boot row 5
.equ BOOTROW_BOOTROW6 = 0x1106           ; Boot row 6
.equ BOOTROW_BOOTROW7 = 0x1107           ; Boot row 7
.equ BOOTROW_BOOTROW8 = 0x1108           ; Boot row 8
.equ BOOTROW_BOOTROW9 = 0x1109           ; Boot row 9
.equ BOOTROW_BOOTROW10 = 0x110A          ; Boot row 10
.equ BOOTROW_BOOTROW11 = 0x110B          ; Boot row 11
.equ BOOTROW_BOOTROW12 = 0x110C          ; Boot row 12
.equ BOOTROW_BOOTROW13 = 0x110D          ; Boot row 13
.equ BOOTROW_BOOTROW14 = 0x110E          ; Boot row 14
.equ BOOTROW_BOOTROW15 = 0x110F          ; Boot row 15
.equ BOOTROW_BOOTROW16 = 0x1110          ; Boot row 16
.equ BOOTROW_BOOTROW17 = 0x1111          ; Boot row 17
.equ BOOTROW_BOOTROW18 = 0x1112          ; Boot row 18
.equ BOOTROW_BOOTROW19 = 0x1113          ; Boot row 19
.equ BOOTROW_BOOTROW20 = 0x1114          ; Boot row 20
.equ BOOTROW_BOOTROW21 = 0x1115          ; Boot row 21
.equ BOOTROW_BOOTROW22 = 0x1116          ; Boot row 22
.equ BOOTROW_BOOTROW23 = 0x1117          ; Boot row 23
.equ BOOTROW_BOOTROW24 = 0x1118          ; Boot row 24
.equ BOOTROW_BOOTROW25 = 0x1119          ; Boot row 25
.equ BOOTROW_BOOTROW26 = 0x111A          ; Boot row 26
.equ BOOTROW_BOOTROW27 = 0x111B          ; Boot row 27
.equ BOOTROW_BOOTROW28 = 0x111C          ; Boot row 28
.equ BOOTROW_BOOTROW29 = 0x111D          ; Boot row 29
.equ BOOTROW_BOOTROW30 = 0x111E          ; Boot row 30
.equ BOOTROW_BOOTROW31 = 0x111F          ; Boot row 31
.equ BOOTROW_BOOTROW32 = 0x1120          ; Boot row 32
.equ BOOTROW_BOOTROW33 = 0x1121          ; Boot row 33
.equ BOOTROW_BOOTROW34 = 0x1122          ; Boot row 34
.equ BOOTROW_BOOTROW35 = 0x1123          ; Boot row 35
.equ BOOTROW_BOOTROW36 = 0x1124          ; Boot row 36
.equ BOOTROW_BOOTROW37 = 0x1125          ; Boot row 37
.equ BOOTROW_BOOTROW38 = 0x1126          ; Boot row 38
.equ BOOTROW_BOOTROW39 = 0x1127          ; Boot row 39
.equ BOOTROW_BOOTROW40 = 0x1128          ; Boot row 40
.equ BOOTROW_BOOTROW41 = 0x1129          ; Boot row 41
.equ BOOTROW_BOOTROW42 = 0x112A          ; Boot row 42
.equ BOOTROW_BOOTROW43 = 0x112B          ; Boot row 43
.equ BOOTROW_BOOTROW44 = 0x112C          ; Boot row 44
.equ BOOTROW_BOOTROW45 = 0x112D          ; Boot row 45
.equ BOOTROW_BOOTROW46 = 0x112E          ; Boot row 46
.equ BOOTROW_BOOTROW47 = 0x112F          ; Boot row 47
.equ BOOTROW_BOOTROW48 = 0x1130          ; Boot row 48
.equ BOOTROW_BOOTROW49 = 0x1131          ; Boot row 49
.equ BOOTROW_BOOTROW50 = 0x1132          ; Boot row 50
.equ BOOTROW_BOOTROW51 = 0x1133          ; Boot row 51
.equ BOOTROW_BOOTROW52 = 0x1134          ; Boot row 52
.equ BOOTROW_BOOTROW53 = 0x1135          ; Boot row 53
.equ BOOTROW_BOOTROW54 = 0x1136          ; Boot row 54
.equ BOOTROW_BOOTROW55 = 0x1137          ; Boot row 55
.equ BOOTROW_BOOTROW56 = 0x1138          ; Boot row 56
.equ BOOTROW_BOOTROW57 = 0x1139          ; Boot row 57
.equ BOOTROW_BOOTROW58 = 0x113A          ; Boot row 58
.equ BOOTROW_BOOTROW59 = 0x113B          ; Boot row 59
.equ BOOTROW_BOOTROW60 = 0x113C          ; Boot row 60
.equ BOOTROW_BOOTROW61 = 0x113D          ; Boot row 61
.equ BOOTROW_BOOTROW62 = 0x113E          ; Boot row 62
.equ BOOTROW_BOOTROW63 = 0x113F          ; Boot row 63
.equ BOOTROW_BOOTROW64 = 0x1140          ; Boot row 64
.equ BOOTROW_BOOTROW65 = 0x1141          ; Boot row 65
.equ BOOTROW_BOOTROW66 = 0x1142          ; Boot row 66
.equ BOOTROW_BOOTROW67 = 0x1143          ; Boot row 67
.equ BOOTROW_BOOTROW68 = 0x1144          ; Boot row 68
.equ BOOTROW_BOOTROW69 = 0x1145          ; Boot row 69
.equ BOOTROW_BOOTROW70 = 0x1146          ; Boot row 70
.equ BOOTROW_BOOTROW71 = 0x1147          ; Boot row 71
.equ BOOTROW_BOOTROW72 = 0x1148          ; Boot row 72
.equ BOOTROW_BOOTROW73 = 0x1149          ; Boot row 73
.equ BOOTROW_BOOTROW74 = 0x114A          ; Boot row 74
.equ BOOTROW_BOOTROW75 = 0x114B          ; Boot row 75
.equ BOOTROW_BOOTROW76 = 0x114C          ; Boot row 76
.equ BOOTROW_BOOTROW77 = 0x114D          ; Boot row 77
.equ BOOTROW_BOOTROW78 = 0x114E          ; Boot row 78
.equ BOOTROW_BOOTROW79 = 0x114F          ; Boot row 79
.equ BOOTROW_BOOTROW80 = 0x1150          ; Boot row 80
.equ BOOTROW_BOOTROW81 = 0x1151          ; Boot row 81
.equ BOOTROW_BOOTROW82 = 0x1152          ; Boot row 82
.equ BOOTROW_BOOTROW83 = 0x1153          ; Boot row 83
.equ BOOTROW_BOOTROW84 = 0x1154          ; Boot row 84
.equ BOOTROW_BOOTROW85 = 0x1155          ; Boot row 85
.equ BOOTROW_BOOTROW86 = 0x1156          ; Boot row 86
.equ BOOTROW_BOOTROW87 = 0x1157          ; Boot row 87
.equ BOOTROW_BOOTROW88 = 0x1158          ; Boot row 88
.equ BOOTROW_BOOTROW89 = 0x1159          ; Boot row 89
.equ BOOTROW_BOOTROW90 = 0x115A          ; Boot row 90
.equ BOOTROW_BOOTROW91 = 0x115B          ; Boot row 91
.equ BOOTROW_BOOTROW92 = 0x115C          ; Boot row 92
.equ BOOTROW_BOOTROW93 = 0x115D          ; Boot row 93
.equ BOOTROW_BOOTROW94 = 0x115E          ; Boot row 94
.equ BOOTROW_BOOTROW95 = 0x115F          ; Boot row 95
.equ BOOTROW_BOOTROW96 = 0x1160          ; Boot row 96
.equ BOOTROW_BOOTROW97 = 0x1161          ; Boot row 97
.equ BOOTROW_BOOTROW98 = 0x1162          ; Boot row 98
.equ BOOTROW_BOOTROW99 = 0x1163          ; Boot row 99
.equ BOOTROW_BOOTROW100 = 0x1164         ; Boot row 100
.equ BOOTROW_BOOTROW101 = 0x1165         ; Boot row 101
.equ BOOTROW_BOOTROW102 = 0x1166         ; Boot row 102
.equ BOOTROW_BOOTROW103 = 0x1167         ; Boot row 103
.equ BOOTROW_BOOTROW104 = 0x1168         ; Boot row 104
.equ BOOTROW_BOOTROW105 = 0x1169         ; Boot row 105
.equ BOOTROW_BOOTROW106 = 0x116A         ; Boot row 106
.equ BOOTROW_BOOTROW107 = 0x116B         ; Boot row 107
.equ BOOTROW_BOOTROW108 = 0x116C         ; Boot row 108
.equ BOOTROW_BOOTROW109 = 0x116D         ; Boot row 109
.equ BOOTROW_BOOTROW110 = 0x116E         ; Boot row 110
.equ BOOTROW_BOOTROW111 = 0x116F         ; Boot row 111
.equ BOOTROW_BOOTROW112 = 0x1170         ; Boot row 112
.equ BOOTROW_BOOTROW113 = 0x1171         ; Boot row 113
.equ BOOTROW_BOOTROW114 = 0x1172         ; Boot row 114
.equ BOOTROW_BOOTROW115 = 0x1173         ; Boot row 115
.equ BOOTROW_BOOTROW116 = 0x1174         ; Boot row 116
.equ BOOTROW_BOOTROW117 = 0x1175         ; Boot row 117
.equ BOOTROW_BOOTROW118 = 0x1176         ; Boot row 118
.equ BOOTROW_BOOTROW119 = 0x1177         ; Boot row 119
.equ BOOTROW_BOOTROW120 = 0x1178         ; Boot row 120
.equ BOOTROW_BOOTROW121 = 0x1179         ; Boot row 121
.equ BOOTROW_BOOTROW122 = 0x117A         ; Boot row 122
.equ BOOTROW_BOOTROW123 = 0x117B         ; Boot row 123
.equ BOOTROW_BOOTROW124 = 0x117C         ; Boot row 124
.equ BOOTROW_BOOTROW125 = 0x117D         ; Boot row 125
.equ BOOTROW_BOOTROW126 = 0x117E         ; Boot row 126
.equ BOOTROW_BOOTROW127 = 0x117F         ; Boot row 127
.equ BOOTROW_BOOTROW128 = 0x1180         ; Boot row 128
.equ BOOTROW_BOOTROW129 = 0x1181         ; Boot row 129
.equ BOOTROW_BOOTROW130 = 0x1182         ; Boot row 130
.equ BOOTROW_BOOTROW131 = 0x1183         ; Boot row 131
.equ BOOTROW_BOOTROW132 = 0x1184         ; Boot row 132
.equ BOOTROW_BOOTROW133 = 0x1185         ; Boot row 133
.equ BOOTROW_BOOTROW134 = 0x1186         ; Boot row 134
.equ BOOTROW_BOOTROW135 = 0x1187         ; Boot row 135
.equ BOOTROW_BOOTROW136 = 0x1188         ; Boot row 136
.equ BOOTROW_BOOTROW137 = 0x1189         ; Boot row 137
.equ BOOTROW_BOOTROW138 = 0x118A         ; Boot row 138
.equ BOOTROW_BOOTROW139 = 0x118B         ; Boot row 139
.equ BOOTROW_BOOTROW140 = 0x118C         ; Boot row 140
.equ BOOTROW_BOOTROW141 = 0x118D         ; Boot row 141
.equ BOOTROW_BOOTROW142 = 0x118E         ; Boot row 142
.equ BOOTROW_BOOTROW143 = 0x118F         ; Boot row 143
.equ BOOTROW_BOOTROW144 = 0x1190         ; Boot row 144
.equ BOOTROW_BOOTROW145 = 0x1191         ; Boot row 145
.equ BOOTROW_BOOTROW146 = 0x1192         ; Boot row 146
.equ BOOTROW_BOOTROW147 = 0x1193         ; Boot row 147
.equ BOOTROW_BOOTROW148 = 0x1194         ; Boot row 148
.equ BOOTROW_BOOTROW149 = 0x1195         ; Boot row 149
.equ BOOTROW_BOOTROW150 = 0x1196         ; Boot row 150
.equ BOOTROW_BOOTROW151 = 0x1197         ; Boot row 151
.equ BOOTROW_BOOTROW152 = 0x1198         ; Boot row 152
.equ BOOTROW_BOOTROW153 = 0x1199         ; Boot row 153
.equ BOOTROW_BOOTROW154 = 0x119A         ; Boot row 154
.equ BOOTROW_BOOTROW155 = 0x119B         ; Boot row 155
.equ BOOTROW_BOOTROW156 = 0x119C         ; Boot row 156
.equ BOOTROW_BOOTROW157 = 0x119D         ; Boot row 157
.equ BOOTROW_BOOTROW158 = 0x119E         ; Boot row 158
.equ BOOTROW_BOOTROW159 = 0x119F         ; Boot row 159
.equ BOOTROW_BOOTROW160 = 0x11A0         ; Boot row 160
.equ BOOTROW_BOOTROW161 = 0x11A1         ; Boot row 161
.equ BOOTROW_BOOTROW162 = 0x11A2         ; Boot row 162
.equ BOOTROW_BOOTROW163 = 0x11A3         ; Boot row 163
.equ BOOTROW_BOOTROW164 = 0x11A4         ; Boot row 164
.equ BOOTROW_BOOTROW165 = 0x11A5         ; Boot row 165
.equ BOOTROW_BOOTROW166 = 0x11A6         ; Boot row 166
.equ BOOTROW_BOOTROW167 = 0x11A7         ; Boot row 167
.equ BOOTROW_BOOTROW168 = 0x11A8         ; Boot row 168
.equ BOOTROW_BOOTROW169 = 0x11A9         ; Boot row 169
.equ BOOTROW_BOOTROW170 = 0x11AA         ; Boot row 170
.equ BOOTROW_BOOTROW171 = 0x11AB         ; Boot row 171
.equ BOOTROW_BOOTROW172 = 0x11AC         ; Boot row 172
.equ BOOTROW_BOOTROW173 = 0x11AD         ; Boot row 173
.equ BOOTROW_BOOTROW174 = 0x11AE         ; Boot row 174
.equ BOOTROW_BOOTROW175 = 0x11AF         ; Boot row 175
.equ BOOTROW_BOOTROW176 = 0x11B0         ; Boot row 176
.equ BOOTROW_BOOTROW177 = 0x11B1         ; Boot row 177
.equ BOOTROW_BOOTROW178 = 0x11B2         ; Boot row 178
.equ BOOTROW_BOOTROW179 = 0x11B3         ; Boot row 179
.equ BOOTROW_BOOTROW180 = 0x11B4         ; Boot row 180
.equ BOOTROW_BOOTROW181 = 0x11B5         ; Boot row 181
.equ BOOTROW_BOOTROW182 = 0x11B6         ; Boot row 182
.equ BOOTROW_BOOTROW183 = 0x11B7         ; Boot row 183
.equ BOOTROW_BOOTROW184 = 0x11B8         ; Boot row 184
.equ BOOTROW_BOOTROW185 = 0x11B9         ; Boot row 185
.equ BOOTROW_BOOTROW186 = 0x11BA         ; Boot row 186
.equ BOOTROW_BOOTROW187 = 0x11BB         ; Boot row 187
.equ BOOTROW_BOOTROW188 = 0x11BC         ; Boot row 188
.equ BOOTROW_BOOTROW189 = 0x11BD         ; Boot row 189
.equ BOOTROW_BOOTROW190 = 0x11BE         ; Boot row 190
.equ BOOTROW_BOOTROW191 = 0x11BF         ; Boot row 191
.equ BOOTROW_BOOTROW192 = 0x11C0         ; Boot row 192
.equ BOOTROW_BOOTROW193 = 0x11C1         ; Boot row 193
.equ BOOTROW_BOOTROW194 = 0x11C2         ; Boot row 194
.equ BOOTROW_BOOTROW195 = 0x11C3         ; Boot row 195
.equ BOOTROW_BOOTROW196 = 0x11C4         ; Boot row 196
.equ BOOTROW_BOOTROW197 = 0x11C5         ; Boot row 197
.equ BOOTROW_BOOTROW198 = 0x11C6         ; Boot row 198
.equ BOOTROW_BOOTROW199 = 0x11C7         ; Boot row 199
.equ BOOTROW_BOOTROW200 = 0x11C8         ; Boot row 200
.equ BOOTROW_BOOTROW201 = 0x11C9         ; Boot row 201
.equ BOOTROW_BOOTROW202 = 0x11CA         ; Boot row 202
.equ BOOTROW_BOOTROW203 = 0x11CB         ; Boot row 203
.equ BOOTROW_BOOTROW204 = 0x11CC         ; Boot row 204
.equ BOOTROW_BOOTROW205 = 0x11CD         ; Boot row 205
.equ BOOTROW_BOOTROW206 = 0x11CE         ; Boot row 206
.equ BOOTROW_BOOTROW207 = 0x11CF         ; Boot row 207
.equ BOOTROW_BOOTROW208 = 0x11D0         ; Boot row 208
.equ BOOTROW_BOOTROW209 = 0x11D1         ; Boot row 209
.equ BOOTROW_BOOTROW210 = 0x11D2         ; Boot row 210
.equ BOOTROW_BOOTROW211 = 0x11D3         ; Boot row 211
.equ BOOTROW_BOOTROW212 = 0x11D4         ; Boot row 212
.equ BOOTROW_BOOTROW213 = 0x11D5         ; Boot row 213
.equ BOOTROW_BOOTROW214 = 0x11D6         ; Boot row 214
.equ BOOTROW_BOOTROW215 = 0x11D7         ; Boot row 215
.equ BOOTROW_BOOTROW216 = 0x11D8         ; Boot row 216
.equ BOOTROW_BOOTROW217 = 0x11D9         ; Boot row 217
.equ BOOTROW_BOOTROW218 = 0x11DA         ; Boot row 218
.equ BOOTROW_BOOTROW219 = 0x11DB         ; Boot row 219
.equ BOOTROW_BOOTROW220 = 0x11DC         ; Boot row 220
.equ BOOTROW_BOOTROW221 = 0x11DD         ; Boot row 221
.equ BOOTROW_BOOTROW222 = 0x11DE         ; Boot row 222
.equ BOOTROW_BOOTROW223 = 0x11DF         ; Boot row 223
.equ BOOTROW_BOOTROW224 = 0x11E0         ; Boot row 224
.equ BOOTROW_BOOTROW225 = 0x11E1         ; Boot row 225
.equ BOOTROW_BOOTROW226 = 0x11E2         ; Boot row 226
.equ BOOTROW_BOOTROW227 = 0x11E3         ; Boot row 227
.equ BOOTROW_BOOTROW228 = 0x11E4         ; Boot row 228
.equ BOOTROW_BOOTROW229 = 0x11E5         ; Boot row 229
.equ BOOTROW_BOOTROW230 = 0x11E6         ; Boot row 230
.equ BOOTROW_BOOTROW231 = 0x11E7         ; Boot row 231
.equ BOOTROW_BOOTROW232 = 0x11E8         ; Boot row 232
.equ BOOTROW_BOOTROW233 = 0x11E9         ; Boot row 233
.equ BOOTROW_BOOTROW234 = 0x11EA         ; Boot row 234
.equ BOOTROW_BOOTROW235 = 0x11EB         ; Boot row 235
.equ BOOTROW_BOOTROW236 = 0x11EC         ; Boot row 236
.equ BOOTROW_BOOTROW237 = 0x11ED         ; Boot row 237
.equ BOOTROW_BOOTROW238 = 0x11EE         ; Boot row 238
.equ BOOTROW_BOOTROW239 = 0x11EF         ; Boot row 239
.equ BOOTROW_BOOTROW240 = 0x11F0         ; Boot row 240
.equ BOOTROW_BOOTROW241 = 0x11F1         ; Boot row 241
.equ BOOTROW_BOOTROW242 = 0x11F2         ; Boot row 242
.equ BOOTROW_BOOTROW243 = 0x11F3         ; Boot row 243
.equ BOOTROW_BOOTROW244 = 0x11F4         ; Boot row 244
.equ BOOTROW_BOOTROW245 = 0x11F5         ; Boot row 245
.equ BOOTROW_BOOTROW246 = 0x11F6         ; Boot row 246
.equ BOOTROW_BOOTROW247 = 0x11F7         ; Boot row 247
.equ BOOTROW_BOOTROW248 = 0x11F8         ; Boot row 248
.equ BOOTROW_BOOTROW249 = 0x11F9         ; Boot row 249
.equ BOOTROW_BOOTROW250 = 0x11FA         ; Boot row 250
.equ BOOTROW_BOOTROW251 = 0x11FB         ; Boot row 251
.equ BOOTROW_BOOTROW252 = 0x11FC         ; Boot row 252
.equ BOOTROW_BOOTROW253 = 0x11FD         ; Boot row 253
.equ BOOTROW_BOOTROW254 = 0x11FE         ; Boot row 254
.equ BOOTROW_BOOTROW255 = 0x11FF         ; Boot row 255

;*************************************************************************
;** CCL - Configurable Custom Logic
;*************************************************************************

.equ CCL_CTRLA = 0x01C0                  ; Control Register A
.equ CCL_SEQCTRL0 = 0x01C1               ; Sequential Control 0
.equ CCL_SEQCTRL1 = 0x01C2               ; Sequential Control 1
.equ CCL_INTCTRL0 = 0x01C5               ; Interrupt Control 0
.equ CCL_INTFLAGS = 0x01C7               ; Interrupt Flags
.equ CCL_LUT0CTRLA = 0x01C8              ; LUT 0 Control A
.equ CCL_LUT0CTRLB = 0x01C9              ; LUT 0 Control B
.equ CCL_LUT0CTRLC = 0x01CA              ; LUT 0 Control C
.equ CCL_TRUTH0 = 0x01CB                 ; Truth 0
.equ CCL_LUT1CTRLA = 0x01CC              ; LUT 1 Control A
.equ CCL_LUT1CTRLB = 0x01CD              ; LUT 1 Control B
.equ CCL_LUT1CTRLC = 0x01CE              ; LUT 1 Control C
.equ CCL_TRUTH1 = 0x01CF                 ; Truth 1
.equ CCL_LUT2CTRLA = 0x01D0              ; LUT 2 Control A
.equ CCL_LUT2CTRLB = 0x01D1              ; LUT 2 Control B
.equ CCL_LUT2CTRLC = 0x01D2              ; LUT 2 Control C
.equ CCL_TRUTH2 = 0x01D3                 ; Truth 2
.equ CCL_LUT3CTRLA = 0x01D4              ; LUT 3 Control A
.equ CCL_LUT3CTRLB = 0x01D5              ; LUT 3 Control B
.equ CCL_LUT3CTRLC = 0x01D6              ; LUT 3 Control C
.equ CCL_TRUTH3 = 0x01D7                 ; Truth 3

;*************************************************************************
;** CLKCTRL - Clock controller
;*************************************************************************

.equ CLKCTRL_MCLKCTRLA = 0x0060          ; MCLK Control A
.equ CLKCTRL_MCLKCTRLB = 0x0061          ; MCLK Control B
.equ CLKCTRL_MCLKCTRLC = 0x0062          ; MCLK Control C
.equ CLKCTRL_MCLKINTCTRL = 0x0063        ; MCLK Interrupt Control
.equ CLKCTRL_MCLKINTFLAGS = 0x0064       ; MCLK Interrupt Flags
.equ CLKCTRL_MCLKSTATUS = 0x0065         ; MCLK Status
.equ CLKCTRL_MCLKTIMEBASE = 0x0066       ; Timebase
.equ CLKCTRL_OSCHFCTRLA = 0x0068         ; OSCHF Control A
.equ CLKCTRL_OSCHFTUNE = 0x0069          ; OSCHF Tune
.equ CLKCTRL_OSCHFSTATUS = 0x006A        ; OSCHF Status
.equ CLKCTRL_OSC32KCTRLA = 0x0078        ; OSC32K Control A
.equ CLKCTRL_XOSC32KCTRLA = 0x007C       ; XOSC32K Control A
.equ CLKCTRL_XOSCHFCTRLA = 0x0080        ; XOSCHF Control A
.equ CLKCTRL_USBPLLSTATUS = 0x0085       ; PLL Status

;*************************************************************************
;** CPU - CPU
;*************************************************************************

.equ CPU_CCP = 0x0034                    ; Configuration Change Protection
.equ CPU_RAMPZ = 0x003B                  ; Extended Z-pointer Register
.equ CPU_SP = 0x003D                     ; Stack Pointer
.equ CPU_SPL = 0x003D                    ; Stack Pointer low byte
.equ CPU_SPH = 0x003E                    ; Stack Pointer hi byte
.equ CPU_SREG = 0x003F                   ; Status Register

;*************************************************************************
;** CPUINT - Interrupt Controller
;*************************************************************************

.equ CPUINT_CTRLA = 0x0110               ; Control A
.equ CPUINT_STATUS = 0x0111              ; Status
.equ CPUINT_LVL0PRI = 0x0112             ; Interrupt Level 0 Priority
.equ CPUINT_LVL1VEC = 0x0113             ; Interrupt Level 1 Priority Vector

;*************************************************************************
;** CRCSCAN - CRCSCAN
;*************************************************************************

.equ CRCSCAN_CTRLA = 0x0120              ; Control A
.equ CRCSCAN_CTRLB = 0x0121              ; Control B
.equ CRCSCAN_STATUS = 0x0122             ; Status

;*************************************************************************
;** EVSYS - Event System
;*************************************************************************

.equ EVSYS_SWEVENTA = 0x0200             ; Software Event A
.equ EVSYS_CHANNEL0 = 0x0210             ; Multiplexer Channel 0
.equ EVSYS_CHANNEL1 = 0x0211             ; Multiplexer Channel 1
.equ EVSYS_CHANNEL2 = 0x0212             ; Multiplexer Channel 2
.equ EVSYS_CHANNEL3 = 0x0213             ; Multiplexer Channel 3
.equ EVSYS_CHANNEL4 = 0x0214             ; Multiplexer Channel 4
.equ EVSYS_CHANNEL5 = 0x0215             ; Multiplexer Channel 5
.equ EVSYS_USERCCLLUT0A = 0x0220         ; CCL0 Event A
.equ EVSYS_USERCCLLUT0B = 0x0221         ; CCL0 Event B
.equ EVSYS_USERCCLLUT1A = 0x0222         ; CCL1 Event A
.equ EVSYS_USERCCLLUT1B = 0x0223         ; CCL1 Event B
.equ EVSYS_USERCCLLUT2A = 0x0224         ; CCL2 Event A
.equ EVSYS_USERCCLLUT2B = 0x0225         ; CCL2 Event B
.equ EVSYS_USERCCLLUT3A = 0x0226         ; CCL3 Event A
.equ EVSYS_USERCCLLUT3B = 0x0227         ; CCL3 Event B
.equ EVSYS_USERADC0START = 0x0228        ; ADC0
.equ EVSYS_USEREVSYSEVOUTA = 0x0229      ; EVOUTA
.equ EVSYS_USEREVSYSEVOUTD = 0x022A      ; EVOUTD
.equ EVSYS_USEREVSYSEVOUTF = 0x022B      ; EVOUTF
.equ EVSYS_USERUSART0IRDA = 0x022C       ; USART0
.equ EVSYS_USERUSART1IRDA = 0x022D       ; USART1
.equ EVSYS_USERTCA0CNTA = 0x022E         ; TCA0 Event A
.equ EVSYS_USERTCA0CNTB = 0x022F         ; TCA0 Event B
.equ EVSYS_USERTCB0CAPT = 0x0230         ; TCB0 Event A
.equ EVSYS_USERTCB0COUNT = 0x0231        ; TCB0 Event B
.equ EVSYS_USERTCB1CAPT = 0x0232         ; TCB1 Event A
.equ EVSYS_USERTCB1COUNT = 0x0233        ; TCB1 Event B

;*************************************************************************
;** FUSE - Fuses
;*************************************************************************

.equ FUSE_WDTCFG = 0x1050                ; Watchdog Configuration
.equ FUSE_BODCFG = 0x1051                ; BOD Configuration
.equ FUSE_OSCCFG = 0x1052                ; Oscillator Configuration
.equ FUSE_SYSCFG0 = 0x1055               ; System Configuration 0
.equ FUSE_SYSCFG1 = 0x1056               ; System Configuration 1
.equ FUSE_CODESIZE = 0x1057              ; Code Section Size
.equ FUSE_BOOTSIZE = 0x1058              ; Boot Section Size
.equ FUSE_PDICFG = 0x105A                ; Programming and Debugging Interface Configuration
.equ FUSE_PDICFGL = 0x105A               ; Programming and Debugging Interface Configuration low byte
.equ FUSE_PDICFGH = 0x105B               ; Programming and Debugging Interface Configuration hi byte

;*************************************************************************
;** GPR - General Purpose Registers
;*************************************************************************

.equ GPR_GPR0 = 0x001C                   ; General Purpose Register 0
.equ GPR_GPR1 = 0x001D                   ; General Purpose Register 1
.equ GPR_GPR2 = 0x001E                   ; General Purpose Register 2
.equ GPR_GPR3 = 0x001F                   ; General Purpose Register 3

;*************************************************************************
;** LOCK - Lockbits
;*************************************************************************

.equ LOCK_KEY = 0x1040                   ; Lock Key Bits
.equ LOCK_KEY0 = 0x1040                  ; Lock Key Bits 0
.equ LOCK_KEY1 = 0x1041                  ; Lock Key Bits 1
.equ LOCK_KEY2 = 0x1042                  ; Lock Key Bits 2
.equ LOCK_KEY3 = 0x1043                  ; Lock Key Bits 3

;*************************************************************************
;** NVMCTRL - Non-volatile Memory Controller
;*************************************************************************

.equ NVMCTRL_CTRLA = 0x1000              ; Control A
.equ NVMCTRL_CTRLB = 0x1001              ; Control B
.equ NVMCTRL_CTRLC = 0x1002              ; Control C
.equ NVMCTRL_INTCTRL = 0x1004            ; Interrupt Control
.equ NVMCTRL_INTFLAGS = 0x1005           ; Interrupt Flags
.equ NVMCTRL_STATUS = 0x1006             ; Status
.equ NVMCTRL_DATA = 0x1008               ; Data
.equ NVMCTRL_DATA0 = 0x1008              ; Data 0
.equ NVMCTRL_DATA1 = 0x1009              ; Data 1
.equ NVMCTRL_DATA2 = 0x100A              ; Data 2
.equ NVMCTRL_DATA3 = 0x100B              ; Data 3
.equ NVMCTRL_ADDR = 0x100C               ; Address
.equ NVMCTRL_ADDR0 = 0x100C              ; Address 0
.equ NVMCTRL_ADDR1 = 0x100D              ; Address 1
.equ NVMCTRL_ADDR2 = 0x100E              ; Address 2
.equ NVMCTRL_ADDR3 = 0x100F              ; Address 3

;*************************************************************************
;** PORTA - I/O Ports
;*************************************************************************

.equ PORTA_DIR = 0x0400                  ; Data Direction
.equ PORTA_DIRSET = 0x0401               ; Data Direction Set
.equ PORTA_DIRCLR = 0x0402               ; Data Direction Clear
.equ PORTA_DIRTGL = 0x0403               ; Data Direction Toggle
.equ PORTA_OUT = 0x0404                  ; Output Value
.equ PORTA_OUTSET = 0x0405               ; Output Value Set
.equ PORTA_OUTCLR = 0x0406               ; Output Value Clear
.equ PORTA_OUTTGL = 0x0407               ; Output Value Toggle
.equ PORTA_IN = 0x0408                   ; Input Value
.equ PORTA_INTFLAGS = 0x0409             ; Interrupt Flags
.equ PORTA_PORTCTRL = 0x040A             ; Port Control
.equ PORTA_PINCONFIG = 0x040B            ; Pin Control Config
.equ PORTA_PINCTRLUPD = 0x040C           ; Pin Control Update
.equ PORTA_PINCTRLSET = 0x040D           ; Pin Control Set
.equ PORTA_PINCTRLCLR = 0x040E           ; Pin Control Clear
.equ PORTA_PIN0CTRL = 0x0410             ; Pin 0 Control
.equ PORTA_PIN1CTRL = 0x0411             ; Pin 1 Control
.equ PORTA_PIN2CTRL = 0x0412             ; Pin 2 Control
.equ PORTA_PIN3CTRL = 0x0413             ; Pin 3 Control
.equ PORTA_PIN4CTRL = 0x0414             ; Pin 4 Control
.equ PORTA_PIN5CTRL = 0x0415             ; Pin 5 Control
.equ PORTA_PIN6CTRL = 0x0416             ; Pin 6 Control
.equ PORTA_PIN7CTRL = 0x0417             ; Pin 7 Control
.equ PORTA_EVGENCTRLA = 0x0418           ; Event Generation Control A

;*************************************************************************
;** PORTC - I/O Ports
;*************************************************************************

.equ PORTC_DIR = 0x0440                  ; Data Direction
.equ PORTC_DIRSET = 0x0441               ; Data Direction Set
.equ PORTC_DIRCLR = 0x0442               ; Data Direction Clear
.equ PORTC_DIRTGL = 0x0443               ; Data Direction Toggle
.equ PORTC_OUT = 0x0444                  ; Output Value
.equ PORTC_OUTSET = 0x0445               ; Output Value Set
.equ PORTC_OUTCLR = 0x0446               ; Output Value Clear
.equ PORTC_OUTTGL = 0x0447               ; Output Value Toggle
.equ PORTC_IN = 0x0448                   ; Input Value
.equ PORTC_INTFLAGS = 0x0449             ; Interrupt Flags
.equ PORTC_PORTCTRL = 0x044A             ; Port Control
.equ PORTC_PINCONFIG = 0x044B            ; Pin Control Config
.equ PORTC_PINCTRLUPD = 0x044C           ; Pin Control Update
.equ PORTC_PINCTRLSET = 0x044D           ; Pin Control Set
.equ PORTC_PINCTRLCLR = 0x044E           ; Pin Control Clear
.equ PORTC_PIN0CTRL = 0x0450             ; Pin 0 Control
.equ PORTC_PIN1CTRL = 0x0451             ; Pin 1 Control
.equ PORTC_PIN2CTRL = 0x0452             ; Pin 2 Control
.equ PORTC_PIN3CTRL = 0x0453             ; Pin 3 Control
.equ PORTC_PIN4CTRL = 0x0454             ; Pin 4 Control
.equ PORTC_PIN5CTRL = 0x0455             ; Pin 5 Control
.equ PORTC_PIN6CTRL = 0x0456             ; Pin 6 Control
.equ PORTC_PIN7CTRL = 0x0457             ; Pin 7 Control
.equ PORTC_EVGENCTRLA = 0x0458           ; Event Generation Control A

;*************************************************************************
;** PORTD - I/O Ports
;*************************************************************************

.equ PORTD_DIR = 0x0460                  ; Data Direction
.equ PORTD_DIRSET = 0x0461               ; Data Direction Set
.equ PORTD_DIRCLR = 0x0462               ; Data Direction Clear
.equ PORTD_DIRTGL = 0x0463               ; Data Direction Toggle
.equ PORTD_OUT = 0x0464                  ; Output Value
.equ PORTD_OUTSET = 0x0465               ; Output Value Set
.equ PORTD_OUTCLR = 0x0466               ; Output Value Clear
.equ PORTD_OUTTGL = 0x0467               ; Output Value Toggle
.equ PORTD_IN = 0x0468                   ; Input Value
.equ PORTD_INTFLAGS = 0x0469             ; Interrupt Flags
.equ PORTD_PORTCTRL = 0x046A             ; Port Control
.equ PORTD_PINCONFIG = 0x046B            ; Pin Control Config
.equ PORTD_PINCTRLUPD = 0x046C           ; Pin Control Update
.equ PORTD_PINCTRLSET = 0x046D           ; Pin Control Set
.equ PORTD_PINCTRLCLR = 0x046E           ; Pin Control Clear
.equ PORTD_PIN0CTRL = 0x0470             ; Pin 0 Control
.equ PORTD_PIN1CTRL = 0x0471             ; Pin 1 Control
.equ PORTD_PIN2CTRL = 0x0472             ; Pin 2 Control
.equ PORTD_PIN3CTRL = 0x0473             ; Pin 3 Control
.equ PORTD_PIN4CTRL = 0x0474             ; Pin 4 Control
.equ PORTD_PIN5CTRL = 0x0475             ; Pin 5 Control
.equ PORTD_PIN6CTRL = 0x0476             ; Pin 6 Control
.equ PORTD_PIN7CTRL = 0x0477             ; Pin 7 Control
.equ PORTD_EVGENCTRLA = 0x0478           ; Event Generation Control A

;*************************************************************************
;** PORTF - I/O Ports
;*************************************************************************

.equ PORTF_DIR = 0x04A0                  ; Data Direction
.equ PORTF_DIRSET = 0x04A1               ; Data Direction Set
.equ PORTF_DIRCLR = 0x04A2               ; Data Direction Clear
.equ PORTF_DIRTGL = 0x04A3               ; Data Direction Toggle
.equ PORTF_OUT = 0x04A4                  ; Output Value
.equ PORTF_OUTSET = 0x04A5               ; Output Value Set
.equ PORTF_OUTCLR = 0x04A6               ; Output Value Clear
.equ PORTF_OUTTGL = 0x04A7               ; Output Value Toggle
.equ PORTF_IN = 0x04A8                   ; Input Value
.equ PORTF_INTFLAGS = 0x04A9             ; Interrupt Flags
.equ PORTF_PORTCTRL = 0x04AA             ; Port Control
.equ PORTF_PINCONFIG = 0x04AB            ; Pin Control Config
.equ PORTF_PINCTRLUPD = 0x04AC           ; Pin Control Update
.equ PORTF_PINCTRLSET = 0x04AD           ; Pin Control Set
.equ PORTF_PINCTRLCLR = 0x04AE           ; Pin Control Clear
.equ PORTF_PIN0CTRL = 0x04B0             ; Pin 0 Control
.equ PORTF_PIN1CTRL = 0x04B1             ; Pin 1 Control
.equ PORTF_PIN2CTRL = 0x04B2             ; Pin 2 Control
.equ PORTF_PIN3CTRL = 0x04B3             ; Pin 3 Control
.equ PORTF_PIN4CTRL = 0x04B4             ; Pin 4 Control
.equ PORTF_PIN5CTRL = 0x04B5             ; Pin 5 Control
.equ PORTF_PIN6CTRL = 0x04B6             ; Pin 6 Control
.equ PORTF_PIN7CTRL = 0x04B7             ; Pin 7 Control
.equ PORTF_EVGENCTRLA = 0x04B8           ; Event Generation Control A

;*************************************************************************
;** PORTMUX - Port Multiplexer
;*************************************************************************

.equ PORTMUX_EVSYSROUTEA = 0x05E0        ; EVSYS route A
.equ PORTMUX_CCLROUTEA = 0x05E1          ; CCL route A
.equ PORTMUX_USARTROUTEA = 0x05E2        ; USART route A
.equ PORTMUX_SPIROUTEA = 0x05E5          ; SPI route A
.equ PORTMUX_TWIROUTEA = 0x05E6          ; TWI route A
.equ PORTMUX_TCAROUTEA = 0x05E7          ; TCA route A
.equ PORTMUX_TCBROUTEA = 0x05E8          ; TCB route A

;*************************************************************************
;** RSTCTRL - Reset controller
;*************************************************************************

.equ RSTCTRL_RSTFR = 0x0040              ; Reset Flags
.equ RSTCTRL_SWRR = 0x0041               ; Software Reset

;*************************************************************************
;** RTC - Real-Time Counter
;*************************************************************************

.equ RTC_CTRLA = 0x0140                  ; Control A
.equ RTC_STATUS = 0x0141                 ; Status
.equ RTC_INTCTRL = 0x0142                ; Interrupt Control
.equ RTC_INTFLAGS = 0x0143               ; Interrupt Flags
.equ RTC_TEMP = 0x0144                   ; Temporary
.equ RTC_DBGCTRL = 0x0145                ; Debug control
.equ RTC_CALIB = 0x0146                  ; Calibration
.equ RTC_CLKSEL = 0x0147                 ; Clock Select
.equ RTC_CNT = 0x0148                    ; Counter
.equ RTC_CNTL = 0x0148                   ; Counter low byte
.equ RTC_CNTH = 0x0149                   ; Counter hi byte
.equ RTC_PER = 0x014A                    ; Period
.equ RTC_PERL = 0x014A                   ; Period low byte
.equ RTC_PERH = 0x014B                   ; Period hi byte
.equ RTC_CMP = 0x014C                    ; Compare
.equ RTC_CMPL = 0x014C                   ; Compare low byte
.equ RTC_CMPH = 0x014D                   ; Compare hi byte
.equ RTC_PITCTRLA = 0x0150               ; PIT Control A
.equ RTC_PITSTATUS = 0x0151              ; PIT Status
.equ RTC_PITINTCTRL = 0x0152             ; PIT Interrupt Control
.equ RTC_PITINTFLAGS = 0x0153            ; PIT Interrupt Flags
.equ RTC_PITDBGCTRL = 0x0155             ; PIT Debug control
.equ RTC_PITEVGENCTRLA = 0x0156          ; PIT Event Generation Control A

;*************************************************************************
;** SIGROW - Signature row
;*************************************************************************

.equ SIGROW_DEVICEID0 = 0x1080           ; Device ID Byte 0
.equ SIGROW_DEVICEID1 = 0x1081           ; Device ID Byte 1
.equ SIGROW_DEVICEID2 = 0x1082           ; Device ID Byte 2
.equ SIGROW_TEMPSENSE0 = 0x1084          ; Temperature Calibration 0
.equ SIGROW_TEMPSENSE0L = 0x1084         ; Temperature Calibration 0 low byte
.equ SIGROW_TEMPSENSE0H = 0x1085         ; Temperature Calibration 0 hi byte
.equ SIGROW_TEMPSENSE1 = 0x1086          ; Temperature Calibration 1
.equ SIGROW_TEMPSENSE1L = 0x1086         ; Temperature Calibration 1 low byte
.equ SIGROW_TEMPSENSE1H = 0x1087         ; Temperature Calibration 1 hi byte
.equ SIGROW_SERNUM0 = 0x1090             ; LOTNUM0
.equ SIGROW_SERNUM1 = 0x1091             ; LOTNUM1
.equ SIGROW_SERNUM2 = 0x1092             ; LOTNUM2
.equ SIGROW_SERNUM3 = 0x1093             ; LOTNUM3
.equ SIGROW_SERNUM4 = 0x1094             ; LOTNUM4
.equ SIGROW_SERNUM5 = 0x1095             ; LOTNUM5
.equ SIGROW_SERNUM6 = 0x1096             ; RANDOM
.equ SIGROW_SERNUM7 = 0x1097             ; SCRIBE
.equ SIGROW_SERNUM8 = 0x1098             ; XPOS0
.equ SIGROW_SERNUM9 = 0x1099             ; XPOS1
.equ SIGROW_SERNUM10 = 0x109A            ; YPOS0
.equ SIGROW_SERNUM11 = 0x109B            ; YPOS1
.equ SIGROW_SERNUM12 = 0x109C            ; RES0
.equ SIGROW_SERNUM13 = 0x109D            ; RES1
.equ SIGROW_SERNUM14 = 0x109E            ; RES2
.equ SIGROW_SERNUM15 = 0x109F            ; RES3

;*************************************************************************
;** SLPCTRL - Sleep Controller
;*************************************************************************

.equ SLPCTRL_CTRLA = 0x0050              ; Control A
.equ SLPCTRL_VREGCTRL = 0x0051           ; Control B

;*************************************************************************
;** SPI0 - Serial Peripheral Interface
;*************************************************************************

.equ SPI0_CTRLA = 0x0940                 ; Control A
.equ SPI0_CTRLB = 0x0941                 ; Control B
.equ SPI0_INTCTRL = 0x0942               ; Interrupt Control
.equ SPI0_INTFLAGS = 0x0943              ; Interrupt Flags
.equ SPI0_DATA = 0x0944                  ; Data

;*************************************************************************
;** SYSCFG - System Configuration Registers
;*************************************************************************

.equ SYSCFG_REVID = 0x0F01               ; Revision ID
.equ SYSCFG_VUSBCTRL = 0x0F06            ; USB Voltage System Control

;*************************************************************************
;** TCA0 - 16-bit Timer/Counter Type A
;*************************************************************************

.equ TCA0_SINGLE_CTRLA = 0x0A00          ; SINGLE Control A
.equ TCA0_SPLIT_CTRLA = 0x0A00           ; SPLIT Control A
.equ TCA0_SINGLE_CTRLB = 0x0A01          ; SINGLE Control B
.equ TCA0_SPLIT_CTRLB = 0x0A01           ; SPLIT Control B
.equ TCA0_SINGLE_CTRLC = 0x0A02          ; SINGLE Control C
.equ TCA0_SPLIT_CTRLC = 0x0A02           ; SPLIT Control C
.equ TCA0_SINGLE_CTRLD = 0x0A03          ; SINGLE Control D
.equ TCA0_SPLIT_CTRLD = 0x0A03           ; SPLIT Control D
.equ TCA0_SINGLE_CTRLECLR = 0x0A04       ; SINGLE Control E Clear
.equ TCA0_SPLIT_CTRLECLR = 0x0A04        ; SPLIT Control E Clear
.equ TCA0_SINGLE_CTRLESET = 0x0A05       ; SINGLE Control E Set
.equ TCA0_SPLIT_CTRLESET = 0x0A05        ; SPLIT Control E Set
.equ TCA0_SINGLE_CTRLFCLR = 0x0A06       ; SINGLE Control F Clear
.equ TCA0_SINGLE_CTRLFSET = 0x0A07       ; SINGLE Control F Set
.equ TCA0_SINGLE_EVCTRL = 0x0A09         ; SINGLE Event Control
.equ TCA0_SINGLE_INTCTRL = 0x0A0A        ; SINGLE Interrupt Control
.equ TCA0_SPLIT_INTCTRL = 0x0A0A         ; SPLIT Interrupt Control
.equ TCA0_SINGLE_INTFLAGS = 0x0A0B       ; SINGLE Interrupt Flags
.equ TCA0_SPLIT_INTFLAGS = 0x0A0B        ; SPLIT Interrupt Flags
.equ TCA0_SINGLE_DBGCTRL = 0x0A0E        ; SINGLE Debug Control
.equ TCA0_SPLIT_DBGCTRL = 0x0A0E         ; SPLIT Debug Control
.equ TCA0_SINGLE_TEMP = 0x0A0F           ; SINGLE Temporary data for 16-bit Access
.equ TCA0_SINGLE_CNT = 0x0A20            ; SINGLE Count
.equ TCA0_SINGLE_CNTL = 0x0A20           ; SINGLE Count low byte
.equ TCA0_SINGLE_CNTH = 0x0A21           ; SINGLE Count hi byte
.equ TCA0_SPLIT_LCNT = 0x0A20            ; SPLIT Low Count
.equ TCA0_SPLIT_HCNT = 0x0A21            ; SPLIT High Count
.equ TCA0_SINGLE_PER = 0x0A26            ; SINGLE Period
.equ TCA0_SINGLE_PERL = 0x0A26           ; SINGLE Period low byte
.equ TCA0_SINGLE_PERH = 0x0A27           ; SINGLE Period hi byte
.equ TCA0_SPLIT_LPER = 0x0A26            ; SPLIT Low Period
.equ TCA0_SPLIT_HPER = 0x0A27            ; SPLIT High Period
.equ TCA0_SINGLE_CMP0 = 0x0A28           ; SINGLE Compare 0
.equ TCA0_SINGLE_CMP0L = 0x0A28          ; SINGLE Compare 0 low byte
.equ TCA0_SINGLE_CMP0H = 0x0A29          ; SINGLE Compare 0 hi byte
.equ TCA0_SPLIT_LCMP0 = 0x0A28           ; SPLIT Low Compare
.equ TCA0_SPLIT_HCMP0 = 0x0A29           ; SPLIT High Compare
.equ TCA0_SINGLE_CMP1 = 0x0A2A           ; SINGLE Compare 1
.equ TCA0_SINGLE_CMP1L = 0x0A2A          ; SINGLE Compare 1 low byte
.equ TCA0_SINGLE_CMP1H = 0x0A2B          ; SINGLE Compare 1 hi byte
.equ TCA0_SPLIT_LCMP1 = 0x0A2A           ; SPLIT Low Compare
.equ TCA0_SPLIT_HCMP1 = 0x0A2B           ; SPLIT High Compare
.equ TCA0_SINGLE_CMP2 = 0x0A2C           ; SINGLE Compare 2
.equ TCA0_SINGLE_CMP2L = 0x0A2C          ; SINGLE Compare 2 low byte
.equ TCA0_SINGLE_CMP2H = 0x0A2D          ; SINGLE Compare 2 hi byte
.equ TCA0_SPLIT_LCMP2 = 0x0A2C           ; SPLIT Low Compare
.equ TCA0_SPLIT_HCMP2 = 0x0A2D           ; SPLIT High Compare
.equ TCA0_SINGLE_PERBUF = 0x0A36         ; SINGLE Period Buffer
.equ TCA0_SINGLE_PERBUFL = 0x0A36        ; SINGLE Period Buffer low byte
.equ TCA0_SINGLE_PERBUFH = 0x0A37        ; SINGLE Period Buffer hi byte
.equ TCA0_SINGLE_CMP0BUF = 0x0A38        ; SINGLE Compare 0 Buffer
.equ TCA0_SINGLE_CMP0BUFL = 0x0A38       ; SINGLE Compare 0 Buffer low byte
.equ TCA0_SINGLE_CMP0BUFH = 0x0A39       ; SINGLE Compare 0 Buffer hi byte
.equ TCA0_SINGLE_CMP1BUF = 0x0A3A        ; SINGLE Compare 1 Buffer
.equ TCA0_SINGLE_CMP1BUFL = 0x0A3A       ; SINGLE Compare 1 Buffer low byte
.equ TCA0_SINGLE_CMP1BUFH = 0x0A3B       ; SINGLE Compare 1 Buffer hi byte
.equ TCA0_SINGLE_CMP2BUF = 0x0A3C        ; SINGLE Compare 2 Buffer
.equ TCA0_SINGLE_CMP2BUFL = 0x0A3C       ; SINGLE Compare 2 Buffer low byte
.equ TCA0_SINGLE_CMP2BUFH = 0x0A3D       ; SINGLE Compare 2 Buffer hi byte

;*************************************************************************
;** TCB0 - 16-bit Timer Type B
;*************************************************************************

.equ TCB0_CTRLA = 0x0B00                 ; Control A
.equ TCB0_CTRLB = 0x0B01                 ; Control Register B
.equ TCB0_EVCTRL = 0x0B04                ; Event Control
.equ TCB0_INTCTRL = 0x0B05               ; Interrupt Control
.equ TCB0_INTFLAGS = 0x0B06              ; Interrupt Flags
.equ TCB0_STATUS = 0x0B07                ; Status
.equ TCB0_DBGCTRL = 0x0B08               ; Debug Control
.equ TCB0_TEMP = 0x0B09                  ; Temporary Value
.equ TCB0_CNT = 0x0B0A                   ; Count
.equ TCB0_CNTL = 0x0B0A                  ; Count low byte
.equ TCB0_CNTH = 0x0B0B                  ; Count hi byte
.equ TCB0_CCMP = 0x0B0C                  ; Compare or Capture
.equ TCB0_CCMPL = 0x0B0C                 ; Compare or Capture low byte
.equ TCB0_CCMPH = 0x0B0D                 ; Compare or Capture hi byte

;*************************************************************************
;** TCB1 - 16-bit Timer Type B
;*************************************************************************

.equ TCB1_CTRLA = 0x0B10                 ; Control A
.equ TCB1_CTRLB = 0x0B11                 ; Control Register B
.equ TCB1_EVCTRL = 0x0B14                ; Event Control
.equ TCB1_INTCTRL = 0x0B15               ; Interrupt Control
.equ TCB1_INTFLAGS = 0x0B16              ; Interrupt Flags
.equ TCB1_STATUS = 0x0B17                ; Status
.equ TCB1_DBGCTRL = 0x0B18               ; Debug Control
.equ TCB1_TEMP = 0x0B19                  ; Temporary Value
.equ TCB1_CNT = 0x0B1A                   ; Count
.equ TCB1_CNTL = 0x0B1A                  ; Count low byte
.equ TCB1_CNTH = 0x0B1B                  ; Count hi byte
.equ TCB1_CCMP = 0x0B1C                  ; Compare or Capture
.equ TCB1_CCMPL = 0x0B1C                 ; Compare or Capture low byte
.equ TCB1_CCMPH = 0x0B1D                 ; Compare or Capture hi byte

;*************************************************************************
;** TWI0 - Two-Wire Interface
;*************************************************************************

.equ TWI0_CTRLA = 0x0900                 ; Control A
.equ TWI0_DBGCTRL = 0x0902               ; Debug Control
.equ TWI0_MCTRLA = 0x0903                ; Host Control A
.equ TWI0_MCTRLB = 0x0904                ; Host Control B
.equ TWI0_MSTATUS = 0x0905               ; Host STATUS
.equ TWI0_MBAUD = 0x0906                 ; Host Baud Rate
.equ TWI0_MADDR = 0x0907                 ; Host Address
.equ TWI0_MDATA = 0x0908                 ; Host Data
.equ TWI0_SCTRLA = 0x0909                ; Client Control A
.equ TWI0_SCTRLB = 0x090A                ; Client Control B
.equ TWI0_SSTATUS = 0x090B               ; Client Status
.equ TWI0_SADDR = 0x090C                 ; Client Address
.equ TWI0_SDATA = 0x090D                 ; Client Data
.equ TWI0_SADDRMASK = 0x090E             ; Client Address Mask

;*************************************************************************
;** USART0 - Universal Synchronous and Asynchronous Receiver and Transmitter
;*************************************************************************

.equ USART0_RXDATAL = 0x0800             ; Receive Data Low Byte
.equ USART0_RXDATAH = 0x0801             ; Receive Data High Byte
.equ USART0_TXDATAL = 0x0802             ; Transmit Data Low Byte
.equ USART0_TXDATAH = 0x0803             ; Transmit Data High Byte
.equ USART0_STATUS = 0x0804              ; Status
.equ USART0_CTRLA = 0x0805               ; Control A
.equ USART0_CTRLB = 0x0806               ; Control B
.equ USART0_CTRLC = 0x0807               ; Control C
.equ USART0_BAUD = 0x0808                ; Baud Rate
.equ USART0_BAUDL = 0x0808               ; Baud Rate low byte
.equ USART0_BAUDH = 0x0809               ; Baud Rate hi byte
.equ USART0_CTRLD = 0x080A               ; Control D
.equ USART0_DBGCTRL = 0x080B             ; Debug Control
.equ USART0_EVCTRL = 0x080C              ; Event Control
.equ USART0_TXPLCTRL = 0x080D            ; IRCOM Transmitter Pulse Length Control
.equ USART0_RXPLCTRL = 0x080E            ; IRCOM Receiver Pulse Length Control

;*************************************************************************
;** USART1 - Universal Synchronous and Asynchronous Receiver and Transmitter
;*************************************************************************

.equ USART1_RXDATAL = 0x0820             ; Receive Data Low Byte
.equ USART1_RXDATAH = 0x0821             ; Receive Data High Byte
.equ USART1_TXDATAL = 0x0822             ; Transmit Data Low Byte
.equ USART1_TXDATAH = 0x0823             ; Transmit Data High Byte
.equ USART1_STATUS = 0x0824              ; Status
.equ USART1_CTRLA = 0x0825               ; Control A
.equ USART1_CTRLB = 0x0826               ; Control B
.equ USART1_CTRLC = 0x0827               ; Control C
.equ USART1_BAUD = 0x0828                ; Baud Rate
.equ USART1_BAUDL = 0x0828               ; Baud Rate low byte
.equ USART1_BAUDH = 0x0829               ; Baud Rate hi byte
.equ USART1_CTRLD = 0x082A               ; Control D
.equ USART1_DBGCTRL = 0x082B             ; Debug Control
.equ USART1_EVCTRL = 0x082C              ; Event Control
.equ USART1_TXPLCTRL = 0x082D            ; IRCOM Transmitter Pulse Length Control
.equ USART1_RXPLCTRL = 0x082E            ; IRCOM Receiver Pulse Length Control

;*************************************************************************
;** USB0 - USB Device Controller
;*************************************************************************

.equ USB0_CTRLA = 0x0C00                 ; Control A
.equ USB0_CTRLB = 0x0C01                 ; Control B
.equ USB0_BUSSTATE = 0x0C02              ; Bus State
.equ USB0_ADDR = 0x0C03                  ; Address
.equ USB0_FIFOWP = 0x0C04                ; FIFO Write Pointer
.equ USB0_FIFORP = 0x0C05                ; FIFO Read Pointer
.equ USB0_EPPTR = 0x0C06                 ; Endpoint Configuration Table Pointer
.equ USB0_EPPTRL = 0x0C06                ; Endpoint Configuration Table Pointer low byte
.equ USB0_EPPTRH = 0x0C07                ; Endpoint Configuration Table Pointer hi byte
.equ USB0_INTCTRLA = 0x0C08              ; Interrupt Control A
.equ USB0_INTCTRLB = 0x0C09              ; Interrupt Control B
.equ USB0_INTFLAGSA = 0x0C0A             ; Interrupt Flags A
.equ USB0_INTFLAGSB = 0x0C0B             ; Interrupt Flags B
.equ USB0_STATUS0_OUTCLR = 0x0C40        ; Endpoint n OUT Status Clear
.equ USB0_STATUS0_OUTSET = 0x0C41        ; Endpoint n OUT Status Set
.equ USB0_STATUS0_INCLR = 0x0C42         ; Endpoint n IN Status Clear
.equ USB0_STATUS0_INSET = 0x0C43         ; Endpoint n IN Status Set
.equ USB0_STATUS1_OUTCLR = 0x0C44        ; Endpoint n OUT Status Clear
.equ USB0_STATUS1_OUTSET = 0x0C45        ; Endpoint n OUT Status Set
.equ USB0_STATUS1_INCLR = 0x0C46         ; Endpoint n IN Status Clear
.equ USB0_STATUS1_INSET = 0x0C47         ; Endpoint n IN Status Set
.equ USB0_STATUS2_OUTCLR = 0x0C48        ; Endpoint n OUT Status Clear
.equ USB0_STATUS2_OUTSET = 0x0C49        ; Endpoint n OUT Status Set
.equ USB0_STATUS2_INCLR = 0x0C4A         ; Endpoint n IN Status Clear
.equ USB0_STATUS2_INSET = 0x0C4B         ; Endpoint n IN Status Set
.equ USB0_STATUS3_OUTCLR = 0x0C4C        ; Endpoint n OUT Status Clear
.equ USB0_STATUS3_OUTSET = 0x0C4D        ; Endpoint n OUT Status Set
.equ USB0_STATUS3_INCLR = 0x0C4E         ; Endpoint n IN Status Clear
.equ USB0_STATUS3_INSET = 0x0C4F         ; Endpoint n IN Status Set
.equ USB0_STATUS4_OUTCLR = 0x0C50        ; Endpoint n OUT Status Clear
.equ USB0_STATUS4_OUTSET = 0x0C51        ; Endpoint n OUT Status Set
.equ USB0_STATUS4_INCLR = 0x0C52         ; Endpoint n IN Status Clear
.equ USB0_STATUS4_INSET = 0x0C53         ; Endpoint n IN Status Set
.equ USB0_STATUS5_OUTCLR = 0x0C54        ; Endpoint n OUT Status Clear
.equ USB0_STATUS5_OUTSET = 0x0C55        ; Endpoint n OUT Status Set
.equ USB0_STATUS5_INCLR = 0x0C56         ; Endpoint n IN Status Clear
.equ USB0_STATUS5_INSET = 0x0C57         ; Endpoint n IN Status Set
.equ USB0_STATUS6_OUTCLR = 0x0C58        ; Endpoint n OUT Status Clear
.equ USB0_STATUS6_OUTSET = 0x0C59        ; Endpoint n OUT Status Set
.equ USB0_STATUS6_INCLR = 0x0C5A         ; Endpoint n IN Status Clear
.equ USB0_STATUS6_INSET = 0x0C5B         ; Endpoint n IN Status Set
.equ USB0_STATUS7_OUTCLR = 0x0C5C        ; Endpoint n OUT Status Clear
.equ USB0_STATUS7_OUTSET = 0x0C5D        ; Endpoint n OUT Status Set
.equ USB0_STATUS7_INCLR = 0x0C5E         ; Endpoint n IN Status Clear
.equ USB0_STATUS7_INSET = 0x0C5F         ; Endpoint n IN Status Set
.equ USB0_STATUS8_OUTCLR = 0x0C60        ; Endpoint n OUT Status Clear
.equ USB0_STATUS8_OUTSET = 0x0C61        ; Endpoint n OUT Status Set
.equ USB0_STATUS8_INCLR = 0x0C62         ; Endpoint n IN Status Clear
.equ USB0_STATUS8_INSET = 0x0C63         ; Endpoint n IN Status Set
.equ USB0_STATUS9_OUTCLR = 0x0C64        ; Endpoint n OUT Status Clear
.equ USB0_STATUS9_OUTSET = 0x0C65        ; Endpoint n OUT Status Set
.equ USB0_STATUS9_INCLR = 0x0C66         ; Endpoint n IN Status Clear
.equ USB0_STATUS9_INSET = 0x0C67         ; Endpoint n IN Status Set
.equ USB0_STATUS10_OUTCLR = 0x0C68       ; Endpoint n OUT Status Clear
.equ USB0_STATUS10_OUTSET = 0x0C69       ; Endpoint n OUT Status Set
.equ USB0_STATUS10_INCLR = 0x0C6A        ; Endpoint n IN Status Clear
.equ USB0_STATUS10_INSET = 0x0C6B        ; Endpoint n IN Status Set
.equ USB0_STATUS11_OUTCLR = 0x0C6C       ; Endpoint n OUT Status Clear
.equ USB0_STATUS11_OUTSET = 0x0C6D       ; Endpoint n OUT Status Set
.equ USB0_STATUS11_INCLR = 0x0C6E        ; Endpoint n IN Status Clear
.equ USB0_STATUS11_INSET = 0x0C6F        ; Endpoint n IN Status Set
.equ USB0_STATUS12_OUTCLR = 0x0C70       ; Endpoint n OUT Status Clear
.equ USB0_STATUS12_OUTSET = 0x0C71       ; Endpoint n OUT Status Set
.equ USB0_STATUS12_INCLR = 0x0C72        ; Endpoint n IN Status Clear
.equ USB0_STATUS12_INSET = 0x0C73        ; Endpoint n IN Status Set
.equ USB0_STATUS13_OUTCLR = 0x0C74       ; Endpoint n OUT Status Clear
.equ USB0_STATUS13_OUTSET = 0x0C75       ; Endpoint n OUT Status Set
.equ USB0_STATUS13_INCLR = 0x0C76        ; Endpoint n IN Status Clear
.equ USB0_STATUS13_INSET = 0x0C77        ; Endpoint n IN Status Set
.equ USB0_STATUS14_OUTCLR = 0x0C78       ; Endpoint n OUT Status Clear
.equ USB0_STATUS14_OUTSET = 0x0C79       ; Endpoint n OUT Status Set
.equ USB0_STATUS14_INCLR = 0x0C7A        ; Endpoint n IN Status Clear
.equ USB0_STATUS14_INSET = 0x0C7B        ; Endpoint n IN Status Set
.equ USB0_STATUS15_OUTCLR = 0x0C7C       ; Endpoint n OUT Status Clear
.equ USB0_STATUS15_OUTSET = 0x0C7D       ; Endpoint n OUT Status Set
.equ USB0_STATUS15_INCLR = 0x0C7E        ; Endpoint n IN Status Clear
.equ USB0_STATUS15_INSET = 0x0C7F        ; Endpoint n IN Status Set

;*************************************************************************
;** USERROW - User Row
;*************************************************************************

.equ USERROW_USERROW0 = 0x1200           ; User Row 0
.equ USERROW_USERROW1 = 0x1201           ; User Row 1
.equ USERROW_USERROW2 = 0x1202           ; User Row 2
.equ USERROW_USERROW3 = 0x1203           ; User Row 3
.equ USERROW_USERROW4 = 0x1204           ; User Row 4
.equ USERROW_USERROW5 = 0x1205           ; User Row 5
.equ USERROW_USERROW6 = 0x1206           ; User Row 6
.equ USERROW_USERROW7 = 0x1207           ; User Row 7
.equ USERROW_USERROW8 = 0x1208           ; User Row 8
.equ USERROW_USERROW9 = 0x1209           ; User Row 9
.equ USERROW_USERROW10 = 0x120A          ; User Row 10
.equ USERROW_USERROW11 = 0x120B          ; User Row 11
.equ USERROW_USERROW12 = 0x120C          ; User Row 12
.equ USERROW_USERROW13 = 0x120D          ; User Row 13
.equ USERROW_USERROW14 = 0x120E          ; User Row 14
.equ USERROW_USERROW15 = 0x120F          ; User Row 15
.equ USERROW_USERROW16 = 0x1210          ; User Row 16
.equ USERROW_USERROW17 = 0x1211          ; User Row 17
.equ USERROW_USERROW18 = 0x1212          ; User Row 18
.equ USERROW_USERROW19 = 0x1213          ; User Row 19
.equ USERROW_USERROW20 = 0x1214          ; User Row 20
.equ USERROW_USERROW21 = 0x1215          ; User Row 21
.equ USERROW_USERROW22 = 0x1216          ; User Row 22
.equ USERROW_USERROW23 = 0x1217          ; User Row 23
.equ USERROW_USERROW24 = 0x1218          ; User Row 24
.equ USERROW_USERROW25 = 0x1219          ; User Row 25
.equ USERROW_USERROW26 = 0x121A          ; User Row 26
.equ USERROW_USERROW27 = 0x121B          ; User Row 27
.equ USERROW_USERROW28 = 0x121C          ; User Row 28
.equ USERROW_USERROW29 = 0x121D          ; User Row 29
.equ USERROW_USERROW30 = 0x121E          ; User Row 30
.equ USERROW_USERROW31 = 0x121F          ; User Row 31
.equ USERROW_USERROW32 = 0x1220          ; User Row 32
.equ USERROW_USERROW33 = 0x1221          ; User Row 33
.equ USERROW_USERROW34 = 0x1222          ; User Row 34
.equ USERROW_USERROW35 = 0x1223          ; User Row 35
.equ USERROW_USERROW36 = 0x1224          ; User Row 36
.equ USERROW_USERROW37 = 0x1225          ; User Row 37
.equ USERROW_USERROW38 = 0x1226          ; User Row 38
.equ USERROW_USERROW39 = 0x1227          ; User Row 39
.equ USERROW_USERROW40 = 0x1228          ; User Row 40
.equ USERROW_USERROW41 = 0x1229          ; User Row 41
.equ USERROW_USERROW42 = 0x122A          ; User Row 42
.equ USERROW_USERROW43 = 0x122B          ; User Row 43
.equ USERROW_USERROW44 = 0x122C          ; User Row 44
.equ USERROW_USERROW45 = 0x122D          ; User Row 45
.equ USERROW_USERROW46 = 0x122E          ; User Row 46
.equ USERROW_USERROW47 = 0x122F          ; User Row 47
.equ USERROW_USERROW48 = 0x1230          ; User Row 48
.equ USERROW_USERROW49 = 0x1231          ; User Row 49
.equ USERROW_USERROW50 = 0x1232          ; User Row 50
.equ USERROW_USERROW51 = 0x1233          ; User Row 51
.equ USERROW_USERROW52 = 0x1234          ; User Row 52
.equ USERROW_USERROW53 = 0x1235          ; User Row 53
.equ USERROW_USERROW54 = 0x1236          ; User Row 54
.equ USERROW_USERROW55 = 0x1237          ; User Row 55
.equ USERROW_USERROW56 = 0x1238          ; User Row 56
.equ USERROW_USERROW57 = 0x1239          ; User Row 57
.equ USERROW_USERROW58 = 0x123A          ; User Row 58
.equ USERROW_USERROW59 = 0x123B          ; User Row 59
.equ USERROW_USERROW60 = 0x123C          ; User Row 60
.equ USERROW_USERROW61 = 0x123D          ; User Row 61
.equ USERROW_USERROW62 = 0x123E          ; User Row 62
.equ USERROW_USERROW63 = 0x123F          ; User Row 63
.equ USERROW_USERROW64 = 0x1240          ; User Row 64
.equ USERROW_USERROW65 = 0x1241          ; User Row 65
.equ USERROW_USERROW66 = 0x1242          ; User Row 66
.equ USERROW_USERROW67 = 0x1243          ; User Row 67
.equ USERROW_USERROW68 = 0x1244          ; User Row 68
.equ USERROW_USERROW69 = 0x1245          ; User Row 69
.equ USERROW_USERROW70 = 0x1246          ; User Row 70
.equ USERROW_USERROW71 = 0x1247          ; User Row 71
.equ USERROW_USERROW72 = 0x1248          ; User Row 72
.equ USERROW_USERROW73 = 0x1249          ; User Row 73
.equ USERROW_USERROW74 = 0x124A          ; User Row 74
.equ USERROW_USERROW75 = 0x124B          ; User Row 75
.equ USERROW_USERROW76 = 0x124C          ; User Row 76
.equ USERROW_USERROW77 = 0x124D          ; User Row 77
.equ USERROW_USERROW78 = 0x124E          ; User Row 78
.equ USERROW_USERROW79 = 0x124F          ; User Row 79
.equ USERROW_USERROW80 = 0x1250          ; User Row 80
.equ USERROW_USERROW81 = 0x1251          ; User Row 81
.equ USERROW_USERROW82 = 0x1252          ; User Row 82
.equ USERROW_USERROW83 = 0x1253          ; User Row 83
.equ USERROW_USERROW84 = 0x1254          ; User Row 84
.equ USERROW_USERROW85 = 0x1255          ; User Row 85
.equ USERROW_USERROW86 = 0x1256          ; User Row 86
.equ USERROW_USERROW87 = 0x1257          ; User Row 87
.equ USERROW_USERROW88 = 0x1258          ; User Row 88
.equ USERROW_USERROW89 = 0x1259          ; User Row 89
.equ USERROW_USERROW90 = 0x125A          ; User Row 90
.equ USERROW_USERROW91 = 0x125B          ; User Row 91
.equ USERROW_USERROW92 = 0x125C          ; User Row 92
.equ USERROW_USERROW93 = 0x125D          ; User Row 93
.equ USERROW_USERROW94 = 0x125E          ; User Row 94
.equ USERROW_USERROW95 = 0x125F          ; User Row 95
.equ USERROW_USERROW96 = 0x1260          ; User Row 96
.equ USERROW_USERROW97 = 0x1261          ; User Row 97
.equ USERROW_USERROW98 = 0x1262          ; User Row 98
.equ USERROW_USERROW99 = 0x1263          ; User Row 99
.equ USERROW_USERROW100 = 0x1264         ; User Row 100
.equ USERROW_USERROW101 = 0x1265         ; User Row 101
.equ USERROW_USERROW102 = 0x1266         ; User Row 102
.equ USERROW_USERROW103 = 0x1267         ; User Row 103
.equ USERROW_USERROW104 = 0x1268         ; User Row 104
.equ USERROW_USERROW105 = 0x1269         ; User Row 105
.equ USERROW_USERROW106 = 0x126A         ; User Row 106
.equ USERROW_USERROW107 = 0x126B         ; User Row 107
.equ USERROW_USERROW108 = 0x126C         ; User Row 108
.equ USERROW_USERROW109 = 0x126D         ; User Row 109
.equ USERROW_USERROW110 = 0x126E         ; User Row 110
.equ USERROW_USERROW111 = 0x126F         ; User Row 111
.equ USERROW_USERROW112 = 0x1270         ; User Row 112
.equ USERROW_USERROW113 = 0x1271         ; User Row 113
.equ USERROW_USERROW114 = 0x1272         ; User Row 114
.equ USERROW_USERROW115 = 0x1273         ; User Row 115
.equ USERROW_USERROW116 = 0x1274         ; User Row 116
.equ USERROW_USERROW117 = 0x1275         ; User Row 117
.equ USERROW_USERROW118 = 0x1276         ; User Row 118
.equ USERROW_USERROW119 = 0x1277         ; User Row 119
.equ USERROW_USERROW120 = 0x1278         ; User Row 120
.equ USERROW_USERROW121 = 0x1279         ; User Row 121
.equ USERROW_USERROW122 = 0x127A         ; User Row 122
.equ USERROW_USERROW123 = 0x127B         ; User Row 123
.equ USERROW_USERROW124 = 0x127C         ; User Row 124
.equ USERROW_USERROW125 = 0x127D         ; User Row 125
.equ USERROW_USERROW126 = 0x127E         ; User Row 126
.equ USERROW_USERROW127 = 0x127F         ; User Row 127
.equ USERROW_USERROW128 = 0x1280         ; User Row 128
.equ USERROW_USERROW129 = 0x1281         ; User Row 129
.equ USERROW_USERROW130 = 0x1282         ; User Row 130
.equ USERROW_USERROW131 = 0x1283         ; User Row 131
.equ USERROW_USERROW132 = 0x1284         ; User Row 132
.equ USERROW_USERROW133 = 0x1285         ; User Row 133
.equ USERROW_USERROW134 = 0x1286         ; User Row 134
.equ USERROW_USERROW135 = 0x1287         ; User Row 135
.equ USERROW_USERROW136 = 0x1288         ; User Row 136
.equ USERROW_USERROW137 = 0x1289         ; User Row 137
.equ USERROW_USERROW138 = 0x128A         ; User Row 138
.equ USERROW_USERROW139 = 0x128B         ; User Row 139
.equ USERROW_USERROW140 = 0x128C         ; User Row 140
.equ USERROW_USERROW141 = 0x128D         ; User Row 141
.equ USERROW_USERROW142 = 0x128E         ; User Row 142
.equ USERROW_USERROW143 = 0x128F         ; User Row 143
.equ USERROW_USERROW144 = 0x1290         ; User Row 144
.equ USERROW_USERROW145 = 0x1291         ; User Row 145
.equ USERROW_USERROW146 = 0x1292         ; User Row 146
.equ USERROW_USERROW147 = 0x1293         ; User Row 147
.equ USERROW_USERROW148 = 0x1294         ; User Row 148
.equ USERROW_USERROW149 = 0x1295         ; User Row 149
.equ USERROW_USERROW150 = 0x1296         ; User Row 150
.equ USERROW_USERROW151 = 0x1297         ; User Row 151
.equ USERROW_USERROW152 = 0x1298         ; User Row 152
.equ USERROW_USERROW153 = 0x1299         ; User Row 153
.equ USERROW_USERROW154 = 0x129A         ; User Row 154
.equ USERROW_USERROW155 = 0x129B         ; User Row 155
.equ USERROW_USERROW156 = 0x129C         ; User Row 156
.equ USERROW_USERROW157 = 0x129D         ; User Row 157
.equ USERROW_USERROW158 = 0x129E         ; User Row 158
.equ USERROW_USERROW159 = 0x129F         ; User Row 159
.equ USERROW_USERROW160 = 0x12A0         ; User Row 160
.equ USERROW_USERROW161 = 0x12A1         ; User Row 161
.equ USERROW_USERROW162 = 0x12A2         ; User Row 162
.equ USERROW_USERROW163 = 0x12A3         ; User Row 163
.equ USERROW_USERROW164 = 0x12A4         ; User Row 164
.equ USERROW_USERROW165 = 0x12A5         ; User Row 165
.equ USERROW_USERROW166 = 0x12A6         ; User Row 166
.equ USERROW_USERROW167 = 0x12A7         ; User Row 167
.equ USERROW_USERROW168 = 0x12A8         ; User Row 168
.equ USERROW_USERROW169 = 0x12A9         ; User Row 169
.equ USERROW_USERROW170 = 0x12AA         ; User Row 170
.equ USERROW_USERROW171 = 0x12AB         ; User Row 171
.equ USERROW_USERROW172 = 0x12AC         ; User Row 172
.equ USERROW_USERROW173 = 0x12AD         ; User Row 173
.equ USERROW_USERROW174 = 0x12AE         ; User Row 174
.equ USERROW_USERROW175 = 0x12AF         ; User Row 175
.equ USERROW_USERROW176 = 0x12B0         ; User Row 176
.equ USERROW_USERROW177 = 0x12B1         ; User Row 177
.equ USERROW_USERROW178 = 0x12B2         ; User Row 178
.equ USERROW_USERROW179 = 0x12B3         ; User Row 179
.equ USERROW_USERROW180 = 0x12B4         ; User Row 180
.equ USERROW_USERROW181 = 0x12B5         ; User Row 181
.equ USERROW_USERROW182 = 0x12B6         ; User Row 182
.equ USERROW_USERROW183 = 0x12B7         ; User Row 183
.equ USERROW_USERROW184 = 0x12B8         ; User Row 184
.equ USERROW_USERROW185 = 0x12B9         ; User Row 185
.equ USERROW_USERROW186 = 0x12BA         ; User Row 186
.equ USERROW_USERROW187 = 0x12BB         ; User Row 187
.equ USERROW_USERROW188 = 0x12BC         ; User Row 188
.equ USERROW_USERROW189 = 0x12BD         ; User Row 189
.equ USERROW_USERROW190 = 0x12BE         ; User Row 190
.equ USERROW_USERROW191 = 0x12BF         ; User Row 191
.equ USERROW_USERROW192 = 0x12C0         ; User Row 192
.equ USERROW_USERROW193 = 0x12C1         ; User Row 193
.equ USERROW_USERROW194 = 0x12C2         ; User Row 194
.equ USERROW_USERROW195 = 0x12C3         ; User Row 195
.equ USERROW_USERROW196 = 0x12C4         ; User Row 196
.equ USERROW_USERROW197 = 0x12C5         ; User Row 197
.equ USERROW_USERROW198 = 0x12C6         ; User Row 198
.equ USERROW_USERROW199 = 0x12C7         ; User Row 199
.equ USERROW_USERROW200 = 0x12C8         ; User Row 200
.equ USERROW_USERROW201 = 0x12C9         ; User Row 201
.equ USERROW_USERROW202 = 0x12CA         ; User Row 202
.equ USERROW_USERROW203 = 0x12CB         ; User Row 203
.equ USERROW_USERROW204 = 0x12CC         ; User Row 204
.equ USERROW_USERROW205 = 0x12CD         ; User Row 205
.equ USERROW_USERROW206 = 0x12CE         ; User Row 206
.equ USERROW_USERROW207 = 0x12CF         ; User Row 207
.equ USERROW_USERROW208 = 0x12D0         ; User Row 208
.equ USERROW_USERROW209 = 0x12D1         ; User Row 209
.equ USERROW_USERROW210 = 0x12D2         ; User Row 210
.equ USERROW_USERROW211 = 0x12D3         ; User Row 211
.equ USERROW_USERROW212 = 0x12D4         ; User Row 212
.equ USERROW_USERROW213 = 0x12D5         ; User Row 213
.equ USERROW_USERROW214 = 0x12D6         ; User Row 214
.equ USERROW_USERROW215 = 0x12D7         ; User Row 215
.equ USERROW_USERROW216 = 0x12D8         ; User Row 216
.equ USERROW_USERROW217 = 0x12D9         ; User Row 217
.equ USERROW_USERROW218 = 0x12DA         ; User Row 218
.equ USERROW_USERROW219 = 0x12DB         ; User Row 219
.equ USERROW_USERROW220 = 0x12DC         ; User Row 220
.equ USERROW_USERROW221 = 0x12DD         ; User Row 221
.equ USERROW_USERROW222 = 0x12DE         ; User Row 222
.equ USERROW_USERROW223 = 0x12DF         ; User Row 223
.equ USERROW_USERROW224 = 0x12E0         ; User Row 224
.equ USERROW_USERROW225 = 0x12E1         ; User Row 225
.equ USERROW_USERROW226 = 0x12E2         ; User Row 226
.equ USERROW_USERROW227 = 0x12E3         ; User Row 227
.equ USERROW_USERROW228 = 0x12E4         ; User Row 228
.equ USERROW_USERROW229 = 0x12E5         ; User Row 229
.equ USERROW_USERROW230 = 0x12E6         ; User Row 230
.equ USERROW_USERROW231 = 0x12E7         ; User Row 231
.equ USERROW_USERROW232 = 0x12E8         ; User Row 232
.equ USERROW_USERROW233 = 0x12E9         ; User Row 233
.equ USERROW_USERROW234 = 0x12EA         ; User Row 234
.equ USERROW_USERROW235 = 0x12EB         ; User Row 235
.equ USERROW_USERROW236 = 0x12EC         ; User Row 236
.equ USERROW_USERROW237 = 0x12ED         ; User Row 237
.equ USERROW_USERROW238 = 0x12EE         ; User Row 238
.equ USERROW_USERROW239 = 0x12EF         ; User Row 239
.equ USERROW_USERROW240 = 0x12F0         ; User Row 240
.equ USERROW_USERROW241 = 0x12F1         ; User Row 241
.equ USERROW_USERROW242 = 0x12F2         ; User Row 242
.equ USERROW_USERROW243 = 0x12F3         ; User Row 243
.equ USERROW_USERROW244 = 0x12F4         ; User Row 244
.equ USERROW_USERROW245 = 0x12F5         ; User Row 245
.equ USERROW_USERROW246 = 0x12F6         ; User Row 246
.equ USERROW_USERROW247 = 0x12F7         ; User Row 247
.equ USERROW_USERROW248 = 0x12F8         ; User Row 248
.equ USERROW_USERROW249 = 0x12F9         ; User Row 249
.equ USERROW_USERROW250 = 0x12FA         ; User Row 250
.equ USERROW_USERROW251 = 0x12FB         ; User Row 251
.equ USERROW_USERROW252 = 0x12FC         ; User Row 252
.equ USERROW_USERROW253 = 0x12FD         ; User Row 253
.equ USERROW_USERROW254 = 0x12FE         ; User Row 254
.equ USERROW_USERROW255 = 0x12FF         ; User Row 255
.equ USERROW_USERROW256 = 0x1300         ; User Row 256
.equ USERROW_USERROW257 = 0x1301         ; User Row 257
.equ USERROW_USERROW258 = 0x1302         ; User Row 258
.equ USERROW_USERROW259 = 0x1303         ; User Row 259
.equ USERROW_USERROW260 = 0x1304         ; User Row 260
.equ USERROW_USERROW261 = 0x1305         ; User Row 261
.equ USERROW_USERROW262 = 0x1306         ; User Row 262
.equ USERROW_USERROW263 = 0x1307         ; User Row 263
.equ USERROW_USERROW264 = 0x1308         ; User Row 264
.equ USERROW_USERROW265 = 0x1309         ; User Row 265
.equ USERROW_USERROW266 = 0x130A         ; User Row 266
.equ USERROW_USERROW267 = 0x130B         ; User Row 267
.equ USERROW_USERROW268 = 0x130C         ; User Row 268
.equ USERROW_USERROW269 = 0x130D         ; User Row 269
.equ USERROW_USERROW270 = 0x130E         ; User Row 270
.equ USERROW_USERROW271 = 0x130F         ; User Row 271
.equ USERROW_USERROW272 = 0x1310         ; User Row 272
.equ USERROW_USERROW273 = 0x1311         ; User Row 273
.equ USERROW_USERROW274 = 0x1312         ; User Row 274
.equ USERROW_USERROW275 = 0x1313         ; User Row 275
.equ USERROW_USERROW276 = 0x1314         ; User Row 276
.equ USERROW_USERROW277 = 0x1315         ; User Row 277
.equ USERROW_USERROW278 = 0x1316         ; User Row 278
.equ USERROW_USERROW279 = 0x1317         ; User Row 279
.equ USERROW_USERROW280 = 0x1318         ; User Row 280
.equ USERROW_USERROW281 = 0x1319         ; User Row 281
.equ USERROW_USERROW282 = 0x131A         ; User Row 282
.equ USERROW_USERROW283 = 0x131B         ; User Row 283
.equ USERROW_USERROW284 = 0x131C         ; User Row 284
.equ USERROW_USERROW285 = 0x131D         ; User Row 285
.equ USERROW_USERROW286 = 0x131E         ; User Row 286
.equ USERROW_USERROW287 = 0x131F         ; User Row 287
.equ USERROW_USERROW288 = 0x1320         ; User Row 288
.equ USERROW_USERROW289 = 0x1321         ; User Row 289
.equ USERROW_USERROW290 = 0x1322         ; User Row 290
.equ USERROW_USERROW291 = 0x1323         ; User Row 291
.equ USERROW_USERROW292 = 0x1324         ; User Row 292
.equ USERROW_USERROW293 = 0x1325         ; User Row 293
.equ USERROW_USERROW294 = 0x1326         ; User Row 294
.equ USERROW_USERROW295 = 0x1327         ; User Row 295
.equ USERROW_USERROW296 = 0x1328         ; User Row 296
.equ USERROW_USERROW297 = 0x1329         ; User Row 297
.equ USERROW_USERROW298 = 0x132A         ; User Row 298
.equ USERROW_USERROW299 = 0x132B         ; User Row 299
.equ USERROW_USERROW300 = 0x132C         ; User Row 300
.equ USERROW_USERROW301 = 0x132D         ; User Row 301
.equ USERROW_USERROW302 = 0x132E         ; User Row 302
.equ USERROW_USERROW303 = 0x132F         ; User Row 303
.equ USERROW_USERROW304 = 0x1330         ; User Row 304
.equ USERROW_USERROW305 = 0x1331         ; User Row 305
.equ USERROW_USERROW306 = 0x1332         ; User Row 306
.equ USERROW_USERROW307 = 0x1333         ; User Row 307
.equ USERROW_USERROW308 = 0x1334         ; User Row 308
.equ USERROW_USERROW309 = 0x1335         ; User Row 309
.equ USERROW_USERROW310 = 0x1336         ; User Row 310
.equ USERROW_USERROW311 = 0x1337         ; User Row 311
.equ USERROW_USERROW312 = 0x1338         ; User Row 312
.equ USERROW_USERROW313 = 0x1339         ; User Row 313
.equ USERROW_USERROW314 = 0x133A         ; User Row 314
.equ USERROW_USERROW315 = 0x133B         ; User Row 315
.equ USERROW_USERROW316 = 0x133C         ; User Row 316
.equ USERROW_USERROW317 = 0x133D         ; User Row 317
.equ USERROW_USERROW318 = 0x133E         ; User Row 318
.equ USERROW_USERROW319 = 0x133F         ; User Row 319
.equ USERROW_USERROW320 = 0x1340         ; User Row 320
.equ USERROW_USERROW321 = 0x1341         ; User Row 321
.equ USERROW_USERROW322 = 0x1342         ; User Row 322
.equ USERROW_USERROW323 = 0x1343         ; User Row 323
.equ USERROW_USERROW324 = 0x1344         ; User Row 324
.equ USERROW_USERROW325 = 0x1345         ; User Row 325
.equ USERROW_USERROW326 = 0x1346         ; User Row 326
.equ USERROW_USERROW327 = 0x1347         ; User Row 327
.equ USERROW_USERROW328 = 0x1348         ; User Row 328
.equ USERROW_USERROW329 = 0x1349         ; User Row 329
.equ USERROW_USERROW330 = 0x134A         ; User Row 330
.equ USERROW_USERROW331 = 0x134B         ; User Row 331
.equ USERROW_USERROW332 = 0x134C         ; User Row 332
.equ USERROW_USERROW333 = 0x134D         ; User Row 333
.equ USERROW_USERROW334 = 0x134E         ; User Row 334
.equ USERROW_USERROW335 = 0x134F         ; User Row 335
.equ USERROW_USERROW336 = 0x1350         ; User Row 336
.equ USERROW_USERROW337 = 0x1351         ; User Row 337
.equ USERROW_USERROW338 = 0x1352         ; User Row 338
.equ USERROW_USERROW339 = 0x1353         ; User Row 339
.equ USERROW_USERROW340 = 0x1354         ; User Row 340
.equ USERROW_USERROW341 = 0x1355         ; User Row 341
.equ USERROW_USERROW342 = 0x1356         ; User Row 342
.equ USERROW_USERROW343 = 0x1357         ; User Row 343
.equ USERROW_USERROW344 = 0x1358         ; User Row 344
.equ USERROW_USERROW345 = 0x1359         ; User Row 345
.equ USERROW_USERROW346 = 0x135A         ; User Row 346
.equ USERROW_USERROW347 = 0x135B         ; User Row 347
.equ USERROW_USERROW348 = 0x135C         ; User Row 348
.equ USERROW_USERROW349 = 0x135D         ; User Row 349
.equ USERROW_USERROW350 = 0x135E         ; User Row 350
.equ USERROW_USERROW351 = 0x135F         ; User Row 351
.equ USERROW_USERROW352 = 0x1360         ; User Row 352
.equ USERROW_USERROW353 = 0x1361         ; User Row 353
.equ USERROW_USERROW354 = 0x1362         ; User Row 354
.equ USERROW_USERROW355 = 0x1363         ; User Row 355
.equ USERROW_USERROW356 = 0x1364         ; User Row 356
.equ USERROW_USERROW357 = 0x1365         ; User Row 357
.equ USERROW_USERROW358 = 0x1366         ; User Row 358
.equ USERROW_USERROW359 = 0x1367         ; User Row 359
.equ USERROW_USERROW360 = 0x1368         ; User Row 360
.equ USERROW_USERROW361 = 0x1369         ; User Row 361
.equ USERROW_USERROW362 = 0x136A         ; User Row 362
.equ USERROW_USERROW363 = 0x136B         ; User Row 363
.equ USERROW_USERROW364 = 0x136C         ; User Row 364
.equ USERROW_USERROW365 = 0x136D         ; User Row 365
.equ USERROW_USERROW366 = 0x136E         ; User Row 366
.equ USERROW_USERROW367 = 0x136F         ; User Row 367
.equ USERROW_USERROW368 = 0x1370         ; User Row 368
.equ USERROW_USERROW369 = 0x1371         ; User Row 369
.equ USERROW_USERROW370 = 0x1372         ; User Row 370
.equ USERROW_USERROW371 = 0x1373         ; User Row 371
.equ USERROW_USERROW372 = 0x1374         ; User Row 372
.equ USERROW_USERROW373 = 0x1375         ; User Row 373
.equ USERROW_USERROW374 = 0x1376         ; User Row 374
.equ USERROW_USERROW375 = 0x1377         ; User Row 375
.equ USERROW_USERROW376 = 0x1378         ; User Row 376
.equ USERROW_USERROW377 = 0x1379         ; User Row 377
.equ USERROW_USERROW378 = 0x137A         ; User Row 378
.equ USERROW_USERROW379 = 0x137B         ; User Row 379
.equ USERROW_USERROW380 = 0x137C         ; User Row 380
.equ USERROW_USERROW381 = 0x137D         ; User Row 381
.equ USERROW_USERROW382 = 0x137E         ; User Row 382
.equ USERROW_USERROW383 = 0x137F         ; User Row 383
.equ USERROW_USERROW384 = 0x1380         ; User Row 384
.equ USERROW_USERROW385 = 0x1381         ; User Row 385
.equ USERROW_USERROW386 = 0x1382         ; User Row 386
.equ USERROW_USERROW387 = 0x1383         ; User Row 387
.equ USERROW_USERROW388 = 0x1384         ; User Row 388
.equ USERROW_USERROW389 = 0x1385         ; User Row 389
.equ USERROW_USERROW390 = 0x1386         ; User Row 390
.equ USERROW_USERROW391 = 0x1387         ; User Row 391
.equ USERROW_USERROW392 = 0x1388         ; User Row 392
.equ USERROW_USERROW393 = 0x1389         ; User Row 393
.equ USERROW_USERROW394 = 0x138A         ; User Row 394
.equ USERROW_USERROW395 = 0x138B         ; User Row 395
.equ USERROW_USERROW396 = 0x138C         ; User Row 396
.equ USERROW_USERROW397 = 0x138D         ; User Row 397
.equ USERROW_USERROW398 = 0x138E         ; User Row 398
.equ USERROW_USERROW399 = 0x138F         ; User Row 399
.equ USERROW_USERROW400 = 0x1390         ; User Row 400
.equ USERROW_USERROW401 = 0x1391         ; User Row 401
.equ USERROW_USERROW402 = 0x1392         ; User Row 402
.equ USERROW_USERROW403 = 0x1393         ; User Row 403
.equ USERROW_USERROW404 = 0x1394         ; User Row 404
.equ USERROW_USERROW405 = 0x1395         ; User Row 405
.equ USERROW_USERROW406 = 0x1396         ; User Row 406
.equ USERROW_USERROW407 = 0x1397         ; User Row 407
.equ USERROW_USERROW408 = 0x1398         ; User Row 408
.equ USERROW_USERROW409 = 0x1399         ; User Row 409
.equ USERROW_USERROW410 = 0x139A         ; User Row 410
.equ USERROW_USERROW411 = 0x139B         ; User Row 411
.equ USERROW_USERROW412 = 0x139C         ; User Row 412
.equ USERROW_USERROW413 = 0x139D         ; User Row 413
.equ USERROW_USERROW414 = 0x139E         ; User Row 414
.equ USERROW_USERROW415 = 0x139F         ; User Row 415
.equ USERROW_USERROW416 = 0x13A0         ; User Row 416
.equ USERROW_USERROW417 = 0x13A1         ; User Row 417
.equ USERROW_USERROW418 = 0x13A2         ; User Row 418
.equ USERROW_USERROW419 = 0x13A3         ; User Row 419
.equ USERROW_USERROW420 = 0x13A4         ; User Row 420
.equ USERROW_USERROW421 = 0x13A5         ; User Row 421
.equ USERROW_USERROW422 = 0x13A6         ; User Row 422
.equ USERROW_USERROW423 = 0x13A7         ; User Row 423
.equ USERROW_USERROW424 = 0x13A8         ; User Row 424
.equ USERROW_USERROW425 = 0x13A9         ; User Row 425
.equ USERROW_USERROW426 = 0x13AA         ; User Row 426
.equ USERROW_USERROW427 = 0x13AB         ; User Row 427
.equ USERROW_USERROW428 = 0x13AC         ; User Row 428
.equ USERROW_USERROW429 = 0x13AD         ; User Row 429
.equ USERROW_USERROW430 = 0x13AE         ; User Row 430
.equ USERROW_USERROW431 = 0x13AF         ; User Row 431
.equ USERROW_USERROW432 = 0x13B0         ; User Row 432
.equ USERROW_USERROW433 = 0x13B1         ; User Row 433
.equ USERROW_USERROW434 = 0x13B2         ; User Row 434
.equ USERROW_USERROW435 = 0x13B3         ; User Row 435
.equ USERROW_USERROW436 = 0x13B4         ; User Row 436
.equ USERROW_USERROW437 = 0x13B5         ; User Row 437
.equ USERROW_USERROW438 = 0x13B6         ; User Row 438
.equ USERROW_USERROW439 = 0x13B7         ; User Row 439
.equ USERROW_USERROW440 = 0x13B8         ; User Row 440
.equ USERROW_USERROW441 = 0x13B9         ; User Row 441
.equ USERROW_USERROW442 = 0x13BA         ; User Row 442
.equ USERROW_USERROW443 = 0x13BB         ; User Row 443
.equ USERROW_USERROW444 = 0x13BC         ; User Row 444
.equ USERROW_USERROW445 = 0x13BD         ; User Row 445
.equ USERROW_USERROW446 = 0x13BE         ; User Row 446
.equ USERROW_USERROW447 = 0x13BF         ; User Row 447
.equ USERROW_USERROW448 = 0x13C0         ; User Row 448
.equ USERROW_USERROW449 = 0x13C1         ; User Row 449
.equ USERROW_USERROW450 = 0x13C2         ; User Row 450
.equ USERROW_USERROW451 = 0x13C3         ; User Row 451
.equ USERROW_USERROW452 = 0x13C4         ; User Row 452
.equ USERROW_USERROW453 = 0x13C5         ; User Row 453
.equ USERROW_USERROW454 = 0x13C6         ; User Row 454
.equ USERROW_USERROW455 = 0x13C7         ; User Row 455
.equ USERROW_USERROW456 = 0x13C8         ; User Row 456
.equ USERROW_USERROW457 = 0x13C9         ; User Row 457
.equ USERROW_USERROW458 = 0x13CA         ; User Row 458
.equ USERROW_USERROW459 = 0x13CB         ; User Row 459
.equ USERROW_USERROW460 = 0x13CC         ; User Row 460
.equ USERROW_USERROW461 = 0x13CD         ; User Row 461
.equ USERROW_USERROW462 = 0x13CE         ; User Row 462
.equ USERROW_USERROW463 = 0x13CF         ; User Row 463
.equ USERROW_USERROW464 = 0x13D0         ; User Row 464
.equ USERROW_USERROW465 = 0x13D1         ; User Row 465
.equ USERROW_USERROW466 = 0x13D2         ; User Row 466
.equ USERROW_USERROW467 = 0x13D3         ; User Row 467
.equ USERROW_USERROW468 = 0x13D4         ; User Row 468
.equ USERROW_USERROW469 = 0x13D5         ; User Row 469
.equ USERROW_USERROW470 = 0x13D6         ; User Row 470
.equ USERROW_USERROW471 = 0x13D7         ; User Row 471
.equ USERROW_USERROW472 = 0x13D8         ; User Row 472
.equ USERROW_USERROW473 = 0x13D9         ; User Row 473
.equ USERROW_USERROW474 = 0x13DA         ; User Row 474
.equ USERROW_USERROW475 = 0x13DB         ; User Row 475
.equ USERROW_USERROW476 = 0x13DC         ; User Row 476
.equ USERROW_USERROW477 = 0x13DD         ; User Row 477
.equ USERROW_USERROW478 = 0x13DE         ; User Row 478
.equ USERROW_USERROW479 = 0x13DF         ; User Row 479
.equ USERROW_USERROW480 = 0x13E0         ; User Row 480
.equ USERROW_USERROW481 = 0x13E1         ; User Row 481
.equ USERROW_USERROW482 = 0x13E2         ; User Row 482
.equ USERROW_USERROW483 = 0x13E3         ; User Row 483
.equ USERROW_USERROW484 = 0x13E4         ; User Row 484
.equ USERROW_USERROW485 = 0x13E5         ; User Row 485
.equ USERROW_USERROW486 = 0x13E6         ; User Row 486
.equ USERROW_USERROW487 = 0x13E7         ; User Row 487
.equ USERROW_USERROW488 = 0x13E8         ; User Row 488
.equ USERROW_USERROW489 = 0x13E9         ; User Row 489
.equ USERROW_USERROW490 = 0x13EA         ; User Row 490
.equ USERROW_USERROW491 = 0x13EB         ; User Row 491
.equ USERROW_USERROW492 = 0x13EC         ; User Row 492
.equ USERROW_USERROW493 = 0x13ED         ; User Row 493
.equ USERROW_USERROW494 = 0x13EE         ; User Row 494
.equ USERROW_USERROW495 = 0x13EF         ; User Row 495
.equ USERROW_USERROW496 = 0x13F0         ; User Row 496
.equ USERROW_USERROW497 = 0x13F1         ; User Row 497
.equ USERROW_USERROW498 = 0x13F2         ; User Row 498
.equ USERROW_USERROW499 = 0x13F3         ; User Row 499
.equ USERROW_USERROW500 = 0x13F4         ; User Row 500
.equ USERROW_USERROW501 = 0x13F5         ; User Row 501
.equ USERROW_USERROW502 = 0x13F6         ; User Row 502
.equ USERROW_USERROW503 = 0x13F7         ; User Row 503
.equ USERROW_USERROW504 = 0x13F8         ; User Row 504
.equ USERROW_USERROW505 = 0x13F9         ; User Row 505
.equ USERROW_USERROW506 = 0x13FA         ; User Row 506
.equ USERROW_USERROW507 = 0x13FB         ; User Row 507
.equ USERROW_USERROW508 = 0x13FC         ; User Row 508
.equ USERROW_USERROW509 = 0x13FD         ; User Row 509
.equ USERROW_USERROW510 = 0x13FE         ; User Row 510
.equ USERROW_USERROW511 = 0x13FF         ; User Row 511

;*************************************************************************
;** VPORTA - Virtual Ports
;*************************************************************************

.equ VPORTA_DIR = 0x0000                 ; Data Direction
.equ VPORTA_OUT = 0x0001                 ; Output Value
.equ VPORTA_IN = 0x0002                  ; Input Value
.equ VPORTA_INTFLAGS = 0x0003            ; Interrupt Flags

;*************************************************************************
;** VPORTC - Virtual Ports
;*************************************************************************

.equ VPORTC_DIR = 0x0008                 ; Data Direction
.equ VPORTC_OUT = 0x0009                 ; Output Value
.equ VPORTC_IN = 0x000A                  ; Input Value
.equ VPORTC_INTFLAGS = 0x000B            ; Interrupt Flags

;*************************************************************************
;** VPORTD - Virtual Ports
;*************************************************************************

.equ VPORTD_DIR = 0x000C                 ; Data Direction
.equ VPORTD_OUT = 0x000D                 ; Output Value
.equ VPORTD_IN = 0x000E                  ; Input Value
.equ VPORTD_INTFLAGS = 0x000F            ; Interrupt Flags

;*************************************************************************
;** VPORTF - Virtual Ports
;*************************************************************************

.equ VPORTF_DIR = 0x0014                 ; Data Direction
.equ VPORTF_OUT = 0x0015                 ; Output Value
.equ VPORTF_IN = 0x0016                  ; Input Value
.equ VPORTF_INTFLAGS = 0x0017            ; Interrupt Flags

;*************************************************************************
;** VREF - Voltage reference
;*************************************************************************

.equ VREF_ACREF = 0x00B0                 ; ADC0 Reference

;*************************************************************************
;** WDT - Watch-Dog Timer
;*************************************************************************

.equ WDT_CTRLA = 0x0100                  ; Control A
.equ WDT_STATUS = 0x0101                 ; Status


; ***** ALL MODULE BASE ADRESSES *****************************************

.equ AC0_base = 0x0680                   ; Analog Comparator
.equ ADC0_base = 0x0600                  ; Analog to Digital Converter
.equ BOD_base = 0x00A0                   ; Bod interface
.equ BOOTROW_base = 0x1100               ; Boot Row
.equ CCL_base = 0x01C0                   ; Configurable Custom Logic
.equ CLKCTRL_base = 0x0060               ; Clock controller
.equ CPU_base = 0x0030                   ; CPU
.equ CPUINT_base = 0x0110                ; Interrupt Controller
.equ CRCSCAN_base = 0x0120               ; CRCSCAN
.equ EVSYS_base = 0x0200                 ; Event System
.equ FUSE_base = 0x1050                  ; Fuses
.equ GPR_base = 0x001C                   ; General Purpose Registers
.equ LOCK_base = 0x1040                  ; Lockbits
.equ NVMCTRL_base = 0x1000               ; Non-volatile Memory Controller
.equ PORTA_base = 0x0400                 ; I/O Ports
.equ PORTC_base = 0x0440                 ; I/O Ports
.equ PORTD_base = 0x0460                 ; I/O Ports
.equ PORTF_base = 0x04A0                 ; I/O Ports
.equ PORTMUX_base = 0x05E0               ; Port Multiplexer
.equ RSTCTRL_base = 0x0040               ; Reset controller
.equ RTC_base = 0x0140                   ; Real-Time Counter
.equ SIGROW_base = 0x1080                ; Signature row
.equ SLPCTRL_base = 0x0050               ; Sleep Controller
.equ SPI0_base = 0x0940                  ; Serial Peripheral Interface
.equ SYSCFG_base = 0x0F00                ; System Configuration Registers
.equ TCA0_base = 0x0A00                  ; 16-bit Timer/Counter Type A
.equ TCB0_base = 0x0B00                  ; 16-bit Timer Type B
.equ TCB1_base = 0x0B10                  ; 16-bit Timer Type B
.equ TWI0_base = 0x0900                  ; Two-Wire Interface
.equ USART0_base = 0x0800                ; Universal Synchronous and Asynchronous Receiver and Transmitter
.equ USART1_base = 0x0820                ; Universal Synchronous and Asynchronous Receiver and Transmitter
.equ USB0_base = 0x0C00                  ; USB Device Controller
.equ USERROW_base = 0x1200               ; User Row
.equ VPORTA_base = 0x0000                ; Virtual Ports
.equ VPORTC_base = 0x0008                ; Virtual Ports
.equ VPORTD_base = 0x000C                ; Virtual Ports
.equ VPORTF_base = 0x0014                ; Virtual Ports
.equ VREF_base = 0x00B0                  ; Voltage reference
.equ WDT_base = 0x0100                   ; Watch-Dog Timer


; ***** IO REGISTER OFFSETS **********************************************


;*************************************************************************
;** AC - Analog Comparator
;*************************************************************************
.equ AC_CTRLA_offset = 0x00              ; Control A
.equ AC_MUXCTRL_offset = 0x02            ; Mux Control A
.equ AC_DACREF_offset = 0x05             ; DAC Voltage Reference
.equ AC_INTCTRL_offset = 0x06            ; Interrupt Control
.equ AC_STATUS_offset = 0x07             ; Status

;*************************************************************************
;** ADC - Analog to Digital Converter
;*************************************************************************
.equ ADC_CTRLA_offset = 0x00             ; Control A
.equ ADC_CTRLB_offset = 0x01             ; Control C
.equ ADC_CTRLC_offset = 0x02             ; Control B
.equ ADC_CTRLD_offset = 0x03             ; Control E
.equ ADC_CTRLE_offset = 0x04             ; Control F
.equ ADC_CTRLF_offset = 0x05             ; Control D
.equ ADC_INTCTRL_offset = 0x06           ; Interrupt Control
.equ ADC_INTFLAGS_offset = 0x07          ; Interrupt Flags
.equ ADC_STATUS_offset = 0x08            ; Status
.equ ADC_DBGCTRL_offset = 0x09           ; Debug Control
.equ ADC_COMMAND_offset = 0x0A           ; Command
.equ ADC_MUXPOS_offset = 0x0B            ; Positive mux input
.equ ADC_RESULT_offset = 0x0C            ; ADC Accumulator Result
.equ ADC_SAMPLE_offset = 0x0E            ; ADC Sample
.equ ADC_WINLT_offset = 0x10             ; Window comparator low threshold
.equ ADC_WINHT_offset = 0x12             ; Window comparator high threshold
.equ ADC_TEMP_offset = 0x14              ; Temporary Data

;*************************************************************************
;** BOD - Bod interface
;*************************************************************************
.equ BOD_CTRLA_offset = 0x00             ; Control A
.equ BOD_CTRLB_offset = 0x01             ; Control B
.equ BOD_VLMCTRLA_offset = 0x08          ; Voltage level monitor Control
.equ BOD_INTCTRL_offset = 0x09           ; Voltage level monitor interrupt Control
.equ BOD_INTFLAGS_offset = 0x0A          ; Voltage level monitor interrupt Flags
.equ BOD_STATUS_offset = 0x0B            ; Voltage level monitor status

;*************************************************************************
;** BOOTROW - Boot Row
;*************************************************************************
.equ BOOTROW_BOOTROW_offset = 0x00       ; Boot row
.equ BOOTROW_BOOTROW_count = 0x100       ; Number of Boot row
.equ BOOTROW_BOOTROW_size = 0x01         ; Size of Boot row in bytes

;*************************************************************************
;** CCL - Configurable Custom Logic
;*************************************************************************
.equ CCL_CTRLA_offset = 0x00             ; Control Register A
.equ CCL_SEQCTRL0_offset = 0x01          ; Sequential Control 0
.equ CCL_SEQCTRL1_offset = 0x02          ; Sequential Control 1
.equ CCL_INTCTRL0_offset = 0x05          ; Interrupt Control 0
.equ CCL_INTFLAGS_offset = 0x07          ; Interrupt Flags
.equ CCL_LUT0CTRLA_offset = 0x08         ; LUT 0 Control A
.equ CCL_LUT0CTRLB_offset = 0x09         ; LUT 0 Control B
.equ CCL_LUT0CTRLC_offset = 0x0A         ; LUT 0 Control C
.equ CCL_TRUTH0_offset = 0x0B            ; Truth 0
.equ CCL_LUT1CTRLA_offset = 0x0C         ; LUT 1 Control A
.equ CCL_LUT1CTRLB_offset = 0x0D         ; LUT 1 Control B
.equ CCL_LUT1CTRLC_offset = 0x0E         ; LUT 1 Control C
.equ CCL_TRUTH1_offset = 0x0F            ; Truth 1
.equ CCL_LUT2CTRLA_offset = 0x10         ; LUT 2 Control A
.equ CCL_LUT2CTRLB_offset = 0x11         ; LUT 2 Control B
.equ CCL_LUT2CTRLC_offset = 0x12         ; LUT 2 Control C
.equ CCL_TRUTH2_offset = 0x13            ; Truth 2
.equ CCL_LUT3CTRLA_offset = 0x14         ; LUT 3 Control A
.equ CCL_LUT3CTRLB_offset = 0x15         ; LUT 3 Control B
.equ CCL_LUT3CTRLC_offset = 0x16         ; LUT 3 Control C
.equ CCL_TRUTH3_offset = 0x17            ; Truth 3

;*************************************************************************
;** CLKCTRL - Clock controller
;*************************************************************************
.equ CLKCTRL_MCLKCTRLA_offset = 0x00     ; MCLK Control A
.equ CLKCTRL_MCLKCTRLB_offset = 0x01     ; MCLK Control B
.equ CLKCTRL_MCLKCTRLC_offset = 0x02     ; MCLK Control C
.equ CLKCTRL_MCLKINTCTRL_offset = 0x03   ; MCLK Interrupt Control
.equ CLKCTRL_MCLKINTFLAGS_offset = 0x04  ; MCLK Interrupt Flags
.equ CLKCTRL_MCLKSTATUS_offset = 0x05    ; MCLK Status
.equ CLKCTRL_MCLKTIMEBASE_offset = 0x06  ; Timebase
.equ CLKCTRL_OSCHFCTRLA_offset = 0x08    ; OSCHF Control A
.equ CLKCTRL_OSCHFTUNE_offset = 0x09     ; OSCHF Tune
.equ CLKCTRL_OSCHFSTATUS_offset = 0x0A   ; OSCHF Status
.equ CLKCTRL_OSC32KCTRLA_offset = 0x18   ; OSC32K Control A
.equ CLKCTRL_XOSC32KCTRLA_offset = 0x1C  ; XOSC32K Control A
.equ CLKCTRL_XOSCHFCTRLA_offset = 0x20   ; XOSCHF Control A
.equ CLKCTRL_USBPLLSTATUS_offset = 0x25  ; PLL Status

;*************************************************************************
;** CPU - CPU
;*************************************************************************
.equ CPU_CCP_offset = 0x04               ; Configuration Change Protection
.equ CPU_RAMPZ_offset = 0x0B             ; Extended Z-pointer Register
.equ CPU_SP_offset = 0x0D                ; Stack Pointer
.equ CPU_SREG_offset = 0x0F              ; Status Register

;*************************************************************************
;** CPUINT - Interrupt Controller
;*************************************************************************
.equ CPUINT_CTRLA_offset = 0x00          ; Control A
.equ CPUINT_STATUS_offset = 0x01         ; Status
.equ CPUINT_LVL0PRI_offset = 0x02        ; Interrupt Level 0 Priority
.equ CPUINT_LVL1VEC_offset = 0x03        ; Interrupt Level 1 Priority Vector

;*************************************************************************
;** CRCSCAN - CRCSCAN
;*************************************************************************
.equ CRCSCAN_CTRLA_offset = 0x00         ; Control A
.equ CRCSCAN_CTRLB_offset = 0x01         ; Control B
.equ CRCSCAN_STATUS_offset = 0x02        ; Status

;*************************************************************************
;** EVSYS - Event System
;*************************************************************************
.equ EVSYS_SWEVENTA_offset = 0x00        ; Software Event A
.equ EVSYS_CHANNEL0_offset = 0x10        ; Multiplexer Channel 0
.equ EVSYS_CHANNEL1_offset = 0x11        ; Multiplexer Channel 1
.equ EVSYS_CHANNEL2_offset = 0x12        ; Multiplexer Channel 2
.equ EVSYS_CHANNEL3_offset = 0x13        ; Multiplexer Channel 3
.equ EVSYS_CHANNEL4_offset = 0x14        ; Multiplexer Channel 4
.equ EVSYS_CHANNEL5_offset = 0x15        ; Multiplexer Channel 5
.equ EVSYS_USERCCLLUT0A_offset = 0x20    ; CCL0 Event A
.equ EVSYS_USERCCLLUT0B_offset = 0x21    ; CCL0 Event B
.equ EVSYS_USERCCLLUT1A_offset = 0x22    ; CCL1 Event A
.equ EVSYS_USERCCLLUT1B_offset = 0x23    ; CCL1 Event B
.equ EVSYS_USERCCLLUT2A_offset = 0x24    ; CCL2 Event A
.equ EVSYS_USERCCLLUT2B_offset = 0x25    ; CCL2 Event B
.equ EVSYS_USERCCLLUT3A_offset = 0x26    ; CCL3 Event A
.equ EVSYS_USERCCLLUT3B_offset = 0x27    ; CCL3 Event B
.equ EVSYS_USERADC0START_offset = 0x28   ; ADC0
.equ EVSYS_USEREVSYSEVOUTA_offset = 0x29 ; EVOUTA
.equ EVSYS_USEREVSYSEVOUTD_offset = 0x2A ; EVOUTD
.equ EVSYS_USEREVSYSEVOUTF_offset = 0x2B ; EVOUTF
.equ EVSYS_USERUSART0IRDA_offset = 0x2C  ; USART0
.equ EVSYS_USERUSART1IRDA_offset = 0x2D  ; USART1
.equ EVSYS_USERTCA0CNTA_offset = 0x2E    ; TCA0 Event A
.equ EVSYS_USERTCA0CNTB_offset = 0x2F    ; TCA0 Event B
.equ EVSYS_USERTCB0CAPT_offset = 0x30    ; TCB0 Event A
.equ EVSYS_USERTCB0COUNT_offset = 0x31   ; TCB0 Event B
.equ EVSYS_USERTCB1CAPT_offset = 0x32    ; TCB1 Event A
.equ EVSYS_USERTCB1COUNT_offset = 0x33   ; TCB1 Event B

;*************************************************************************
;** FUSE - Fuses
;*************************************************************************
.equ FUSE_WDTCFG_offset = 0x00           ; Watchdog Configuration
.equ FUSE_BODCFG_offset = 0x01           ; BOD Configuration
.equ FUSE_OSCCFG_offset = 0x02           ; Oscillator Configuration
.equ FUSE_SYSCFG0_offset = 0x05          ; System Configuration 0
.equ FUSE_SYSCFG1_offset = 0x06          ; System Configuration 1
.equ FUSE_CODESIZE_offset = 0x07         ; Code Section Size
.equ FUSE_BOOTSIZE_offset = 0x08         ; Boot Section Size
.equ FUSE_PDICFG_offset = 0x0A           ; Programming and Debugging Interface Configuration

;*************************************************************************
;** GPR - General Purpose Registers
;*************************************************************************
.equ GPR_GPR0_offset = 0x00              ; General Purpose Register 0
.equ GPR_GPR1_offset = 0x01              ; General Purpose Register 1
.equ GPR_GPR2_offset = 0x02              ; General Purpose Register 2
.equ GPR_GPR3_offset = 0x03              ; General Purpose Register 3

;*************************************************************************
;** LOCK - Lockbits
;*************************************************************************
.equ LOCK_KEY_offset = 0x00              ; Lock Key Bits

;*************************************************************************
;** NVMCTRL - Non-volatile Memory Controller
;*************************************************************************
.equ NVMCTRL_CTRLA_offset = 0x00         ; Control A
.equ NVMCTRL_CTRLB_offset = 0x01         ; Control B
.equ NVMCTRL_CTRLC_offset = 0x02         ; Control C
.equ NVMCTRL_INTCTRL_offset = 0x04       ; Interrupt Control
.equ NVMCTRL_INTFLAGS_offset = 0x05      ; Interrupt Flags
.equ NVMCTRL_STATUS_offset = 0x06        ; Status
.equ NVMCTRL_DATA_offset = 0x08          ; Data
.equ NVMCTRL_ADDR_offset = 0x0C          ; Address

;*************************************************************************
;** PORT - I/O Ports
;*************************************************************************
.equ PORT_DIR_offset = 0x00              ; Data Direction
.equ PORT_DIRSET_offset = 0x01           ; Data Direction Set
.equ PORT_DIRCLR_offset = 0x02           ; Data Direction Clear
.equ PORT_DIRTGL_offset = 0x03           ; Data Direction Toggle
.equ PORT_OUT_offset = 0x04              ; Output Value
.equ PORT_OUTSET_offset = 0x05           ; Output Value Set
.equ PORT_OUTCLR_offset = 0x06           ; Output Value Clear
.equ PORT_OUTTGL_offset = 0x07           ; Output Value Toggle
.equ PORT_IN_offset = 0x08               ; Input Value
.equ PORT_INTFLAGS_offset = 0x09         ; Interrupt Flags
.equ PORT_PORTCTRL_offset = 0x0A         ; Port Control
.equ PORT_PINCONFIG_offset = 0x0B        ; Pin Control Config
.equ PORT_PINCTRLUPD_offset = 0x0C       ; Pin Control Update
.equ PORT_PINCTRLSET_offset = 0x0D       ; Pin Control Set
.equ PORT_PINCTRLCLR_offset = 0x0E       ; Pin Control Clear
.equ PORT_PIN0CTRL_offset = 0x10         ; Pin 0 Control
.equ PORT_PIN1CTRL_offset = 0x11         ; Pin 1 Control
.equ PORT_PIN2CTRL_offset = 0x12         ; Pin 2 Control
.equ PORT_PIN3CTRL_offset = 0x13         ; Pin 3 Control
.equ PORT_PIN4CTRL_offset = 0x14         ; Pin 4 Control
.equ PORT_PIN5CTRL_offset = 0x15         ; Pin 5 Control
.equ PORT_PIN6CTRL_offset = 0x16         ; Pin 6 Control
.equ PORT_PIN7CTRL_offset = 0x17         ; Pin 7 Control
.equ PORT_EVGENCTRLA_offset = 0x18       ; Event Generation Control A

;*************************************************************************
;** PORTMUX - Port Multiplexer
;*************************************************************************
.equ PORTMUX_EVSYSROUTEA_offset = 0x00   ; EVSYS route A
.equ PORTMUX_CCLROUTEA_offset = 0x01     ; CCL route A
.equ PORTMUX_USARTROUTEA_offset = 0x02   ; USART route A
.equ PORTMUX_SPIROUTEA_offset = 0x05     ; SPI route A
.equ PORTMUX_TWIROUTEA_offset = 0x06     ; TWI route A
.equ PORTMUX_TCAROUTEA_offset = 0x07     ; TCA route A
.equ PORTMUX_TCBROUTEA_offset = 0x08     ; TCB route A

;*************************************************************************
;** RSTCTRL - Reset controller
;*************************************************************************
.equ RSTCTRL_RSTFR_offset = 0x00         ; Reset Flags
.equ RSTCTRL_SWRR_offset = 0x01          ; Software Reset

;*************************************************************************
;** RTC - Real-Time Counter
;*************************************************************************
.equ RTC_CTRLA_offset = 0x00             ; Control A
.equ RTC_STATUS_offset = 0x01            ; Status
.equ RTC_INTCTRL_offset = 0x02           ; Interrupt Control
.equ RTC_INTFLAGS_offset = 0x03          ; Interrupt Flags
.equ RTC_TEMP_offset = 0x04              ; Temporary
.equ RTC_DBGCTRL_offset = 0x05           ; Debug control
.equ RTC_CALIB_offset = 0x06             ; Calibration
.equ RTC_CLKSEL_offset = 0x07            ; Clock Select
.equ RTC_CNT_offset = 0x08               ; Counter
.equ RTC_PER_offset = 0x0A               ; Period
.equ RTC_CMP_offset = 0x0C               ; Compare
.equ RTC_PITCTRLA_offset = 0x10          ; PIT Control A
.equ RTC_PITSTATUS_offset = 0x11         ; PIT Status
.equ RTC_PITINTCTRL_offset = 0x12        ; PIT Interrupt Control
.equ RTC_PITINTFLAGS_offset = 0x13       ; PIT Interrupt Flags
.equ RTC_PITDBGCTRL_offset = 0x15        ; PIT Debug control
.equ RTC_PITEVGENCTRLA_offset = 0x16     ; PIT Event Generation Control A

;*************************************************************************
;** SIGROW - Signature row
;*************************************************************************
.equ SIGROW_DEVICEID0_offset = 0x00      ; Device ID Byte 0
.equ SIGROW_DEVICEID1_offset = 0x01      ; Device ID Byte 1
.equ SIGROW_DEVICEID2_offset = 0x02      ; Device ID Byte 2
.equ SIGROW_TEMPSENSE0_offset = 0x04     ; Temperature Calibration 0
.equ SIGROW_TEMPSENSE1_offset = 0x06     ; Temperature Calibration 1
.equ SIGROW_SERNUM0_offset = 0x10        ; LOTNUM0
.equ SIGROW_SERNUM1_offset = 0x11        ; LOTNUM1
.equ SIGROW_SERNUM2_offset = 0x12        ; LOTNUM2
.equ SIGROW_SERNUM3_offset = 0x13        ; LOTNUM3
.equ SIGROW_SERNUM4_offset = 0x14        ; LOTNUM4
.equ SIGROW_SERNUM5_offset = 0x15        ; LOTNUM5
.equ SIGROW_SERNUM6_offset = 0x16        ; RANDOM
.equ SIGROW_SERNUM7_offset = 0x17        ; SCRIBE
.equ SIGROW_SERNUM8_offset = 0x18        ; XPOS0
.equ SIGROW_SERNUM9_offset = 0x19        ; XPOS1
.equ SIGROW_SERNUM10_offset = 0x1A       ; YPOS0
.equ SIGROW_SERNUM11_offset = 0x1B       ; YPOS1
.equ SIGROW_SERNUM12_offset = 0x1C       ; RES0
.equ SIGROW_SERNUM13_offset = 0x1D       ; RES1
.equ SIGROW_SERNUM14_offset = 0x1E       ; RES2
.equ SIGROW_SERNUM15_offset = 0x1F       ; RES3

;*************************************************************************
;** SLPCTRL - Sleep Controller
;*************************************************************************
.equ SLPCTRL_CTRLA_offset = 0x00         ; Control A
.equ SLPCTRL_VREGCTRL_offset = 0x01      ; Control B

;*************************************************************************
;** SPI - Serial Peripheral Interface
;*************************************************************************
.equ SPI_CTRLA_offset = 0x00             ; Control A
.equ SPI_CTRLB_offset = 0x01             ; Control B
.equ SPI_INTCTRL_offset = 0x02           ; Interrupt Control
.equ SPI_INTFLAGS_offset = 0x03          ; Interrupt Flags
.equ SPI_DATA_offset = 0x04              ; Data

;*************************************************************************
;** SYSCFG - System Configuration Registers
;*************************************************************************
.equ SYSCFG_REVID_offset = 0x01          ; Revision ID
.equ SYSCFG_VUSBCTRL_offset = 0x06       ; USB Voltage System Control

;*************************************************************************
;** TCA - 16-bit Timer/Counter Type A
;*************************************************************************
.equ TCA_SINGLE_CTRLA_offset = 0x00      ; Control A
.equ TCA_SPLIT_CTRLA_offset = 0x00       ; Control A
.equ TCA_SINGLE_CTRLB_offset = 0x01      ; Control B
.equ TCA_SPLIT_CTRLB_offset = 0x01       ; Control B
.equ TCA_SINGLE_CTRLC_offset = 0x02      ; Control C
.equ TCA_SPLIT_CTRLC_offset = 0x02       ; Control C
.equ TCA_SINGLE_CTRLD_offset = 0x03      ; Control D
.equ TCA_SPLIT_CTRLD_offset = 0x03       ; Control D
.equ TCA_SINGLE_CTRLECLR_offset = 0x04   ; Control E Clear
.equ TCA_SPLIT_CTRLECLR_offset = 0x04    ; Control E Clear
.equ TCA_SINGLE_CTRLESET_offset = 0x05   ; Control E Set
.equ TCA_SPLIT_CTRLESET_offset = 0x05    ; Control E Set
.equ TCA_SINGLE_CTRLFCLR_offset = 0x06   ; Control F Clear
.equ TCA_SINGLE_CTRLFSET_offset = 0x07   ; Control F Set
.equ TCA_SINGLE_EVCTRL_offset = 0x09     ; Event Control
.equ TCA_SINGLE_INTCTRL_offset = 0x0A    ; Interrupt Control
.equ TCA_SPLIT_INTCTRL_offset = 0x0A     ; Interrupt Control
.equ TCA_SINGLE_INTFLAGS_offset = 0x0B   ; Interrupt Flags
.equ TCA_SPLIT_INTFLAGS_offset = 0x0B    ; Interrupt Flags
.equ TCA_SINGLE_DBGCTRL_offset = 0x0E    ; Debug Control
.equ TCA_SPLIT_DBGCTRL_offset = 0x0E     ; Debug Control
.equ TCA_SINGLE_TEMP_offset = 0x0F       ; Temporary data for 16-bit Access
.equ TCA_SINGLE_CNT_offset = 0x20        ; Count
.equ TCA_SPLIT_LCNT_offset = 0x20        ; Low Count
.equ TCA_SPLIT_HCNT_offset = 0x21        ; High Count
.equ TCA_SINGLE_PER_offset = 0x26        ; Period
.equ TCA_SPLIT_LPER_offset = 0x26        ; Low Period
.equ TCA_SPLIT_HPER_offset = 0x27        ; High Period
.equ TCA_SINGLE_CMP0_offset = 0x28       ; Compare 0
.equ TCA_SPLIT_LCMP0_offset = 0x28       ; Low Compare
.equ TCA_SPLIT_HCMP0_offset = 0x29       ; High Compare
.equ TCA_SINGLE_CMP1_offset = 0x2A       ; Compare 1
.equ TCA_SPLIT_LCMP1_offset = 0x2A       ; Low Compare
.equ TCA_SPLIT_HCMP1_offset = 0x2B       ; High Compare
.equ TCA_SINGLE_CMP2_offset = 0x2C       ; Compare 2
.equ TCA_SPLIT_LCMP2_offset = 0x2C       ; Low Compare
.equ TCA_SPLIT_HCMP2_offset = 0x2D       ; High Compare
.equ TCA_SINGLE_PERBUF_offset = 0x36     ; Period Buffer
.equ TCA_SINGLE_CMP0BUF_offset = 0x38    ; Compare 0 Buffer
.equ TCA_SINGLE_CMP1BUF_offset = 0x3A    ; Compare 1 Buffer
.equ TCA_SINGLE_CMP2BUF_offset = 0x3C    ; Compare 2 Buffer

;*************************************************************************
;** TCB - 16-bit Timer Type B
;*************************************************************************
.equ TCB_CTRLA_offset = 0x00             ; Control A
.equ TCB_CTRLB_offset = 0x01             ; Control Register B
.equ TCB_EVCTRL_offset = 0x04            ; Event Control
.equ TCB_INTCTRL_offset = 0x05           ; Interrupt Control
.equ TCB_INTFLAGS_offset = 0x06          ; Interrupt Flags
.equ TCB_STATUS_offset = 0x07            ; Status
.equ TCB_DBGCTRL_offset = 0x08           ; Debug Control
.equ TCB_TEMP_offset = 0x09              ; Temporary Value
.equ TCB_CNT_offset = 0x0A               ; Count
.equ TCB_CCMP_offset = 0x0C              ; Compare or Capture

;*************************************************************************
;** TWI - Two-Wire Interface
;*************************************************************************
.equ TWI_CTRLA_offset = 0x00             ; Control A
.equ TWI_DBGCTRL_offset = 0x02           ; Debug Control
.equ TWI_MCTRLA_offset = 0x03            ; Host Control A
.equ TWI_MCTRLB_offset = 0x04            ; Host Control B
.equ TWI_MSTATUS_offset = 0x05           ; Host STATUS
.equ TWI_MBAUD_offset = 0x06             ; Host Baud Rate
.equ TWI_MADDR_offset = 0x07             ; Host Address
.equ TWI_MDATA_offset = 0x08             ; Host Data
.equ TWI_SCTRLA_offset = 0x09            ; Client Control A
.equ TWI_SCTRLB_offset = 0x0A            ; Client Control B
.equ TWI_SSTATUS_offset = 0x0B           ; Client Status
.equ TWI_SADDR_offset = 0x0C             ; Client Address
.equ TWI_SDATA_offset = 0x0D             ; Client Data
.equ TWI_SADDRMASK_offset = 0x0E         ; Client Address Mask

;*************************************************************************
;** USART - Universal Synchronous and Asynchronous Receiver and Transmitter
;*************************************************************************
.equ USART_RXDATAL_offset = 0x00         ; Receive Data Low Byte
.equ USART_RXDATAH_offset = 0x01         ; Receive Data High Byte
.equ USART_TXDATAL_offset = 0x02         ; Transmit Data Low Byte
.equ USART_TXDATAH_offset = 0x03         ; Transmit Data High Byte
.equ USART_STATUS_offset = 0x04          ; Status
.equ USART_CTRLA_offset = 0x05           ; Control A
.equ USART_CTRLB_offset = 0x06           ; Control B
.equ USART_CTRLC_offset = 0x07           ; Control C
.equ USART_BAUD_offset = 0x08            ; Baud Rate
.equ USART_CTRLD_offset = 0x0A           ; Control D
.equ USART_DBGCTRL_offset = 0x0B         ; Debug Control
.equ USART_EVCTRL_offset = 0x0C          ; Event Control
.equ USART_TXPLCTRL_offset = 0x0D        ; IRCOM Transmitter Pulse Length Control
.equ USART_RXPLCTRL_offset = 0x0E        ; IRCOM Receiver Pulse Length Control

;*************************************************************************
;** USB - USB Device Controller
;*************************************************************************
.equ USB_EP_STATUS_offset = 0x00         ; Endpoint Status
.equ USB_EP_CTRL_offset = 0x01           ; Endpoint Control
.equ USB_EP_CNT_offset = 0x02            ; Endpoint Byte Count
.equ USB_EP_DATAPTR_offset = 0x04        ; Endpoint Data Pointer
.equ USB_EP_MCNT_offset = 0x06           ; Endpoint Multi-packet Byte Count
.equ USB_EP_PAIR_OUT_offset = 0x00       ; USB Device Controller OUT
.equ USB_EP_PAIR_IN_offset = 0x08        ; USB Device Controller IN
.equ USB_EP_TABLE_FIFO_offset = 0x00     ; FIFO Pointer Table
.equ USB_EP_TABLE_FIFO_count = 0x20      ; Number of FIFO Pointer Table
.equ USB_EP_TABLE_FIFO_size = 0x01       ; Size of FIFO Pointer Table in bytes
.equ USB_EP_TABLE_FRAMENUM_offset = 0x120 ; FRAMENUM count
.equ USB_EP_TABLE_EP_offset = 0x20       ; USB Device Controller EP
.equ USB_EP_TABLE_EP_count = 0x10        ; Number of USB Device Controller EP
.equ USB_EP_TABLE_EP_size = 0x10         ; Size of USB Device Controller EP in bytes
.equ USB_STATUS_OUTCLR_offset = 0x00     ; Endpoint n OUT Status Clear
.equ USB_STATUS_OUTSET_offset = 0x01     ; Endpoint n OUT Status Set
.equ USB_STATUS_INCLR_offset = 0x02      ; Endpoint n IN Status Clear
.equ USB_STATUS_INSET_offset = 0x03      ; Endpoint n IN Status Set
.equ USB_CTRLA_offset = 0x00             ; Control A
.equ USB_CTRLB_offset = 0x01             ; Control B
.equ USB_BUSSTATE_offset = 0x02          ; Bus State
.equ USB_ADDR_offset = 0x03              ; Address
.equ USB_FIFOWP_offset = 0x04            ; FIFO Write Pointer
.equ USB_FIFORP_offset = 0x05            ; FIFO Read Pointer
.equ USB_EPPTR_offset = 0x06             ; Endpoint Configuration Table Pointer
.equ USB_INTCTRLA_offset = 0x08          ; Interrupt Control A
.equ USB_INTCTRLB_offset = 0x09          ; Interrupt Control B
.equ USB_INTFLAGSA_offset = 0x0A         ; Interrupt Flags A
.equ USB_INTFLAGSB_offset = 0x0B         ; Interrupt Flags B
.equ USB_STATUS_offset = 0x40            ; USB Device Controller STATUS
.equ USB_STATUS_count = 0x10             ; Number of USB Device Controller STATUS
.equ USB_STATUS_size = 0x04              ; Size of USB Device Controller STATUS in bytes

;*************************************************************************
;** USERROW - User Row
;*************************************************************************
.equ USERROW_USERROW_offset = 0x00       ; User Row
.equ USERROW_USERROW_count = 0x200       ; Number of User Row
.equ USERROW_USERROW_size = 0x01         ; Size of User Row in bytes

;*************************************************************************
;** VPORT - Virtual Ports
;*************************************************************************
.equ VPORT_DIR_offset = 0x00             ; Data Direction
.equ VPORT_OUT_offset = 0x01             ; Output Value
.equ VPORT_IN_offset = 0x02              ; Input Value
.equ VPORT_INTFLAGS_offset = 0x03        ; Interrupt Flags

;*************************************************************************
;** VREF - Voltage reference
;*************************************************************************
.equ VREF_ACREF_offset = 0x00            ; ADC0 Reference

;*************************************************************************
;** WDT - Watch-Dog Timer
;*************************************************************************
.equ WDT_CTRLA_offset = 0x00             ; Control A
.equ WDT_STATUS_offset = 0x01            ; Status


; ***** LOCKBIT REGISTER LOCATIONS ***************************************




; ***** FUSE REGISTER LOCATIONS ******************************************




; ***** BIT AND VALUE DEFINITIONS ****************************************


;*************************************************************************
;** AC - Analog Comparator
;*************************************************************************

; AC_CTRLA masks
.equ AC_ENABLE_bm = 0x01                 ; Enable bit mask
.equ AC_ENABLE_bp = 0                    ; Enable bit position
.equ AC_HYSMODE_gm = 0x06                ; Hysteresis Mode group mask
.equ AC_HYSMODE_gp = 1                   ; Hysteresis Mode group position
.equ AC_HYSMODE_0_bm = (1<<1)            ; Hysteresis Mode bit 0 mask
.equ AC_HYSMODE_0_bp = 1                 ; Hysteresis Mode bit 0 position
.equ AC_HYSMODE_1_bm = (1<<2)            ; Hysteresis Mode bit 1 mask
.equ AC_HYSMODE_1_bp = 2                 ; Hysteresis Mode bit 1 position
.equ AC_POWER_gm = 0x18                  ; Power profile group mask
.equ AC_POWER_gp = 3                     ; Power profile group position
.equ AC_POWER_0_bm = (1<<3)              ; Power profile bit 0 mask
.equ AC_POWER_0_bp = 3                   ; Power profile bit 0 position
.equ AC_POWER_1_bm = (1<<4)              ; Power profile bit 1 mask
.equ AC_POWER_1_bp = 4                   ; Power profile bit 1 position
.equ AC_OUTEN_bm = 0x40                  ; Output Pad Enable bit mask
.equ AC_OUTEN_bp = 6                     ; Output Pad Enable bit position
.equ AC_RUNSTDBY_bm = 0x80               ; Run in Standby Mode bit mask
.equ AC_RUNSTDBY_bp = 7                  ; Run in Standby Mode bit position

; AC_MUXCTRL masks
.equ AC_MUXNEG_gm = 0x07                 ; Negative Input MUX Selection group mask
.equ AC_MUXNEG_gp = 0                    ; Negative Input MUX Selection group position
.equ AC_MUXNEG_0_bm = (1<<0)             ; Negative Input MUX Selection bit 0 mask
.equ AC_MUXNEG_0_bp = 0                  ; Negative Input MUX Selection bit 0 position
.equ AC_MUXNEG_1_bm = (1<<1)             ; Negative Input MUX Selection bit 1 mask
.equ AC_MUXNEG_1_bp = 1                  ; Negative Input MUX Selection bit 1 position
.equ AC_MUXNEG_2_bm = (1<<2)             ; Negative Input MUX Selection bit 2 mask
.equ AC_MUXNEG_2_bp = 2                  ; Negative Input MUX Selection bit 2 position
.equ AC_MUXPOS_gm = 0x38                 ; Positive Input MUX Selection group mask
.equ AC_MUXPOS_gp = 3                    ; Positive Input MUX Selection group position
.equ AC_MUXPOS_0_bm = (1<<3)             ; Positive Input MUX Selection bit 0 mask
.equ AC_MUXPOS_0_bp = 3                  ; Positive Input MUX Selection bit 0 position
.equ AC_MUXPOS_1_bm = (1<<4)             ; Positive Input MUX Selection bit 1 mask
.equ AC_MUXPOS_1_bp = 4                  ; Positive Input MUX Selection bit 1 position
.equ AC_MUXPOS_2_bm = (1<<5)             ; Positive Input MUX Selection bit 2 mask
.equ AC_MUXPOS_2_bp = 5                  ; Positive Input MUX Selection bit 2 position
.equ AC_INITVAL_bm = 0x40                ; AC Output Initial Value bit mask
.equ AC_INITVAL_bp = 6                   ; AC Output Initial Value bit position
.equ AC_INVERT_bm = 0x80                 ; Invert AC Output bit mask
.equ AC_INVERT_bp = 7                    ; Invert AC Output bit position

; AC_DACREF masks
.equ AC_DACREF_gm = 0xFF                 ; DACREF group mask
.equ AC_DACREF_gp = 0                    ; DACREF group position
.equ AC_DACREF_0_bm = (1<<0)             ; DACREF bit 0 mask
.equ AC_DACREF_0_bp = 0                  ; DACREF bit 0 position
.equ AC_DACREF_1_bm = (1<<1)             ; DACREF bit 1 mask
.equ AC_DACREF_1_bp = 1                  ; DACREF bit 1 position
.equ AC_DACREF_2_bm = (1<<2)             ; DACREF bit 2 mask
.equ AC_DACREF_2_bp = 2                  ; DACREF bit 2 position
.equ AC_DACREF_3_bm = (1<<3)             ; DACREF bit 3 mask
.equ AC_DACREF_3_bp = 3                  ; DACREF bit 3 position
.equ AC_DACREF_4_bm = (1<<4)             ; DACREF bit 4 mask
.equ AC_DACREF_4_bp = 4                  ; DACREF bit 4 position
.equ AC_DACREF_5_bm = (1<<5)             ; DACREF bit 5 mask
.equ AC_DACREF_5_bp = 5                  ; DACREF bit 5 position
.equ AC_DACREF_6_bm = (1<<6)             ; DACREF bit 6 mask
.equ AC_DACREF_6_bp = 6                  ; DACREF bit 6 position
.equ AC_DACREF_7_bm = (1<<7)             ; DACREF bit 7 mask
.equ AC_DACREF_7_bp = 7                  ; DACREF bit 7 position

; AC_INTCTRL masks
.equ AC_CMP_bm = 0x01                    ; Interrupt Enable bit mask
.equ AC_CMP_bp = 0                       ; Interrupt Enable bit position
.equ AC_INTMODE_gm = 0x30                ; Interrupt Mode group mask
.equ AC_INTMODE_gp = 4                   ; Interrupt Mode group position
.equ AC_INTMODE_0_bm = (1<<4)            ; Interrupt Mode bit 0 mask
.equ AC_INTMODE_0_bp = 4                 ; Interrupt Mode bit 0 position
.equ AC_INTMODE_1_bm = (1<<5)            ; Interrupt Mode bit 1 mask
.equ AC_INTMODE_1_bp = 5                 ; Interrupt Mode bit 1 position

; AC_STATUS masks
.equ AC_CMPIF_bm = 0x01                  ; Analog Comparator Interrupt Flag bit mask
.equ AC_CMPIF_bp = 0                     ; Analog Comparator Interrupt Flag bit position
.equ AC_CMPSTATE_bm = 0x10               ; Analog Comparator State bit mask
.equ AC_CMPSTATE_bp = 4                  ; Analog Comparator State bit position

; Hysteresis Mode select
.equ AC_HYSMODE_NONE_gc = (0x00<<1)      ; No hysteresis
.equ AC_HYSMODE_SMALL_gc = (0x01<<1)     ; Small hysteresis
.equ AC_HYSMODE_MEDIUM_gc = (0x02<<1)    ; Medium hysteresis
.equ AC_HYSMODE_LARGE_gc = (0x03<<1)     ; Large hysteresis

; Power profile select
.equ AC_POWER_PROFILE0_gc = (0x00<<3)    ; Power profile 0, lowest consumption and highest response time.
.equ AC_POWER_PROFILE1_gc = (0x01<<3)    ; Power profile 1
.equ AC_POWER_PROFILE2_gc = (0x02<<3)    ; Power profile 2
.equ AC_POWER_PROFILE3_gc = (0x03<<3)    ; Power profile 3

; Interrupt Mode select
.equ AC_NORMAL_INTMODE_BOTHEDGE_gc = (0x00<<4) ; Positive and negative inputs crosses
.equ AC_NORMAL_INTMODE_NEGEDGE_gc = (0x02<<4) ; Positive input goes below negative input
.equ AC_NORMAL_INTMODE_POSEDGE_gc = (0x03<<4) ; Positive input goes above negative input

; AC Output Initial Value select
.equ AC_INITVAL_LOW_gc = (0x00<<6)       ; Output initialized to 0
.equ AC_INITVAL_HIGH_gc = (0x01<<6)      ; Output initialized to 1

; Negative Input MUX Selection
.equ AC_MUXNEG_AINN0_gc = (0x00<<0)      ; Negative Pin 0
.equ AC_MUXNEG_AINN1_gc = (0x01<<0)      ; Negative Pin 1
.equ AC_MUXNEG_AINN2_gc = (0x02<<0)      ; Negative Pin 2
.equ AC_MUXNEG_DACREF_gc = (0x04<<0)     ; DAC Reference

; Positive Input MUX Selection
.equ AC_MUXPOS_AINP0_gc = (0x00<<3)      ; Positive Pin 0
.equ AC_MUXPOS_AINP3_gc = (0x03<<3)      ; Positive Pin 3
.equ AC_MUXPOS_AINP4_gc = (0x04<<3)      ; Positive Pin 4


;*************************************************************************
;** ADC - Analog to Digital Converter
;*************************************************************************

; ADC_CTRLA masks
.equ ADC_ENABLE_bm = 0x01                ; ADC Enable bit mask
.equ ADC_ENABLE_bp = 0                   ; ADC Enable bit position
.equ ADC_LOWLAT_bm = 0x20                ; Conversion mode bit mask
.equ ADC_LOWLAT_bp = 5                   ; Conversion mode bit position
.equ ADC_RUNSTBY_bm = 0x80               ; Run standby mode bit mask
.equ ADC_RUNSTBY_bp = 7                  ; Run standby mode bit position

; ADC_CTRLB masks
.equ ADC_PRESC_gm = 0x0F                 ; Clock Pre-scaler group mask
.equ ADC_PRESC_gp = 0                    ; Clock Pre-scaler group position
.equ ADC_PRESC_0_bm = (1<<0)             ; Clock Pre-scaler bit 0 mask
.equ ADC_PRESC_0_bp = 0                  ; Clock Pre-scaler bit 0 position
.equ ADC_PRESC_1_bm = (1<<1)             ; Clock Pre-scaler bit 1 mask
.equ ADC_PRESC_1_bp = 1                  ; Clock Pre-scaler bit 1 position
.equ ADC_PRESC_2_bm = (1<<2)             ; Clock Pre-scaler bit 2 mask
.equ ADC_PRESC_2_bp = 2                  ; Clock Pre-scaler bit 2 position
.equ ADC_PRESC_3_bm = (1<<3)             ; Clock Pre-scaler bit 3 mask
.equ ADC_PRESC_3_bp = 3                  ; Clock Pre-scaler bit 3 position

; ADC_CTRLC masks
.equ ADC_REFSEL_gm = 0x07                ; Reference Selection group mask
.equ ADC_REFSEL_gp = 0                   ; Reference Selection group position
.equ ADC_REFSEL_0_bm = (1<<0)            ; Reference Selection bit 0 mask
.equ ADC_REFSEL_0_bp = 0                 ; Reference Selection bit 0 position
.equ ADC_REFSEL_1_bm = (1<<1)            ; Reference Selection bit 1 mask
.equ ADC_REFSEL_1_bp = 1                 ; Reference Selection bit 1 position
.equ ADC_REFSEL_2_bm = (1<<2)            ; Reference Selection bit 2 mask
.equ ADC_REFSEL_2_bp = 2                 ; Reference Selection bit 2 position

; ADC_CTRLD masks
.equ ADC_WINCM_gm = 0x07                 ; Window Comparator Mode group mask
.equ ADC_WINCM_gp = 0                    ; Window Comparator Mode group position
.equ ADC_WINCM_0_bm = (1<<0)             ; Window Comparator Mode bit 0 mask
.equ ADC_WINCM_0_bp = 0                  ; Window Comparator Mode bit 0 position
.equ ADC_WINCM_1_bm = (1<<1)             ; Window Comparator Mode bit 1 mask
.equ ADC_WINCM_1_bp = 1                  ; Window Comparator Mode bit 1 position
.equ ADC_WINCM_2_bm = (1<<2)             ; Window Comparator Mode bit 2 mask
.equ ADC_WINCM_2_bp = 2                  ; Window Comparator Mode bit 2 position
.equ ADC_WINSRC_bm = 0x08                ; Window Mode Source bit mask
.equ ADC_WINSRC_bp = 3                   ; Window Mode Source bit position

; ADC_CTRLE masks
.equ ADC_SAMPDUR_gm = 0xFF               ; Sample Duration group mask
.equ ADC_SAMPDUR_gp = 0                  ; Sample Duration group position
.equ ADC_SAMPDUR_0_bm = (1<<0)           ; Sample Duration bit 0 mask
.equ ADC_SAMPDUR_0_bp = 0                ; Sample Duration bit 0 position
.equ ADC_SAMPDUR_1_bm = (1<<1)           ; Sample Duration bit 1 mask
.equ ADC_SAMPDUR_1_bp = 1                ; Sample Duration bit 1 position
.equ ADC_SAMPDUR_2_bm = (1<<2)           ; Sample Duration bit 2 mask
.equ ADC_SAMPDUR_2_bp = 2                ; Sample Duration bit 2 position
.equ ADC_SAMPDUR_3_bm = (1<<3)           ; Sample Duration bit 3 mask
.equ ADC_SAMPDUR_3_bp = 3                ; Sample Duration bit 3 position
.equ ADC_SAMPDUR_4_bm = (1<<4)           ; Sample Duration bit 4 mask
.equ ADC_SAMPDUR_4_bp = 4                ; Sample Duration bit 4 position
.equ ADC_SAMPDUR_5_bm = (1<<5)           ; Sample Duration bit 5 mask
.equ ADC_SAMPDUR_5_bp = 5                ; Sample Duration bit 5 position
.equ ADC_SAMPDUR_6_bm = (1<<6)           ; Sample Duration bit 6 mask
.equ ADC_SAMPDUR_6_bp = 6                ; Sample Duration bit 6 position
.equ ADC_SAMPDUR_7_bm = (1<<7)           ; Sample Duration bit 7 mask
.equ ADC_SAMPDUR_7_bp = 7                ; Sample Duration bit 7 position

; ADC_CTRLF masks
.equ ADC_SAMPNUM_gm = 0x07               ; Sampling Number group mask
.equ ADC_SAMPNUM_gp = 0                  ; Sampling Number group position
.equ ADC_SAMPNUM_0_bm = (1<<0)           ; Sampling Number bit 0 mask
.equ ADC_SAMPNUM_0_bp = 0                ; Sampling Number bit 0 position
.equ ADC_SAMPNUM_1_bm = (1<<1)           ; Sampling Number bit 1 mask
.equ ADC_SAMPNUM_1_bp = 1                ; Sampling Number bit 1 position
.equ ADC_SAMPNUM_2_bm = (1<<2)           ; Sampling Number bit 2 mask
.equ ADC_SAMPNUM_2_bp = 2                ; Sampling Number bit 2 position
.equ ADC_LEFTADJ_bm = 0x10               ; Left Adjust bit mask
.equ ADC_LEFTADJ_bp = 4                  ; Left Adjust bit position
.equ ADC_FREERUN_bm = 0x20               ; Free Running bit mask
.equ ADC_FREERUN_bp = 5                  ; Free Running bit position

; ADC_INTCTRL masks
.equ ADC_RESRDY_bm = 0x01                ; Result Ready Interrupt Enable bit mask
.equ ADC_RESRDY_bp = 0                   ; Result Ready Interrupt Enable bit position
.equ ADC_SAMPRDY_bm = 0x02               ; Sample Ready Interrupt Enable bit mask
.equ ADC_SAMPRDY_bp = 1                  ; Sample Ready Interrupt Enable bit position
.equ ADC_WCMP_bm = 0x04                  ; Window Comparator Interrupt Enable bit mask
.equ ADC_WCMP_bp = 2                     ; Window Comparator Interrupt Enable bit position
.equ ADC_RESOVR_bm = 0x08                ; Result Overwrite Interrupt Enable bit mask
.equ ADC_RESOVR_bp = 3                   ; Result Overwrite Interrupt Enable bit position
.equ ADC_SAMPOVR_bm = 0x10               ; Sample Overwrite Interrupt Enable bit mask
.equ ADC_SAMPOVR_bp = 4                  ; Sample Overwrite Interrupt Enable bit position
.equ ADC_TRIGOVR_bm = 0x20               ; Trigger Overrun Interrupt Enable bit mask
.equ ADC_TRIGOVR_bp = 5                  ; Trigger Overrun Interrupt Enable bit position

; ADC_INTFLAGS masks
; Masks for ADC_RESRDY already defined
; Masks for ADC_SAMPRDY already defined
; Masks for ADC_WCMP already defined
; Masks for ADC_RESOVR already defined
; Masks for ADC_SAMPOVR already defined
; Masks for ADC_TRIGOVR already defined

; ADC_STATUS masks
.equ ADC_ADCBUSY_bm = 0x01               ; ADC Busy bit mask
.equ ADC_ADCBUSY_bp = 0                  ; ADC Busy bit position

; ADC_DBGCTRL masks
.equ ADC_DBGRUN_bm = 0x01                ; Debug run bit mask
.equ ADC_DBGRUN_bp = 0                   ; Debug run bit position

; ADC_COMMAND masks
.equ ADC_START_gm = 0x07                 ; Start Conversion group mask
.equ ADC_START_gp = 0                    ; Start Conversion group position
.equ ADC_START_0_bm = (1<<0)             ; Start Conversion bit 0 mask
.equ ADC_START_0_bp = 0                  ; Start Conversion bit 0 position
.equ ADC_START_1_bm = (1<<1)             ; Start Conversion bit 1 mask
.equ ADC_START_1_bp = 1                  ; Start Conversion bit 1 position
.equ ADC_START_2_bm = (1<<2)             ; Start Conversion bit 2 mask
.equ ADC_START_2_bp = 2                  ; Start Conversion bit 2 position
.equ ADC_MODE_gm = 0x70                  ; Mode group mask
.equ ADC_MODE_gp = 4                     ; Mode group position
.equ ADC_MODE_0_bm = (1<<4)              ; Mode bit 0 mask
.equ ADC_MODE_0_bp = 4                   ; Mode bit 0 position
.equ ADC_MODE_1_bm = (1<<5)              ; Mode bit 1 mask
.equ ADC_MODE_1_bp = 5                   ; Mode bit 1 position
.equ ADC_MODE_2_bm = (1<<6)              ; Mode bit 2 mask
.equ ADC_MODE_2_bp = 6                   ; Mode bit 2 position

; ADC_MUXPOS masks
.equ ADC_MUXPOS_gm = 0x7F                ; Analog Channel Selection Bits group mask
.equ ADC_MUXPOS_gp = 0                   ; Analog Channel Selection Bits group position
.equ ADC_MUXPOS_0_bm = (1<<0)            ; Analog Channel Selection Bits bit 0 mask
.equ ADC_MUXPOS_0_bp = 0                 ; Analog Channel Selection Bits bit 0 position
.equ ADC_MUXPOS_1_bm = (1<<1)            ; Analog Channel Selection Bits bit 1 mask
.equ ADC_MUXPOS_1_bp = 1                 ; Analog Channel Selection Bits bit 1 position
.equ ADC_MUXPOS_2_bm = (1<<2)            ; Analog Channel Selection Bits bit 2 mask
.equ ADC_MUXPOS_2_bp = 2                 ; Analog Channel Selection Bits bit 2 position
.equ ADC_MUXPOS_3_bm = (1<<3)            ; Analog Channel Selection Bits bit 3 mask
.equ ADC_MUXPOS_3_bp = 3                 ; Analog Channel Selection Bits bit 3 position
.equ ADC_MUXPOS_4_bm = (1<<4)            ; Analog Channel Selection Bits bit 4 mask
.equ ADC_MUXPOS_4_bp = 4                 ; Analog Channel Selection Bits bit 4 position
.equ ADC_MUXPOS_5_bm = (1<<5)            ; Analog Channel Selection Bits bit 5 mask
.equ ADC_MUXPOS_5_bp = 5                 ; Analog Channel Selection Bits bit 5 position
.equ ADC_MUXPOS_6_bm = (1<<6)            ; Analog Channel Selection Bits bit 6 mask
.equ ADC_MUXPOS_6_bp = 6                 ; Analog Channel Selection Bits bit 6 position

; ADC_RESULT masks
.equ ADC_RESULT_gm = 0xFFFF              ; ADC Result group mask
.equ ADC_RESULT_gp = 0                   ; ADC Result group position
.equ ADC_RESULT_0_bm = (1<<0)            ; ADC Result bit 0 mask
.equ ADC_RESULT_0_bp = 0                 ; ADC Result bit 0 position
.equ ADC_RESULT_1_bm = (1<<1)            ; ADC Result bit 1 mask
.equ ADC_RESULT_1_bp = 1                 ; ADC Result bit 1 position
.equ ADC_RESULT_2_bm = (1<<2)            ; ADC Result bit 2 mask
.equ ADC_RESULT_2_bp = 2                 ; ADC Result bit 2 position
.equ ADC_RESULT_3_bm = (1<<3)            ; ADC Result bit 3 mask
.equ ADC_RESULT_3_bp = 3                 ; ADC Result bit 3 position
.equ ADC_RESULT_4_bm = (1<<4)            ; ADC Result bit 4 mask
.equ ADC_RESULT_4_bp = 4                 ; ADC Result bit 4 position
.equ ADC_RESULT_5_bm = (1<<5)            ; ADC Result bit 5 mask
.equ ADC_RESULT_5_bp = 5                 ; ADC Result bit 5 position
.equ ADC_RESULT_6_bm = (1<<6)            ; ADC Result bit 6 mask
.equ ADC_RESULT_6_bp = 6                 ; ADC Result bit 6 position
.equ ADC_RESULT_7_bm = (1<<7)            ; ADC Result bit 7 mask
.equ ADC_RESULT_7_bp = 7                 ; ADC Result bit 7 position
.equ ADC_RESULT_8_bm = (1<<8)            ; ADC Result bit 8 mask
.equ ADC_RESULT_8_bp = 8                 ; ADC Result bit 8 position
.equ ADC_RESULT_9_bm = (1<<9)            ; ADC Result bit 9 mask
.equ ADC_RESULT_9_bp = 9                 ; ADC Result bit 9 position
.equ ADC_RESULT_10_bm = (1<<10)          ; ADC Result bit 10 mask
.equ ADC_RESULT_10_bp = 10               ; ADC Result bit 10 position
.equ ADC_RESULT_11_bm = (1<<11)          ; ADC Result bit 11 mask
.equ ADC_RESULT_11_bp = 11               ; ADC Result bit 11 position
.equ ADC_RESULT_12_bm = (1<<12)          ; ADC Result bit 12 mask
.equ ADC_RESULT_12_bp = 12               ; ADC Result bit 12 position
.equ ADC_RESULT_13_bm = (1<<13)          ; ADC Result bit 13 mask
.equ ADC_RESULT_13_bp = 13               ; ADC Result bit 13 position
.equ ADC_RESULT_14_bm = (1<<14)          ; ADC Result bit 14 mask
.equ ADC_RESULT_14_bp = 14               ; ADC Result bit 14 position
.equ ADC_RESULT_15_bm = (1<<15)          ; ADC Result bit 15 mask
.equ ADC_RESULT_15_bp = 15               ; ADC Result bit 15 position

; ADC_SAMPLE masks
.equ ADC_SAMPLE_gm = 0xFFFF              ; ADC Sample group mask
.equ ADC_SAMPLE_gp = 0                   ; ADC Sample group position
.equ ADC_SAMPLE_0_bm = (1<<0)            ; ADC Sample bit 0 mask
.equ ADC_SAMPLE_0_bp = 0                 ; ADC Sample bit 0 position
.equ ADC_SAMPLE_1_bm = (1<<1)            ; ADC Sample bit 1 mask
.equ ADC_SAMPLE_1_bp = 1                 ; ADC Sample bit 1 position
.equ ADC_SAMPLE_2_bm = (1<<2)            ; ADC Sample bit 2 mask
.equ ADC_SAMPLE_2_bp = 2                 ; ADC Sample bit 2 position
.equ ADC_SAMPLE_3_bm = (1<<3)            ; ADC Sample bit 3 mask
.equ ADC_SAMPLE_3_bp = 3                 ; ADC Sample bit 3 position
.equ ADC_SAMPLE_4_bm = (1<<4)            ; ADC Sample bit 4 mask
.equ ADC_SAMPLE_4_bp = 4                 ; ADC Sample bit 4 position
.equ ADC_SAMPLE_5_bm = (1<<5)            ; ADC Sample bit 5 mask
.equ ADC_SAMPLE_5_bp = 5                 ; ADC Sample bit 5 position
.equ ADC_SAMPLE_6_bm = (1<<6)            ; ADC Sample bit 6 mask
.equ ADC_SAMPLE_6_bp = 6                 ; ADC Sample bit 6 position
.equ ADC_SAMPLE_7_bm = (1<<7)            ; ADC Sample bit 7 mask
.equ ADC_SAMPLE_7_bp = 7                 ; ADC Sample bit 7 position
.equ ADC_SAMPLE_8_bm = (1<<8)            ; ADC Sample bit 8 mask
.equ ADC_SAMPLE_8_bp = 8                 ; ADC Sample bit 8 position
.equ ADC_SAMPLE_9_bm = (1<<9)            ; ADC Sample bit 9 mask
.equ ADC_SAMPLE_9_bp = 9                 ; ADC Sample bit 9 position
.equ ADC_SAMPLE_10_bm = (1<<10)          ; ADC Sample bit 10 mask
.equ ADC_SAMPLE_10_bp = 10               ; ADC Sample bit 10 position
.equ ADC_SAMPLE_11_bm = (1<<11)          ; ADC Sample bit 11 mask
.equ ADC_SAMPLE_11_bp = 11               ; ADC Sample bit 11 position
.equ ADC_SAMPLE_12_bm = (1<<12)          ; ADC Sample bit 12 mask
.equ ADC_SAMPLE_12_bp = 12               ; ADC Sample bit 12 position
.equ ADC_SAMPLE_13_bm = (1<<13)          ; ADC Sample bit 13 mask
.equ ADC_SAMPLE_13_bp = 13               ; ADC Sample bit 13 position
.equ ADC_SAMPLE_14_bm = (1<<14)          ; ADC Sample bit 14 mask
.equ ADC_SAMPLE_14_bp = 14               ; ADC Sample bit 14 position
.equ ADC_SAMPLE_15_bm = (1<<15)          ; ADC Sample bit 15 mask
.equ ADC_SAMPLE_15_bp = 15               ; ADC Sample bit 15 position

; ADC_WINLT masks
.equ ADC_WINLT_gm = 0xFFFF               ; Window Low Threshold group mask
.equ ADC_WINLT_gp = 0                    ; Window Low Threshold group position
.equ ADC_WINLT_0_bm = (1<<0)             ; Window Low Threshold bit 0 mask
.equ ADC_WINLT_0_bp = 0                  ; Window Low Threshold bit 0 position
.equ ADC_WINLT_1_bm = (1<<1)             ; Window Low Threshold bit 1 mask
.equ ADC_WINLT_1_bp = 1                  ; Window Low Threshold bit 1 position
.equ ADC_WINLT_2_bm = (1<<2)             ; Window Low Threshold bit 2 mask
.equ ADC_WINLT_2_bp = 2                  ; Window Low Threshold bit 2 position
.equ ADC_WINLT_3_bm = (1<<3)             ; Window Low Threshold bit 3 mask
.equ ADC_WINLT_3_bp = 3                  ; Window Low Threshold bit 3 position
.equ ADC_WINLT_4_bm = (1<<4)             ; Window Low Threshold bit 4 mask
.equ ADC_WINLT_4_bp = 4                  ; Window Low Threshold bit 4 position
.equ ADC_WINLT_5_bm = (1<<5)             ; Window Low Threshold bit 5 mask
.equ ADC_WINLT_5_bp = 5                  ; Window Low Threshold bit 5 position
.equ ADC_WINLT_6_bm = (1<<6)             ; Window Low Threshold bit 6 mask
.equ ADC_WINLT_6_bp = 6                  ; Window Low Threshold bit 6 position
.equ ADC_WINLT_7_bm = (1<<7)             ; Window Low Threshold bit 7 mask
.equ ADC_WINLT_7_bp = 7                  ; Window Low Threshold bit 7 position
.equ ADC_WINLT_8_bm = (1<<8)             ; Window Low Threshold bit 8 mask
.equ ADC_WINLT_8_bp = 8                  ; Window Low Threshold bit 8 position
.equ ADC_WINLT_9_bm = (1<<9)             ; Window Low Threshold bit 9 mask
.equ ADC_WINLT_9_bp = 9                  ; Window Low Threshold bit 9 position
.equ ADC_WINLT_10_bm = (1<<10)           ; Window Low Threshold bit 10 mask
.equ ADC_WINLT_10_bp = 10                ; Window Low Threshold bit 10 position
.equ ADC_WINLT_11_bm = (1<<11)           ; Window Low Threshold bit 11 mask
.equ ADC_WINLT_11_bp = 11                ; Window Low Threshold bit 11 position
.equ ADC_WINLT_12_bm = (1<<12)           ; Window Low Threshold bit 12 mask
.equ ADC_WINLT_12_bp = 12                ; Window Low Threshold bit 12 position
.equ ADC_WINLT_13_bm = (1<<13)           ; Window Low Threshold bit 13 mask
.equ ADC_WINLT_13_bp = 13                ; Window Low Threshold bit 13 position
.equ ADC_WINLT_14_bm = (1<<14)           ; Window Low Threshold bit 14 mask
.equ ADC_WINLT_14_bp = 14                ; Window Low Threshold bit 14 position
.equ ADC_WINLT_15_bm = (1<<15)           ; Window Low Threshold bit 15 mask
.equ ADC_WINLT_15_bp = 15                ; Window Low Threshold bit 15 position

; ADC_WINHT masks
.equ ADC_WINHT_gm = 0xFFFF               ; Window High Threshold group mask
.equ ADC_WINHT_gp = 0                    ; Window High Threshold group position
.equ ADC_WINHT_0_bm = (1<<0)             ; Window High Threshold bit 0 mask
.equ ADC_WINHT_0_bp = 0                  ; Window High Threshold bit 0 position
.equ ADC_WINHT_1_bm = (1<<1)             ; Window High Threshold bit 1 mask
.equ ADC_WINHT_1_bp = 1                  ; Window High Threshold bit 1 position
.equ ADC_WINHT_2_bm = (1<<2)             ; Window High Threshold bit 2 mask
.equ ADC_WINHT_2_bp = 2                  ; Window High Threshold bit 2 position
.equ ADC_WINHT_3_bm = (1<<3)             ; Window High Threshold bit 3 mask
.equ ADC_WINHT_3_bp = 3                  ; Window High Threshold bit 3 position
.equ ADC_WINHT_4_bm = (1<<4)             ; Window High Threshold bit 4 mask
.equ ADC_WINHT_4_bp = 4                  ; Window High Threshold bit 4 position
.equ ADC_WINHT_5_bm = (1<<5)             ; Window High Threshold bit 5 mask
.equ ADC_WINHT_5_bp = 5                  ; Window High Threshold bit 5 position
.equ ADC_WINHT_6_bm = (1<<6)             ; Window High Threshold bit 6 mask
.equ ADC_WINHT_6_bp = 6                  ; Window High Threshold bit 6 position
.equ ADC_WINHT_7_bm = (1<<7)             ; Window High Threshold bit 7 mask
.equ ADC_WINHT_7_bp = 7                  ; Window High Threshold bit 7 position
.equ ADC_WINHT_8_bm = (1<<8)             ; Window High Threshold bit 8 mask
.equ ADC_WINHT_8_bp = 8                  ; Window High Threshold bit 8 position
.equ ADC_WINHT_9_bm = (1<<9)             ; Window High Threshold bit 9 mask
.equ ADC_WINHT_9_bp = 9                  ; Window High Threshold bit 9 position
.equ ADC_WINHT_10_bm = (1<<10)           ; Window High Threshold bit 10 mask
.equ ADC_WINHT_10_bp = 10                ; Window High Threshold bit 10 position
.equ ADC_WINHT_11_bm = (1<<11)           ; Window High Threshold bit 11 mask
.equ ADC_WINHT_11_bp = 11                ; Window High Threshold bit 11 position
.equ ADC_WINHT_12_bm = (1<<12)           ; Window High Threshold bit 12 mask
.equ ADC_WINHT_12_bp = 12                ; Window High Threshold bit 12 position
.equ ADC_WINHT_13_bm = (1<<13)           ; Window High Threshold bit 13 mask
.equ ADC_WINHT_13_bp = 13                ; Window High Threshold bit 13 position
.equ ADC_WINHT_14_bm = (1<<14)           ; Window High Threshold bit 14 mask
.equ ADC_WINHT_14_bp = 14                ; Window High Threshold bit 14 position
.equ ADC_WINHT_15_bm = (1<<15)           ; Window High Threshold bit 15 mask
.equ ADC_WINHT_15_bp = 15                ; Window High Threshold bit 15 position

; ADC_TEMP masks
.equ ADC_TEMP_gm = 0xFF                  ; Temporary group mask
.equ ADC_TEMP_gp = 0                     ; Temporary group position
.equ ADC_TEMP_0_bm = (1<<0)              ; Temporary bit 0 mask
.equ ADC_TEMP_0_bp = 0                   ; Temporary bit 0 position
.equ ADC_TEMP_1_bm = (1<<1)              ; Temporary bit 1 mask
.equ ADC_TEMP_1_bp = 1                   ; Temporary bit 1 position
.equ ADC_TEMP_2_bm = (1<<2)              ; Temporary bit 2 mask
.equ ADC_TEMP_2_bp = 2                   ; Temporary bit 2 position
.equ ADC_TEMP_3_bm = (1<<3)              ; Temporary bit 3 mask
.equ ADC_TEMP_3_bp = 3                   ; Temporary bit 3 position
.equ ADC_TEMP_4_bm = (1<<4)              ; Temporary bit 4 mask
.equ ADC_TEMP_4_bp = 4                   ; Temporary bit 4 position
.equ ADC_TEMP_5_bm = (1<<5)              ; Temporary bit 5 mask
.equ ADC_TEMP_5_bp = 5                   ; Temporary bit 5 position
.equ ADC_TEMP_6_bm = (1<<6)              ; Temporary bit 6 mask
.equ ADC_TEMP_6_bp = 6                   ; Temporary bit 6 position
.equ ADC_TEMP_7_bm = (1<<7)              ; Temporary bit 7 mask
.equ ADC_TEMP_7_bp = 7                   ; Temporary bit 7 position

; Mode select
.equ ADC_MODE_SINGLE_8BIT_gc = (0x00<<4) ; Single 8-bit conv
.equ ADC_MODE_SINGLE_10BIT_gc = (0x01<<4) ; Single 10-bit conv
.equ ADC_MODE_SERIES_gc = (0x02<<4)      ; Series of 10-bit conv
.equ ADC_MODE_BURST_gc = (0x03<<4)       ; Burst of 10-bit conv
.equ ADC_MODE_ACCTEST_gc = (0x07<<4)     ; Acc test mode for FuSa

; Start Conversion select
.equ ADC_START_STOP_gc = (0x00<<0)       ; Stop/No ongoing conv
.equ ADC_START_IMMEDIATE_gc = (0x01<<0)  ; Start Immediately
.equ ADC_START_MUXPOS_WRITE_gc = (0x02<<0) ; Start after a write to MUXPOS
.equ ADC_START_EVENT_TTRIGGER_gc = (0x03<<0) ; Start upon event reception

; Clock Pre-scaler select
.equ ADC_PRESC_DIV2_gc = (0x00<<0)       ; CLK_PER divided by 2
.equ ADC_PRESC_DIV4_gc = (0x01<<0)       ; CLK_PER divided by 4
.equ ADC_PRESC_DIV6_gc = (0x02<<0)       ; CLK_PER divided by 6
.equ ADC_PRESC_DIV8_gc = (0x03<<0)       ; CLK_PER divided by 8
.equ ADC_PRESC_DIV10_gc = (0x04<<0)      ; CLK_PER divided by 10
.equ ADC_PRESC_DIV12_gc = (0x05<<0)      ; CLK_PER divided by 12
.equ ADC_PRESC_DIV14_gc = (0x06<<0)      ; CLK_PER divided by 14
.equ ADC_PRESC_DIV16_gc = (0x07<<0)      ; CLK_PER divided by 16
.equ ADC_PRESC_DIV20_gc = (0x08<<0)      ; CLK_PER divided by 20
.equ ADC_PRESC_DIV24_gc = (0x09<<0)      ; CLK_PER divided by 24
.equ ADC_PRESC_DIV28_gc = (0x0A<<0)      ; CLK_PER divided by 28
.equ ADC_PRESC_DIV32_gc = (0x0B<<0)      ; CLK_PER divided by 32
.equ ADC_PRESC_DIV40_gc = (0x0C<<0)      ; CLK_PER divided by 40
.equ ADC_PRESC_DIV48_gc = (0x0D<<0)      ; CLK_PER divided by 48
.equ ADC_PRESC_DIV56_gc = (0x0E<<0)      ; CLK_PER divided by 56
.equ ADC_PRESC_DIV64_gc = (0x0F<<0)      ; CLK_PER divided by 64

; Reference Selection
.equ ADC_REFSEL_VDD_gc = (0x00<<0)       ; VDD
.equ ADC_REFSEL_VREFA_gc = (0x02<<0)     ; VREFA
.equ ADC_REFSEL_1V024_gc = (0x04<<0)     ; 1.024V
.equ ADC_REFSEL_2V048_gc = (0x05<<0)     ; 2.048V
.equ ADC_REFSEL_4V096_gc = (0x06<<0)     ; 4.096V
.equ ADC_REFSEL_2V500_gc = (0x07<<0)     ; 2.5V

; Window Comparator Mode select
.equ ADC_WINCM_NONE_gc = (0x00<<0)       ; No Window Comparison
.equ ADC_WINCM_BELOW_gc = (0x01<<0)      ; Below Window
.equ ADC_WINCM_ABOVE_gc = (0x02<<0)      ; Above Window
.equ ADC_WINCM_INSIDE_gc = (0x03<<0)     ; Inside Window
.equ ADC_WINCM_OUTSIDE_gc = (0x04<<0)    ; Outside Window

; Sampling Number select
.equ ADC_SAMPNUM_NONE_gc = (0x00<<0)     ; No accumulation
.equ ADC_SAMPNUM_ACC2_gc = (0x01<<0)     ; 2 results accumulated
.equ ADC_SAMPNUM_ACC4_gc = (0x02<<0)     ; 4 results accumulated
.equ ADC_SAMPNUM_ACC8_gc = (0x03<<0)     ; 8 results accumulated
.equ ADC_SAMPNUM_ACC16_gc = (0x04<<0)    ; 16 results accumulated
.equ ADC_SAMPNUM_ACC32_gc = (0x05<<0)    ; 32 results accumulated
.equ ADC_SAMPNUM_ACC64_gc = (0x06<<0)    ; 64 results accumulated

; Analog Channel Selection Bits
.equ ADC_MUXPOS_AIN0_gc = (0x00<<0)      ; ADC input pin 0
.equ ADC_MUXPOS_AIN1_gc = (0x01<<0)      ; ADC input pin 1
.equ ADC_MUXPOS_AIN2_gc = (0x02<<0)      ; ADC input pin 2
.equ ADC_MUXPOS_AIN3_gc = (0x03<<0)      ; ADC input pin 3
.equ ADC_MUXPOS_AIN4_gc = (0x04<<0)      ; ADC input pin 4
.equ ADC_MUXPOS_AIN5_gc = (0x05<<0)      ; ADC input pin 5
.equ ADC_MUXPOS_AIN6_gc = (0x06<<0)      ; ADC input pin 6
.equ ADC_MUXPOS_AIN7_gc = (0x07<<0)      ; ADC input pin 7
.equ ADC_MUXPOS_AIN16_gc = (0x10<<0)     ; ADC input pin 16
.equ ADC_MUXPOS_AIN17_gc = (0x11<<0)     ; ADC input pin 17
.equ ADC_MUXPOS_AIN18_gc = (0x12<<0)     ; ADC input pin 18
.equ ADC_MUXPOS_AIN19_gc = (0x13<<0)     ; ADC input pin 19
.equ ADC_MUXPOS_AIN20_gc = (0x14<<0)     ; ADC input pin 20
.equ ADC_MUXPOS_AIN21_gc = (0x15<<0)     ; ADC input pin 21
.equ ADC_MUXPOS_AIN22_gc = (0x16<<0)     ; ADC input pin 22
.equ ADC_MUXPOS_AIN23_gc = (0x17<<0)     ; ADC input pin 23
.equ ADC_MUXPOS_AIN24_gc = (0x18<<0)     ; ADC input pin 24
.equ ADC_MUXPOS_AIN25_gc = (0x19<<0)     ; ADC input pin 25
.equ ADC_MUXPOS_AIN26_gc = (0x1A<<0)     ; ADC input pin 26
.equ ADC_MUXPOS_AIN27_gc = (0x1B<<0)     ; ADC input pin 27
.equ ADC_MUXPOS_AIN31_gc = (0x1F<<0)     ; ADC input pin 31
.equ ADC_MUXPOS_GND_gc = (0x40<<0)       ; Ground
.equ ADC_MUXPOS_TEMPSENSE_gc = (0x42<<0) ; Temperature sensor
.equ ADC_MUXPOS_VDDDIV10_gc = (0x44<<0)  ; VDD/10
.equ ADC_MUXPOS_DACREF0_gc = (0x49<<0)   ; AC0 DAC voltage


;*************************************************************************
;** BOD - Bod interface
;*************************************************************************

; BOD_CTRLA masks
.equ BOD_SLEEP_gm = 0x03                 ; Operation in sleep mode group mask
.equ BOD_SLEEP_gp = 0                    ; Operation in sleep mode group position
.equ BOD_SLEEP_0_bm = (1<<0)             ; Operation in sleep mode bit 0 mask
.equ BOD_SLEEP_0_bp = 0                  ; Operation in sleep mode bit 0 position
.equ BOD_SLEEP_1_bm = (1<<1)             ; Operation in sleep mode bit 1 mask
.equ BOD_SLEEP_1_bp = 1                  ; Operation in sleep mode bit 1 position
.equ BOD_ACTIVE_gm = 0x0C                ; Operation in active mode group mask
.equ BOD_ACTIVE_gp = 2                   ; Operation in active mode group position
.equ BOD_ACTIVE_0_bm = (1<<2)            ; Operation in active mode bit 0 mask
.equ BOD_ACTIVE_0_bp = 2                 ; Operation in active mode bit 0 position
.equ BOD_ACTIVE_1_bm = (1<<3)            ; Operation in active mode bit 1 mask
.equ BOD_ACTIVE_1_bp = 3                 ; Operation in active mode bit 1 position
.equ BOD_SAMPFREQ_bm = 0x10              ; Sample frequency bit mask
.equ BOD_SAMPFREQ_bp = 4                 ; Sample frequency bit position

; BOD_CTRLB masks
.equ BOD_LVL_gm = 0x07                   ; Bod level group mask
.equ BOD_LVL_gp = 0                      ; Bod level group position
.equ BOD_LVL_0_bm = (1<<0)               ; Bod level bit 0 mask
.equ BOD_LVL_0_bp = 0                    ; Bod level bit 0 position
.equ BOD_LVL_1_bm = (1<<1)               ; Bod level bit 1 mask
.equ BOD_LVL_1_bp = 1                    ; Bod level bit 1 position
.equ BOD_LVL_2_bm = (1<<2)               ; Bod level bit 2 mask
.equ BOD_LVL_2_bp = 2                    ; Bod level bit 2 position

; BOD_VLMCTRLA masks
.equ BOD_VLMLVL_gm = 0x03                ; voltage level monitor level group mask
.equ BOD_VLMLVL_gp = 0                   ; voltage level monitor level group position
.equ BOD_VLMLVL_0_bm = (1<<0)            ; voltage level monitor level bit 0 mask
.equ BOD_VLMLVL_0_bp = 0                 ; voltage level monitor level bit 0 position
.equ BOD_VLMLVL_1_bm = (1<<1)            ; voltage level monitor level bit 1 mask
.equ BOD_VLMLVL_1_bp = 1                 ; voltage level monitor level bit 1 position

; BOD_INTCTRL masks
.equ BOD_VLMIE_bm = 0x01                 ; voltage level monitor interrrupt enable bit mask
.equ BOD_VLMIE_bp = 0                    ; voltage level monitor interrrupt enable bit position
.equ BOD_VLMCFG_gm = 0x06                ; Configuration group mask
.equ BOD_VLMCFG_gp = 1                   ; Configuration group position
.equ BOD_VLMCFG_0_bm = (1<<1)            ; Configuration bit 0 mask
.equ BOD_VLMCFG_0_bp = 1                 ; Configuration bit 0 position
.equ BOD_VLMCFG_1_bm = (1<<2)            ; Configuration bit 1 mask
.equ BOD_VLMCFG_1_bp = 2                 ; Configuration bit 1 position

; BOD_INTFLAGS masks
.equ BOD_VLMIF_bm = 0x01                 ; Voltage level monitor interrupt flag bit mask
.equ BOD_VLMIF_bp = 0                    ; Voltage level monitor interrupt flag bit position

; BOD_STATUS masks
.equ BOD_VLMS_bm = 0x01                  ; Voltage level monitor status bit mask
.equ BOD_VLMS_bp = 0                     ; Voltage level monitor status bit position

; Operation in active mode select
.equ BOD_ACTIVE_DIS_gc = (0x00<<2)       ; Disabled
.equ BOD_ACTIVE_ENABLED_gc = (0x01<<2)   ; Enabled
.equ BOD_ACTIVE_SAMPLED_gc = (0x02<<2)   ; Sampled
.equ BOD_ACTIVE_ENWAKE_gc = (0x03<<2)    ; Enabled with wake-up halted until BOD is ready

; Sample frequency select
.equ BOD_SAMPFREQ_128HZ_gc = (0x00<<4)   ; 128Hz sampling frequency
.equ BOD_SAMPFREQ_32HZ_gc = (0x01<<4)    ; 32Hz sampling frequency

; Operation in sleep mode select
.equ BOD_SLEEP_DIS_gc = (0x00<<0)        ; Disabled
.equ BOD_SLEEP_ENABLED_gc = (0x01<<0)    ; Enabled
.equ BOD_SLEEP_SAMPLED_gc = (0x02<<0)    ; Sampled

; Bod level select
.equ BOD_LVL_BODLEVEL0_gc = (0x00<<0)    ; 1.9 V
.equ BOD_LVL_BODLEVEL1_gc = (0x01<<0)    ; 2.45 V
.equ BOD_LVL_BODLEVEL2_gc = (0x02<<0)    ; 2.7 V
.equ BOD_LVL_BODLEVEL3_gc = (0x03<<0)    ; 2.85 V

; Configuration select
.equ BOD_VLMCFG_FALLING_gc = (0x00<<1)   ; VDD falls below VLM threshold
.equ BOD_VLMCFG_RISING_gc = (0x01<<1)    ; VDD rises above VLM threshold
.equ BOD_VLMCFG_BOTH_gc = (0x02<<1)      ; VDD crosses VLM threshold

; Voltage level monitor status select
.equ BOD_VLMS_ABOVE_gc = (0x00<<0)       ; The voltage is above the VLM threshold level
.equ BOD_VLMS_BELOW_gc = (0x01<<0)       ; The voltage is below the VLM threshold level

; voltage level monitor level select
.equ BOD_VLMLVL_OFF_gc = (0x00<<0)       ; VLM Disabled
.equ BOD_VLMLVL_5ABOVE_gc = (0x01<<0)    ; VLM threshold 5% above BOD level
.equ BOD_VLMLVL_15ABOVE_gc = (0x02<<0)   ; VLM threshold 15% above BOD level
.equ BOD_VLMLVL_25ABOVE_gc = (0x03<<0)   ; VLM threshold 25% above BOD level


;*************************************************************************
;** BOOTROW - Boot Row
;*************************************************************************


;*************************************************************************
;** CCL - Configurable Custom Logic
;*************************************************************************

; CCL_CTRLA masks
.equ CCL_ENABLE_bm = 0x01                ; Enable bit mask
.equ CCL_ENABLE_bp = 0                   ; Enable bit position
.equ CCL_RUNSTDBY_bm = 0x40              ; Run in Standby bit mask
.equ CCL_RUNSTDBY_bp = 6                 ; Run in Standby bit position

; CCL_SEQCTRL0 masks
.equ CCL_SEQSEL_gm = 0x0F                ; Sequential Selection group mask
.equ CCL_SEQSEL_gp = 0                   ; Sequential Selection group position
.equ CCL_SEQSEL_0_bm = (1<<0)            ; Sequential Selection bit 0 mask
.equ CCL_SEQSEL_0_bp = 0                 ; Sequential Selection bit 0 position
.equ CCL_SEQSEL_1_bm = (1<<1)            ; Sequential Selection bit 1 mask
.equ CCL_SEQSEL_1_bp = 1                 ; Sequential Selection bit 1 position
.equ CCL_SEQSEL_2_bm = (1<<2)            ; Sequential Selection bit 2 mask
.equ CCL_SEQSEL_2_bp = 2                 ; Sequential Selection bit 2 position
.equ CCL_SEQSEL_3_bm = (1<<3)            ; Sequential Selection bit 3 mask
.equ CCL_SEQSEL_3_bp = 3                 ; Sequential Selection bit 3 position

; CCL_SEQCTRL1 masks
; Masks for CCL_SEQSEL already defined

; CCL_INTCTRL0 masks
.equ CCL_INTMODE0_gm = 0x03              ; Interrupt Mode for LUT0 group mask
.equ CCL_INTMODE0_gp = 0                 ; Interrupt Mode for LUT0 group position
.equ CCL_INTMODE0_0_bm = (1<<0)          ; Interrupt Mode for LUT0 bit 0 mask
.equ CCL_INTMODE0_0_bp = 0               ; Interrupt Mode for LUT0 bit 0 position
.equ CCL_INTMODE0_1_bm = (1<<1)          ; Interrupt Mode for LUT0 bit 1 mask
.equ CCL_INTMODE0_1_bp = 1               ; Interrupt Mode for LUT0 bit 1 position
.equ CCL_INTMODE1_gm = 0x0C              ; Interrupt Mode for LUT1 group mask
.equ CCL_INTMODE1_gp = 2                 ; Interrupt Mode for LUT1 group position
.equ CCL_INTMODE1_0_bm = (1<<2)          ; Interrupt Mode for LUT1 bit 0 mask
.equ CCL_INTMODE1_0_bp = 2               ; Interrupt Mode for LUT1 bit 0 position
.equ CCL_INTMODE1_1_bm = (1<<3)          ; Interrupt Mode for LUT1 bit 1 mask
.equ CCL_INTMODE1_1_bp = 3               ; Interrupt Mode for LUT1 bit 1 position
.equ CCL_INTMODE2_gm = 0x30              ; Interrupt Mode for LUT2 group mask
.equ CCL_INTMODE2_gp = 4                 ; Interrupt Mode for LUT2 group position
.equ CCL_INTMODE2_0_bm = (1<<4)          ; Interrupt Mode for LUT2 bit 0 mask
.equ CCL_INTMODE2_0_bp = 4               ; Interrupt Mode for LUT2 bit 0 position
.equ CCL_INTMODE2_1_bm = (1<<5)          ; Interrupt Mode for LUT2 bit 1 mask
.equ CCL_INTMODE2_1_bp = 5               ; Interrupt Mode for LUT2 bit 1 position
.equ CCL_INTMODE3_gm = 0xC0              ; Interrupt Mode for LUT3 group mask
.equ CCL_INTMODE3_gp = 6                 ; Interrupt Mode for LUT3 group position
.equ CCL_INTMODE3_0_bm = (1<<6)          ; Interrupt Mode for LUT3 bit 0 mask
.equ CCL_INTMODE3_0_bp = 6               ; Interrupt Mode for LUT3 bit 0 position
.equ CCL_INTMODE3_1_bm = (1<<7)          ; Interrupt Mode for LUT3 bit 1 mask
.equ CCL_INTMODE3_1_bp = 7               ; Interrupt Mode for LUT3 bit 1 position

; CCL_INTFLAGS masks
.equ CCL_INT_gm = 0x0F                   ; Interrupt Flag group mask
.equ CCL_INT_gp = 0                      ; Interrupt Flag group position
.equ CCL_INT_0_bm = (1<<0)               ; Interrupt Flag bit 0 mask
.equ CCL_INT_0_bp = 0                    ; Interrupt Flag bit 0 position
.equ CCL_INT_1_bm = (1<<1)               ; Interrupt Flag bit 1 mask
.equ CCL_INT_1_bp = 1                    ; Interrupt Flag bit 1 position
.equ CCL_INT_2_bm = (1<<2)               ; Interrupt Flag bit 2 mask
.equ CCL_INT_2_bp = 2                    ; Interrupt Flag bit 2 position
.equ CCL_INT_3_bm = (1<<3)               ; Interrupt Flag bit 3 mask
.equ CCL_INT_3_bp = 3                    ; Interrupt Flag bit 3 position

; CCL_LUT0CTRLA masks
; Masks for CCL_ENABLE already defined
.equ CCL_CLKSRC_gm = 0x0E                ; Clock Source Selection group mask
.equ CCL_CLKSRC_gp = 1                   ; Clock Source Selection group position
.equ CCL_CLKSRC_0_bm = (1<<1)            ; Clock Source Selection bit 0 mask
.equ CCL_CLKSRC_0_bp = 1                 ; Clock Source Selection bit 0 position
.equ CCL_CLKSRC_1_bm = (1<<2)            ; Clock Source Selection bit 1 mask
.equ CCL_CLKSRC_1_bp = 2                 ; Clock Source Selection bit 1 position
.equ CCL_CLKSRC_2_bm = (1<<3)            ; Clock Source Selection bit 2 mask
.equ CCL_CLKSRC_2_bp = 3                 ; Clock Source Selection bit 2 position
.equ CCL_FILTSEL_gm = 0x30               ; Filter Selection group mask
.equ CCL_FILTSEL_gp = 4                  ; Filter Selection group position
.equ CCL_FILTSEL_0_bm = (1<<4)           ; Filter Selection bit 0 mask
.equ CCL_FILTSEL_0_bp = 4                ; Filter Selection bit 0 position
.equ CCL_FILTSEL_1_bm = (1<<5)           ; Filter Selection bit 1 mask
.equ CCL_FILTSEL_1_bp = 5                ; Filter Selection bit 1 position
.equ CCL_OUTEN_bm = 0x40                 ; Output Enable bit mask
.equ CCL_OUTEN_bp = 6                    ; Output Enable bit position
.equ CCL_EDGEDET_bm = 0x80               ; Edge Detection Enable bit mask
.equ CCL_EDGEDET_bp = 7                  ; Edge Detection Enable bit position

; CCL_LUT0CTRLB masks
.equ CCL_INSEL0_gm = 0x0F                ; LUT Input 0 Source Selection group mask
.equ CCL_INSEL0_gp = 0                   ; LUT Input 0 Source Selection group position
.equ CCL_INSEL0_0_bm = (1<<0)            ; LUT Input 0 Source Selection bit 0 mask
.equ CCL_INSEL0_0_bp = 0                 ; LUT Input 0 Source Selection bit 0 position
.equ CCL_INSEL0_1_bm = (1<<1)            ; LUT Input 0 Source Selection bit 1 mask
.equ CCL_INSEL0_1_bp = 1                 ; LUT Input 0 Source Selection bit 1 position
.equ CCL_INSEL0_2_bm = (1<<2)            ; LUT Input 0 Source Selection bit 2 mask
.equ CCL_INSEL0_2_bp = 2                 ; LUT Input 0 Source Selection bit 2 position
.equ CCL_INSEL0_3_bm = (1<<3)            ; LUT Input 0 Source Selection bit 3 mask
.equ CCL_INSEL0_3_bp = 3                 ; LUT Input 0 Source Selection bit 3 position
.equ CCL_INSEL1_gm = 0xF0                ; LUT Input 1 Source Selection group mask
.equ CCL_INSEL1_gp = 4                   ; LUT Input 1 Source Selection group position
.equ CCL_INSEL1_0_bm = (1<<4)            ; LUT Input 1 Source Selection bit 0 mask
.equ CCL_INSEL1_0_bp = 4                 ; LUT Input 1 Source Selection bit 0 position
.equ CCL_INSEL1_1_bm = (1<<5)            ; LUT Input 1 Source Selection bit 1 mask
.equ CCL_INSEL1_1_bp = 5                 ; LUT Input 1 Source Selection bit 1 position
.equ CCL_INSEL1_2_bm = (1<<6)            ; LUT Input 1 Source Selection bit 2 mask
.equ CCL_INSEL1_2_bp = 6                 ; LUT Input 1 Source Selection bit 2 position
.equ CCL_INSEL1_3_bm = (1<<7)            ; LUT Input 1 Source Selection bit 3 mask
.equ CCL_INSEL1_3_bp = 7                 ; LUT Input 1 Source Selection bit 3 position

; CCL_LUT0CTRLC masks
.equ CCL_INSEL2_gm = 0x0F                ; LUT Input 2 Source Selection group mask
.equ CCL_INSEL2_gp = 0                   ; LUT Input 2 Source Selection group position
.equ CCL_INSEL2_0_bm = (1<<0)            ; LUT Input 2 Source Selection bit 0 mask
.equ CCL_INSEL2_0_bp = 0                 ; LUT Input 2 Source Selection bit 0 position
.equ CCL_INSEL2_1_bm = (1<<1)            ; LUT Input 2 Source Selection bit 1 mask
.equ CCL_INSEL2_1_bp = 1                 ; LUT Input 2 Source Selection bit 1 position
.equ CCL_INSEL2_2_bm = (1<<2)            ; LUT Input 2 Source Selection bit 2 mask
.equ CCL_INSEL2_2_bp = 2                 ; LUT Input 2 Source Selection bit 2 position
.equ CCL_INSEL2_3_bm = (1<<3)            ; LUT Input 2 Source Selection bit 3 mask
.equ CCL_INSEL2_3_bp = 3                 ; LUT Input 2 Source Selection bit 3 position

; CCL_TRUTH0 masks
.equ CCL_TRUTH_gm = 0xFF                 ; Truth Table group mask
.equ CCL_TRUTH_gp = 0                    ; Truth Table group position
.equ CCL_TRUTH_0_bm = (1<<0)             ; Truth Table bit 0 mask
.equ CCL_TRUTH_0_bp = 0                  ; Truth Table bit 0 position
.equ CCL_TRUTH_1_bm = (1<<1)             ; Truth Table bit 1 mask
.equ CCL_TRUTH_1_bp = 1                  ; Truth Table bit 1 position
.equ CCL_TRUTH_2_bm = (1<<2)             ; Truth Table bit 2 mask
.equ CCL_TRUTH_2_bp = 2                  ; Truth Table bit 2 position
.equ CCL_TRUTH_3_bm = (1<<3)             ; Truth Table bit 3 mask
.equ CCL_TRUTH_3_bp = 3                  ; Truth Table bit 3 position
.equ CCL_TRUTH_4_bm = (1<<4)             ; Truth Table bit 4 mask
.equ CCL_TRUTH_4_bp = 4                  ; Truth Table bit 4 position
.equ CCL_TRUTH_5_bm = (1<<5)             ; Truth Table bit 5 mask
.equ CCL_TRUTH_5_bp = 5                  ; Truth Table bit 5 position
.equ CCL_TRUTH_6_bm = (1<<6)             ; Truth Table bit 6 mask
.equ CCL_TRUTH_6_bp = 6                  ; Truth Table bit 6 position
.equ CCL_TRUTH_7_bm = (1<<7)             ; Truth Table bit 7 mask
.equ CCL_TRUTH_7_bp = 7                  ; Truth Table bit 7 position

; CCL_LUT1CTRLA masks
; Masks for CCL_ENABLE already defined
; Masks for CCL_CLKSRC already defined
; Masks for CCL_FILTSEL already defined
; Masks for CCL_OUTEN already defined
; Masks for CCL_EDGEDET already defined

; CCL_LUT1CTRLB masks
; Masks for CCL_INSEL0 already defined
; Masks for CCL_INSEL1 already defined

; CCL_LUT1CTRLC masks
; Masks for CCL_INSEL2 already defined

; CCL_TRUTH1 masks
; Masks for CCL_TRUTH already defined

; CCL_LUT2CTRLA masks
; Masks for CCL_ENABLE already defined
; Masks for CCL_CLKSRC already defined
; Masks for CCL_FILTSEL already defined
; Masks for CCL_OUTEN already defined
; Masks for CCL_EDGEDET already defined

; CCL_LUT2CTRLB masks
; Masks for CCL_INSEL0 already defined
; Masks for CCL_INSEL1 already defined

; CCL_LUT2CTRLC masks
; Masks for CCL_INSEL2 already defined

; CCL_TRUTH2 masks
; Masks for CCL_TRUTH already defined

; CCL_LUT3CTRLA masks
; Masks for CCL_ENABLE already defined
; Masks for CCL_CLKSRC already defined
; Masks for CCL_FILTSEL already defined
; Masks for CCL_OUTEN already defined
; Masks for CCL_EDGEDET already defined

; CCL_LUT3CTRLB masks
; Masks for CCL_INSEL0 already defined
; Masks for CCL_INSEL1 already defined

; CCL_LUT3CTRLC masks
; Masks for CCL_INSEL2 already defined

; CCL_TRUTH3 masks
; Masks for CCL_TRUTH already defined

; Interrupt Mode for LUT0 select
.equ CCL_INTMODE0_INTDISABLE_gc = (0x00<<0) ; Interrupt disabled
.equ CCL_INTMODE0_RISING_gc = (0x01<<0)  ; Sense rising edge
.equ CCL_INTMODE0_FALLING_gc = (0x02<<0) ; Sense falling edge
.equ CCL_INTMODE0_BOTH_gc = (0x03<<0)    ; Sense both edges

; Interrupt Mode for LUT1 select
.equ CCL_INTMODE1_INTDISABLE_gc = (0x00<<2) ; Interrupt disabled
.equ CCL_INTMODE1_RISING_gc = (0x01<<2)  ; Sense rising edge
.equ CCL_INTMODE1_FALLING_gc = (0x02<<2) ; Sense falling edge
.equ CCL_INTMODE1_BOTH_gc = (0x03<<2)    ; Sense both edges

; Interrupt Mode for LUT2 select
.equ CCL_INTMODE2_INTDISABLE_gc = (0x00<<4) ; Interrupt disabled
.equ CCL_INTMODE2_RISING_gc = (0x01<<4)  ; Sense rising edge
.equ CCL_INTMODE2_FALLING_gc = (0x02<<4) ; Sense falling edge
.equ CCL_INTMODE2_BOTH_gc = (0x03<<4)    ; Sense both edges

; Interrupt Mode for LUT3 select
.equ CCL_INTMODE3_INTDISABLE_gc = (0x00<<6) ; Interrupt disabled
.equ CCL_INTMODE3_RISING_gc = (0x01<<6)  ; Sense rising edge
.equ CCL_INTMODE3_FALLING_gc = (0x02<<6) ; Sense falling edge
.equ CCL_INTMODE3_BOTH_gc = (0x03<<6)    ; Sense both edges

; Clock Source Selection
.equ CCL_CLKSRC_CLKPER_gc = (0x00<<1)    ; Peripheral Clock
.equ CCL_CLKSRC_IN2_gc = (0x01<<1)       ; Selection by INSEL2
.equ CCL_CLKSRC_OSCHF_gc = (0x04<<1)     ; Internal High-Frequency Oscillator
.equ CCL_CLKSRC_OSC32K_gc = (0x05<<1)    ; 32.768 kHz oscillator
.equ CCL_CLKSRC_OSC1K_gc = (0x06<<1)     ; 32.768 kHz oscillator divided by 32

; Edge Detection Enable select
.equ CCL_EDGEDET_DIS_gc = (0x00<<7)      ; Edge detector is disabled
.equ CCL_EDGEDET_EN_gc = (0x01<<7)       ; Edge detector is enabled

; Filter Selection
.equ CCL_FILTSEL_DISABLE_gc = (0x00<<4)  ; Filter disabled
.equ CCL_FILTSEL_SYNCH_gc = (0x01<<4)    ; Synchronizer enabled
.equ CCL_FILTSEL_FILTER_gc = (0x02<<4)   ; Filter enabled

; LUT Input 0 Source Selection
.equ CCL_INSEL0_MASK_gc = (0x00<<0)      ; Masked input
.equ CCL_INSEL0_FEEDBACK_gc = (0x01<<0)  ; Feedback input source
.equ CCL_INSEL0_LINK_gc = (0x02<<0)      ; Linked LUT input source
.equ CCL_INSEL0_EVENTA_gc = (0x03<<0)    ; Event input source A
.equ CCL_INSEL0_EVENTB_gc = (0x04<<0)    ; Event input source B
.equ CCL_INSEL0_IN0_gc = (0x05<<0)       ; IO pin LUTn-IN0 input source
.equ CCL_INSEL0_AC0_gc = (0x06<<0)       ; AC0 OUT input source
.equ CCL_INSEL0_USART0_gc = (0x07<<0)    ; USART0 TXD input source
.equ CCL_INSEL0_SPI0_gc = (0x08<<0)      ; SPI0 MOSI input source
.equ CCL_INSEL0_TCA0_gc = (0x09<<0)      ; TCA0 WO0 input source
.equ CCL_INSEL0_TCB0_gc = (0x0A<<0)      ; TCB0 WO input source

; LUT Input 1 Source Selection
.equ CCL_INSEL1_MASK_gc = (0x00<<4)      ; Masked input
.equ CCL_INSEL1_FEEDBACK_gc = (0x01<<4)  ; Feedback input source
.equ CCL_INSEL1_LINK_gc = (0x02<<4)      ; Linked LUT input source
.equ CCL_INSEL1_EVENTA_gc = (0x03<<4)    ; Event input source A
.equ CCL_INSEL1_EVENTB_gc = (0x04<<4)    ; Event input source B
.equ CCL_INSEL1_IN1_gc = (0x05<<4)       ; IO pin LUTn-IN1 input source
.equ CCL_INSEL1_AC0_gc = (0x06<<4)       ; AC0 OUT input source
.equ CCL_INSEL1_USART1_gc = (0x07<<4)    ; USART1 TXD input source
.equ CCL_INSEL1_SPI0_gc = (0x08<<4)      ; SPI0 MOSI input source
.equ CCL_INSEL1_TCA0_gc = (0x09<<4)      ; TCA0 WO1 input source
.equ CCL_INSEL1_TCB1_gc = (0x0A<<4)      ; TCB1 WO input source

; LUT Input 2 Source Selection
.equ CCL_INSEL2_MASK_gc = (0x00<<0)      ; Masked input
.equ CCL_INSEL2_FEEDBACK_gc = (0x01<<0)  ; Feedback input source
.equ CCL_INSEL2_LINK_gc = (0x02<<0)      ; Linked LUT input source
.equ CCL_INSEL2_EVENTA_gc = (0x03<<0)    ; Event input source A
.equ CCL_INSEL2_EVENTB_gc = (0x04<<0)    ; Event input source B
.equ CCL_INSEL2_IN2_gc = (0x05<<0)       ; IO pin LUTn-IN2 input source
.equ CCL_INSEL2_AC0_gc = (0x06<<0)       ; AC0 OUT input source
.equ CCL_INSEL2_USART1_gc = (0x07<<0)    ; USART1 TXD input source
.equ CCL_INSEL2_SPI0_gc = (0x08<<0)      ; SPI0 SCK input source
.equ CCL_INSEL2_TCA0_gc = (0x09<<0)      ; TCA0 WO2 input source
.equ CCL_INSEL2_TCB1_gc = (0x0A<<0)      ; TCB1 WO input source

; Sequential Selection
.equ CCL_SEQSEL_DISABLE_gc = (0x00<<0)   ; Sequential logic disabled
.equ CCL_SEQSEL_DFF_gc = (0x01<<0)       ; D FlipFlop
.equ CCL_SEQSEL_JK_gc = (0x02<<0)        ; JK FlipFlop
.equ CCL_SEQSEL_LATCH_gc = (0x03<<0)     ; D Latch
.equ CCL_SEQSEL_RS_gc = (0x04<<0)        ; RS Latch


;*************************************************************************
;** CLKCTRL - Clock controller
;*************************************************************************

; CLKCTRL_MCLKCTRLA masks
.equ CLKCTRL_CLKSEL_gm = 0x07            ; Clock select group mask
.equ CLKCTRL_CLKSEL_gp = 0               ; Clock select group position
.equ CLKCTRL_CLKSEL_0_bm = (1<<0)        ; Clock select bit 0 mask
.equ CLKCTRL_CLKSEL_0_bp = 0             ; Clock select bit 0 position
.equ CLKCTRL_CLKSEL_1_bm = (1<<1)        ; Clock select bit 1 mask
.equ CLKCTRL_CLKSEL_1_bp = 1             ; Clock select bit 1 position
.equ CLKCTRL_CLKSEL_2_bm = (1<<2)        ; Clock select bit 2 mask
.equ CLKCTRL_CLKSEL_2_bp = 2             ; Clock select bit 2 position
.equ CLKCTRL_CLKOUT_bm = 0x80            ; System clock out bit mask
.equ CLKCTRL_CLKOUT_bp = 7               ; System clock out bit position

; CLKCTRL_MCLKCTRLB masks
.equ CLKCTRL_PEN_bm = 0x01               ; Prescaler enable bit mask
.equ CLKCTRL_PEN_bp = 0                  ; Prescaler enable bit position
.equ CLKCTRL_PDIV_gm = 0x1E              ; Prescaler division group mask
.equ CLKCTRL_PDIV_gp = 1                 ; Prescaler division group position
.equ CLKCTRL_PDIV_0_bm = (1<<1)          ; Prescaler division bit 0 mask
.equ CLKCTRL_PDIV_0_bp = 1               ; Prescaler division bit 0 position
.equ CLKCTRL_PDIV_1_bm = (1<<2)          ; Prescaler division bit 1 mask
.equ CLKCTRL_PDIV_1_bp = 2               ; Prescaler division bit 1 position
.equ CLKCTRL_PDIV_2_bm = (1<<3)          ; Prescaler division bit 2 mask
.equ CLKCTRL_PDIV_2_bp = 3               ; Prescaler division bit 2 position
.equ CLKCTRL_PDIV_3_bm = (1<<4)          ; Prescaler division bit 3 mask
.equ CLKCTRL_PDIV_3_bp = 4               ; Prescaler division bit 3 position

; CLKCTRL_MCLKCTRLC masks
.equ CLKCTRL_CFDEN_bm = 0x01             ; Clock Failure Detect Enable bit mask
.equ CLKCTRL_CFDEN_bp = 0                ; Clock Failure Detect Enable bit position
.equ CLKCTRL_CFDTST_bm = 0x02            ; Clock Failure Detect Test bit mask
.equ CLKCTRL_CFDTST_bp = 1               ; Clock Failure Detect Test bit position
.equ CLKCTRL_CFDSRC_gm = 0x0C            ; Clock Failure Detect Source group mask
.equ CLKCTRL_CFDSRC_gp = 2               ; Clock Failure Detect Source group position
.equ CLKCTRL_CFDSRC_0_bm = (1<<2)        ; Clock Failure Detect Source bit 0 mask
.equ CLKCTRL_CFDSRC_0_bp = 2             ; Clock Failure Detect Source bit 0 position
.equ CLKCTRL_CFDSRC_1_bm = (1<<3)        ; Clock Failure Detect Source bit 1 mask
.equ CLKCTRL_CFDSRC_1_bp = 3             ; Clock Failure Detect Source bit 1 position

; CLKCTRL_MCLKINTCTRL masks
.equ CLKCTRL_CFD_bm = 0x01               ; Clock Failure Detect Interrupt Enable bit mask
.equ CLKCTRL_CFD_bp = 0                  ; Clock Failure Detect Interrupt Enable bit position
.equ CLKCTRL_INTTYPE_bm = 0x80           ; Interrupt type bit mask
.equ CLKCTRL_INTTYPE_bp = 7              ; Interrupt type bit position

; CLKCTRL_MCLKINTFLAGS masks
; Masks for CLKCTRL_CFD already defined

; CLKCTRL_MCLKSTATUS masks
.equ CLKCTRL_SOSC_bm = 0x01              ; System Oscillator changing bit mask
.equ CLKCTRL_SOSC_bp = 0                 ; System Oscillator changing bit position
.equ CLKCTRL_OSCHFS_bm = 0x02            ; High frequency oscillator status bit mask
.equ CLKCTRL_OSCHFS_bp = 1               ; High frequency oscillator status bit position
.equ CLKCTRL_OSC32KS_bm = 0x04           ; 32KHz oscillator status bit mask
.equ CLKCTRL_OSC32KS_bp = 2              ; 32KHz oscillator status bit position
.equ CLKCTRL_XOSC32KS_bm = 0x08          ; 32.768 kHz Crystal Oscillator status bit mask
.equ CLKCTRL_XOSC32KS_bp = 3             ; 32.768 kHz Crystal Oscillator status bit position
.equ CLKCTRL_EXTS_bm = 0x10              ; External Clock status bit mask
.equ CLKCTRL_EXTS_bp = 4                 ; External Clock status bit position

; CLKCTRL_MCLKTIMEBASE masks
.equ CLKCTRL_TIMEBASE_gm = 0x1F          ; Timebase group mask
.equ CLKCTRL_TIMEBASE_gp = 0             ; Timebase group position
.equ CLKCTRL_TIMEBASE_0_bm = (1<<0)      ; Timebase bit 0 mask
.equ CLKCTRL_TIMEBASE_0_bp = 0           ; Timebase bit 0 position
.equ CLKCTRL_TIMEBASE_1_bm = (1<<1)      ; Timebase bit 1 mask
.equ CLKCTRL_TIMEBASE_1_bp = 1           ; Timebase bit 1 position
.equ CLKCTRL_TIMEBASE_2_bm = (1<<2)      ; Timebase bit 2 mask
.equ CLKCTRL_TIMEBASE_2_bp = 2           ; Timebase bit 2 position
.equ CLKCTRL_TIMEBASE_3_bm = (1<<3)      ; Timebase bit 3 mask
.equ CLKCTRL_TIMEBASE_3_bp = 3           ; Timebase bit 3 position
.equ CLKCTRL_TIMEBASE_4_bm = (1<<4)      ; Timebase bit 4 mask
.equ CLKCTRL_TIMEBASE_4_bp = 4           ; Timebase bit 4 position

; CLKCTRL_OSCHFCTRLA masks
.equ CLKCTRL_AUTOTUNE_gm = 0x03          ; Autotune group mask
.equ CLKCTRL_AUTOTUNE_gp = 0             ; Autotune group position
.equ CLKCTRL_AUTOTUNE_0_bm = (1<<0)      ; Autotune bit 0 mask
.equ CLKCTRL_AUTOTUNE_0_bp = 0           ; Autotune bit 0 position
.equ CLKCTRL_AUTOTUNE_1_bm = (1<<1)      ; Autotune bit 1 mask
.equ CLKCTRL_AUTOTUNE_1_bp = 1           ; Autotune bit 1 position
.equ CLKCTRL_FRQSEL_gm = 0x3C            ; Frequency select group mask
.equ CLKCTRL_FRQSEL_gp = 2               ; Frequency select group position
.equ CLKCTRL_FRQSEL_0_bm = (1<<2)        ; Frequency select bit 0 mask
.equ CLKCTRL_FRQSEL_0_bp = 2             ; Frequency select bit 0 position
.equ CLKCTRL_FRQSEL_1_bm = (1<<3)        ; Frequency select bit 1 mask
.equ CLKCTRL_FRQSEL_1_bp = 3             ; Frequency select bit 1 position
.equ CLKCTRL_FRQSEL_2_bm = (1<<4)        ; Frequency select bit 2 mask
.equ CLKCTRL_FRQSEL_2_bp = 4             ; Frequency select bit 2 position
.equ CLKCTRL_FRQSEL_3_bm = (1<<5)        ; Frequency select bit 3 mask
.equ CLKCTRL_FRQSEL_3_bp = 5             ; Frequency select bit 3 position
.equ CLKCTRL_ALGSEL_bm = 0x40            ; Algorithm Selection bit mask
.equ CLKCTRL_ALGSEL_bp = 6               ; Algorithm Selection bit position
.equ CLKCTRL_RUNSTDBY_bm = 0x80          ; Run standby bit mask
.equ CLKCTRL_RUNSTDBY_bp = 7             ; Run standby bit position

; CLKCTRL_OSCHFTUNE masks
.equ CLKCTRL_TUNE_gm = 0x7F              ; Tune group mask
.equ CLKCTRL_TUNE_gp = 0                 ; Tune group position
.equ CLKCTRL_TUNE_0_bm = (1<<0)          ; Tune bit 0 mask
.equ CLKCTRL_TUNE_0_bp = 0               ; Tune bit 0 position
.equ CLKCTRL_TUNE_1_bm = (1<<1)          ; Tune bit 1 mask
.equ CLKCTRL_TUNE_1_bp = 1               ; Tune bit 1 position
.equ CLKCTRL_TUNE_2_bm = (1<<2)          ; Tune bit 2 mask
.equ CLKCTRL_TUNE_2_bp = 2               ; Tune bit 2 position
.equ CLKCTRL_TUNE_3_bm = (1<<3)          ; Tune bit 3 mask
.equ CLKCTRL_TUNE_3_bp = 3               ; Tune bit 3 position
.equ CLKCTRL_TUNE_4_bm = (1<<4)          ; Tune bit 4 mask
.equ CLKCTRL_TUNE_4_bp = 4               ; Tune bit 4 position
.equ CLKCTRL_TUNE_5_bm = (1<<5)          ; Tune bit 5 mask
.equ CLKCTRL_TUNE_5_bp = 5               ; Tune bit 5 position
.equ CLKCTRL_TUNE_6_bm = (1<<6)          ; Tune bit 6 mask
.equ CLKCTRL_TUNE_6_bp = 6               ; Tune bit 6 position

; CLKCTRL_OSCHFSTATUS masks
.equ CLKCTRL_ATSYNC_bm = 0x01            ; Autotune in Lock bit mask
.equ CLKCTRL_ATSYNC_bp = 0               ; Autotune in Lock bit position
.equ CLKCTRL_ATLOCK_bm = 0x02            ; Autotune Synchronized bit mask
.equ CLKCTRL_ATLOCK_bp = 1               ; Autotune Synchronized bit position

; CLKCTRL_OSC32KCTRLA masks
; Masks for CLKCTRL_RUNSTDBY already defined

; CLKCTRL_XOSC32KCTRLA masks
.equ CLKCTRL_ENABLE_bm = 0x01            ; Enable bit mask
.equ CLKCTRL_ENABLE_bp = 0               ; Enable bit position
.equ CLKCTRL_LPMODE_bm = 0x02            ; Low power mode bit mask
.equ CLKCTRL_LPMODE_bp = 1               ; Low power mode bit position
.equ CLKCTRL_SEL_bm = 0x04               ; Select bit mask
.equ CLKCTRL_SEL_bp = 2                  ; Select bit position
.equ CLKCTRL_CSUT_gm = 0x30              ; Crystal startup time group mask
.equ CLKCTRL_CSUT_gp = 4                 ; Crystal startup time group position
.equ CLKCTRL_CSUT_0_bm = (1<<4)          ; Crystal startup time bit 0 mask
.equ CLKCTRL_CSUT_0_bp = 4               ; Crystal startup time bit 0 position
.equ CLKCTRL_CSUT_1_bm = (1<<5)          ; Crystal startup time bit 1 mask
.equ CLKCTRL_CSUT_1_bp = 5               ; Crystal startup time bit 1 position
; Masks for CLKCTRL_RUNSTDBY already defined

; CLKCTRL_XOSCHFCTRLA masks
; Masks for CLKCTRL_ENABLE already defined
.equ CLKCTRL_SELHF_bm = 0x02             ; External Source Select bit mask
.equ CLKCTRL_SELHF_bp = 1                ; External Source Select bit position
.equ CLKCTRL_FRQRANGE_gm = 0x0C          ; Frequency Range group mask
.equ CLKCTRL_FRQRANGE_gp = 2             ; Frequency Range group position
.equ CLKCTRL_FRQRANGE_0_bm = (1<<2)      ; Frequency Range bit 0 mask
.equ CLKCTRL_FRQRANGE_0_bp = 2           ; Frequency Range bit 0 position
.equ CLKCTRL_FRQRANGE_1_bm = (1<<3)      ; Frequency Range bit 1 mask
.equ CLKCTRL_FRQRANGE_1_bp = 3           ; Frequency Range bit 1 position
.equ CLKCTRL_CSUTHF_gm = 0x30            ; Start-up Time Select group mask
.equ CLKCTRL_CSUTHF_gp = 4               ; Start-up Time Select group position
.equ CLKCTRL_CSUTHF_0_bm = (1<<4)        ; Start-up Time Select bit 0 mask
.equ CLKCTRL_CSUTHF_0_bp = 4             ; Start-up Time Select bit 0 position
.equ CLKCTRL_CSUTHF_1_bm = (1<<5)        ; Start-up Time Select bit 1 mask
.equ CLKCTRL_CSUTHF_1_bp = 5             ; Start-up Time Select bit 1 position
.equ CLKCTRL_RUNSTBY_bm = 0x80           ; Run Standby bit mask
.equ CLKCTRL_RUNSTBY_bp = 7              ; Run Standby bit position

; CLKCTRL_USBPLLSTATUS masks
.equ CLKCTRL_PLLS_bm = 0x01              ; PLL Stable bit mask
.equ CLKCTRL_PLLS_bp = 0                 ; PLL Stable bit position

; Clock select
.equ CLKCTRL_CLKSEL_OSCHF_gc = (0x00<<0) ; Internal high-frequency oscillator
.equ CLKCTRL_CLKSEL_OSC32K_gc = (0x01<<0) ; Internal 32.768 kHz oscillator
.equ CLKCTRL_CLKSEL_XOSC32K_gc = (0x02<<0) ; 32.768 kHz crystal oscillator
.equ CLKCTRL_CLKSEL_EXTCLK_gc = (0x03<<0) ; External clock

; Prescaler division select
.equ CLKCTRL_PDIV_DIV2_gc = (0x00<<1)    ; Divide by 2
.equ CLKCTRL_PDIV_DIV4_gc = (0x01<<1)    ; Divide by 4
.equ CLKCTRL_PDIV_DIV8_gc = (0x02<<1)    ; Divide by 8
.equ CLKCTRL_PDIV_DIV16_gc = (0x03<<1)   ; Divide by 16
.equ CLKCTRL_PDIV_DIV32_gc = (0x04<<1)   ; Divide by 32
.equ CLKCTRL_PDIV_DIV64_gc = (0x05<<1)   ; Divide by 64
.equ CLKCTRL_PDIV_DIV6_gc = (0x08<<1)    ; Divide by 6
.equ CLKCTRL_PDIV_DIV10_gc = (0x09<<1)   ; Divide by 10
.equ CLKCTRL_PDIV_DIV12_gc = (0x0A<<1)   ; Divide by 12
.equ CLKCTRL_PDIV_DIV24_gc = (0x0B<<1)   ; Divide by 24
.equ CLKCTRL_PDIV_DIV48_gc = (0x0C<<1)   ; Divide by 48

; Clock Failure Detect Source select
.equ CLKCTRL_CFDSRC_CLKMAIN_gc = (0x00<<2) ; Main Clock
.equ CLKCTRL_CFDSRC_XOSCHF_gc = (0x01<<2) ; XOSCHF
.equ CLKCTRL_CFDSRC_XOSC32K_gc = (0x02<<2) ; XOSC32K

; Interrupt type select
.equ CLKCTRL_INTTYPE_INT_gc = (0x00<<7)  ; Regular Interrupt
.equ CLKCTRL_INTTYPE_NMI_gc = (0x01<<7)  ; NMI

; Algorithm Selection
.equ CLKCTRL_ALGSEL_BIN_gc = (0x00<<6)   ; Binary Search
.equ CLKCTRL_ALGSEL_INCR_gc = (0x01<<6)  ; Incremental Search

; Autotune select
.equ CLKCTRL_AUTOTUNE_OFF_gc = (0x00<<0) ; Automatic tuning disabled
.equ CLKCTRL_AUTOTUNE_32K_gc = (0x01<<0) ; Automatic tuning against XOSC32K enabled
.equ CLKCTRL_AUTOTUNE_SOF_gc = (0x02<<0) ; Automatic tuning against USB SOF enabled

; Frequency select
.equ CLKCTRL_FRQSEL_1M_gc = (0x00<<2)    ; 1 MHz system clock
.equ CLKCTRL_FRQSEL_2M_gc = (0x01<<2)    ; 2 MHz system clock
.equ CLKCTRL_FRQSEL_3M_gc = (0x02<<2)    ; 3 MHz system clock
.equ CLKCTRL_FRQSEL_4M_gc = (0x03<<2)    ; 4 MHz system clock (default)
.equ CLKCTRL_FRQSEL_8M_gc = (0x05<<2)    ; 8 MHz system clock
.equ CLKCTRL_FRQSEL_12M_gc = (0x06<<2)   ; 12 MHz system clock
.equ CLKCTRL_FRQSEL_16M_gc = (0x07<<2)   ; 16 MHz system clock
.equ CLKCTRL_FRQSEL_20M_gc = (0x08<<2)   ; 20 MHz system clock
.equ CLKCTRL_FRQSEL_24M_gc = (0x09<<2)   ; 24 MHz system clock
.equ CLKCTRL_FRQSEL_28M_gc = (0x0A<<2)   ; 28 MHz system clock
.equ CLKCTRL_FRQSEL_32M_gc = (0x0B<<2)   ; 32 MHz system clock

; Start-up Time Select
.equ CLKCTRL_CSUTHF_256_gc = (0x00<<4)   ; 256 XOSCHF cycles
.equ CLKCTRL_CSUTHF_1K_gc = (0x01<<4)    ; 1K XOSCHF cycles
.equ CLKCTRL_CSUTHF_4K_gc = (0x02<<4)    ; 4K XOSCHF cycles

; Frequency Range select
.equ CLKCTRL_FRQRANGE_8M_gc = (0x00<<2)  ; Max 8 MHz XTAL Frequency
.equ CLKCTRL_FRQRANGE_16M_gc = (0x01<<2) ; Max 16 MHz XTAL Frequency
.equ CLKCTRL_FRQRANGE_24M_gc = (0x02<<2) ; Max 24 MHz XTAL Frequency
.equ CLKCTRL_FRQRANGE_32M_gc = (0x03<<2) ; Max 32 MHz XTAL Frequency

; External Source Select
.equ CLKCTRL_SELHF_XTAL_gc = (0x00<<1)   ; External Crystal
.equ CLKCTRL_SELHF_EXTCLK_gc = (0x01<<1) ; External clock on XTALHF1 pin

; Crystal startup time select
.equ CLKCTRL_CSUT_1K_gc = (0x00<<4)      ; 1k cycles
.equ CLKCTRL_CSUT_16K_gc = (0x01<<4)     ; 16k cycles
.equ CLKCTRL_CSUT_32K_gc = (0x02<<4)     ; 32k cycles
.equ CLKCTRL_CSUT_64K_gc = (0x03<<4)     ; 64k cycles

; Select
.equ CLKCTRL_SEL_XTAL_gc = (0x00<<2)     ; External crystal connected to the XTAL32K1 and XTAL32K2 pins
.equ CLKCTRL_SEL_EXTCLK_gc = (0x01<<2)   ; External clock on the XTAL32K1 pin


;*************************************************************************
;** CPU - CPU
;*************************************************************************

; CPU_CCP masks
.equ CPU_CCP_gm = 0xFF                   ; CCP signature group mask
.equ CPU_CCP_gp = 0                      ; CCP signature group position
.equ CPU_CCP_0_bm = (1<<0)               ; CCP signature bit 0 mask
.equ CPU_CCP_0_bp = 0                    ; CCP signature bit 0 position
.equ CPU_CCP_1_bm = (1<<1)               ; CCP signature bit 1 mask
.equ CPU_CCP_1_bp = 1                    ; CCP signature bit 1 position
.equ CPU_CCP_2_bm = (1<<2)               ; CCP signature bit 2 mask
.equ CPU_CCP_2_bp = 2                    ; CCP signature bit 2 position
.equ CPU_CCP_3_bm = (1<<3)               ; CCP signature bit 3 mask
.equ CPU_CCP_3_bp = 3                    ; CCP signature bit 3 position
.equ CPU_CCP_4_bm = (1<<4)               ; CCP signature bit 4 mask
.equ CPU_CCP_4_bp = 4                    ; CCP signature bit 4 position
.equ CPU_CCP_5_bm = (1<<5)               ; CCP signature bit 5 mask
.equ CPU_CCP_5_bp = 5                    ; CCP signature bit 5 position
.equ CPU_CCP_6_bm = (1<<6)               ; CCP signature bit 6 mask
.equ CPU_CCP_6_bp = 6                    ; CCP signature bit 6 position
.equ CPU_CCP_7_bm = (1<<7)               ; CCP signature bit 7 mask
.equ CPU_CCP_7_bp = 7                    ; CCP signature bit 7 position

; CPU_SREG masks
.equ CPU_C_bm = 0x01                     ; Carry Flag bit mask
.equ CPU_C_bp = 0                        ; Carry Flag bit position
.equ CPU_Z_bm = 0x02                     ; Zero Flag bit mask
.equ CPU_Z_bp = 1                        ; Zero Flag bit position
.equ CPU_N_bm = 0x04                     ; Negative Flag bit mask
.equ CPU_N_bp = 2                        ; Negative Flag bit position
.equ CPU_V_bm = 0x08                     ; Two's Complement Overflow Flag bit mask
.equ CPU_V_bp = 3                        ; Two's Complement Overflow Flag bit position
.equ CPU_S_bm = 0x10                     ; N Exclusive Or V Flag bit mask
.equ CPU_S_bp = 4                        ; N Exclusive Or V Flag bit position
.equ CPU_H_bm = 0x20                     ; Half Carry Flag bit mask
.equ CPU_H_bp = 5                        ; Half Carry Flag bit position
.equ CPU_T_bm = 0x40                     ; Transfer Bit bit mask
.equ CPU_T_bp = 6                        ; Transfer Bit bit position
.equ CPU_I_bm = 0x80                     ; Global Interrupt Enable Flag bit mask
.equ CPU_I_bp = 7                        ; Global Interrupt Enable Flag bit position

; CCP signature select
.equ CPU_CCP_SPM_gc = (0x9D<<0)          ; SPM Instruction Protection
.equ CPU_CCP_IOREG_gc = (0xD8<<0)        ; IO Register Protection


;*************************************************************************
;** CPUINT - Interrupt Controller
;*************************************************************************

; CPUINT_CTRLA masks
.equ CPUINT_LVL0RR_bm = 0x01             ; Round-robin Scheduling Enable bit mask
.equ CPUINT_LVL0RR_bp = 0                ; Round-robin Scheduling Enable bit position
.equ CPUINT_CVT_bm = 0x20                ; Compact Vector Table bit mask
.equ CPUINT_CVT_bp = 5                   ; Compact Vector Table bit position
.equ CPUINT_IVSEL_bm = 0x40              ; Interrupt Vector Select bit mask
.equ CPUINT_IVSEL_bp = 6                 ; Interrupt Vector Select bit position

; CPUINT_STATUS masks
.equ CPUINT_LVL0EX_bm = 0x01             ; Level 0 Interrupt Executing bit mask
.equ CPUINT_LVL0EX_bp = 0                ; Level 0 Interrupt Executing bit position
.equ CPUINT_LVL1EX_bm = 0x02             ; Level 1 Interrupt Executing bit mask
.equ CPUINT_LVL1EX_bp = 1                ; Level 1 Interrupt Executing bit position
.equ CPUINT_NMIEX_bm = 0x80              ; Non-maskable Interrupt Executing bit mask
.equ CPUINT_NMIEX_bp = 7                 ; Non-maskable Interrupt Executing bit position

; CPUINT_LVL0PRI masks
.equ CPUINT_LVL0PRI_gm = 0xFF            ; Interrupt Level Priority group mask
.equ CPUINT_LVL0PRI_gp = 0               ; Interrupt Level Priority group position
.equ CPUINT_LVL0PRI_0_bm = (1<<0)        ; Interrupt Level Priority bit 0 mask
.equ CPUINT_LVL0PRI_0_bp = 0             ; Interrupt Level Priority bit 0 position
.equ CPUINT_LVL0PRI_1_bm = (1<<1)        ; Interrupt Level Priority bit 1 mask
.equ CPUINT_LVL0PRI_1_bp = 1             ; Interrupt Level Priority bit 1 position
.equ CPUINT_LVL0PRI_2_bm = (1<<2)        ; Interrupt Level Priority bit 2 mask
.equ CPUINT_LVL0PRI_2_bp = 2             ; Interrupt Level Priority bit 2 position
.equ CPUINT_LVL0PRI_3_bm = (1<<3)        ; Interrupt Level Priority bit 3 mask
.equ CPUINT_LVL0PRI_3_bp = 3             ; Interrupt Level Priority bit 3 position
.equ CPUINT_LVL0PRI_4_bm = (1<<4)        ; Interrupt Level Priority bit 4 mask
.equ CPUINT_LVL0PRI_4_bp = 4             ; Interrupt Level Priority bit 4 position
.equ CPUINT_LVL0PRI_5_bm = (1<<5)        ; Interrupt Level Priority bit 5 mask
.equ CPUINT_LVL0PRI_5_bp = 5             ; Interrupt Level Priority bit 5 position
.equ CPUINT_LVL0PRI_6_bm = (1<<6)        ; Interrupt Level Priority bit 6 mask
.equ CPUINT_LVL0PRI_6_bp = 6             ; Interrupt Level Priority bit 6 position
.equ CPUINT_LVL0PRI_7_bm = (1<<7)        ; Interrupt Level Priority bit 7 mask
.equ CPUINT_LVL0PRI_7_bp = 7             ; Interrupt Level Priority bit 7 position

; CPUINT_LVL1VEC masks
.equ CPUINT_LVL1VEC_gm = 0xFF            ; Interrupt Vector with High Priority group mask
.equ CPUINT_LVL1VEC_gp = 0               ; Interrupt Vector with High Priority group position
.equ CPUINT_LVL1VEC_0_bm = (1<<0)        ; Interrupt Vector with High Priority bit 0 mask
.equ CPUINT_LVL1VEC_0_bp = 0             ; Interrupt Vector with High Priority bit 0 position
.equ CPUINT_LVL1VEC_1_bm = (1<<1)        ; Interrupt Vector with High Priority bit 1 mask
.equ CPUINT_LVL1VEC_1_bp = 1             ; Interrupt Vector with High Priority bit 1 position
.equ CPUINT_LVL1VEC_2_bm = (1<<2)        ; Interrupt Vector with High Priority bit 2 mask
.equ CPUINT_LVL1VEC_2_bp = 2             ; Interrupt Vector with High Priority bit 2 position
.equ CPUINT_LVL1VEC_3_bm = (1<<3)        ; Interrupt Vector with High Priority bit 3 mask
.equ CPUINT_LVL1VEC_3_bp = 3             ; Interrupt Vector with High Priority bit 3 position
.equ CPUINT_LVL1VEC_4_bm = (1<<4)        ; Interrupt Vector with High Priority bit 4 mask
.equ CPUINT_LVL1VEC_4_bp = 4             ; Interrupt Vector with High Priority bit 4 position
.equ CPUINT_LVL1VEC_5_bm = (1<<5)        ; Interrupt Vector with High Priority bit 5 mask
.equ CPUINT_LVL1VEC_5_bp = 5             ; Interrupt Vector with High Priority bit 5 position
.equ CPUINT_LVL1VEC_6_bm = (1<<6)        ; Interrupt Vector with High Priority bit 6 mask
.equ CPUINT_LVL1VEC_6_bp = 6             ; Interrupt Vector with High Priority bit 6 position
.equ CPUINT_LVL1VEC_7_bm = (1<<7)        ; Interrupt Vector with High Priority bit 7 mask
.equ CPUINT_LVL1VEC_7_bp = 7             ; Interrupt Vector with High Priority bit 7 position


;*************************************************************************
;** CRCSCAN - CRCSCAN
;*************************************************************************

; CRCSCAN_CTRLA masks
.equ CRCSCAN_ENABLE_bm = 0x01            ; Enable CRC scan bit mask
.equ CRCSCAN_ENABLE_bp = 0               ; Enable CRC scan bit position
.equ CRCSCAN_NMIEN_bm = 0x02             ; Enable NMI Trigger bit mask
.equ CRCSCAN_NMIEN_bp = 1                ; Enable NMI Trigger bit position
.equ CRCSCAN_RESET_bm = 0x80             ; Reset CRC scan bit mask
.equ CRCSCAN_RESET_bp = 7                ; Reset CRC scan bit position

; CRCSCAN_CTRLB masks
.equ CRCSCAN_SRC_gm = 0x03               ; CRC Source group mask
.equ CRCSCAN_SRC_gp = 0                  ; CRC Source group position
.equ CRCSCAN_SRC_0_bm = (1<<0)           ; CRC Source bit 0 mask
.equ CRCSCAN_SRC_0_bp = 0                ; CRC Source bit 0 position
.equ CRCSCAN_SRC_1_bm = (1<<1)           ; CRC Source bit 1 mask
.equ CRCSCAN_SRC_1_bp = 1                ; CRC Source bit 1 position

; CRCSCAN_STATUS masks
.equ CRCSCAN_BUSY_bm = 0x01              ; CRC Busy bit mask
.equ CRCSCAN_BUSY_bp = 0                 ; CRC Busy bit position
.equ CRCSCAN_OK_bm = 0x02                ; CRC Ok bit mask
.equ CRCSCAN_OK_bp = 1                   ; CRC Ok bit position

; CRC Source select
.equ CRCSCAN_SRC_FLASH_gc = (0x00<<0)    ; CRC on entire flash
.equ CRCSCAN_SRC_APPLICATION_gc = (0x01<<0) ; CRC on boot and appl section of flash
.equ CRCSCAN_SRC_BOOT_gc = (0x02<<0)     ; CRC on boot section of flash


;*************************************************************************
;** EVSYS - Event System
;*************************************************************************

; EVSYS_SWEVENTA masks
.equ EVSYS_SWEVENTA_gm = 0xFF            ; Software event on channel select group mask
.equ EVSYS_SWEVENTA_gp = 0               ; Software event on channel select group position
.equ EVSYS_SWEVENTA_0_bm = (1<<0)        ; Software event on channel select bit 0 mask
.equ EVSYS_SWEVENTA_0_bp = 0             ; Software event on channel select bit 0 position
.equ EVSYS_SWEVENTA_1_bm = (1<<1)        ; Software event on channel select bit 1 mask
.equ EVSYS_SWEVENTA_1_bp = 1             ; Software event on channel select bit 1 position
.equ EVSYS_SWEVENTA_2_bm = (1<<2)        ; Software event on channel select bit 2 mask
.equ EVSYS_SWEVENTA_2_bp = 2             ; Software event on channel select bit 2 position
.equ EVSYS_SWEVENTA_3_bm = (1<<3)        ; Software event on channel select bit 3 mask
.equ EVSYS_SWEVENTA_3_bp = 3             ; Software event on channel select bit 3 position
.equ EVSYS_SWEVENTA_4_bm = (1<<4)        ; Software event on channel select bit 4 mask
.equ EVSYS_SWEVENTA_4_bp = 4             ; Software event on channel select bit 4 position
.equ EVSYS_SWEVENTA_5_bm = (1<<5)        ; Software event on channel select bit 5 mask
.equ EVSYS_SWEVENTA_5_bp = 5             ; Software event on channel select bit 5 position
.equ EVSYS_SWEVENTA_6_bm = (1<<6)        ; Software event on channel select bit 6 mask
.equ EVSYS_SWEVENTA_6_bp = 6             ; Software event on channel select bit 6 position
.equ EVSYS_SWEVENTA_7_bm = (1<<7)        ; Software event on channel select bit 7 mask
.equ EVSYS_SWEVENTA_7_bp = 7             ; Software event on channel select bit 7 position

; EVSYS_CHANNEL0 masks
.equ EVSYS_CHANNEL_gm = 0xFF             ; Channel generator select group mask
.equ EVSYS_CHANNEL_gp = 0                ; Channel generator select group position
.equ EVSYS_CHANNEL_0_bm = (1<<0)         ; Channel generator select bit 0 mask
.equ EVSYS_CHANNEL_0_bp = 0              ; Channel generator select bit 0 position
.equ EVSYS_CHANNEL_1_bm = (1<<1)         ; Channel generator select bit 1 mask
.equ EVSYS_CHANNEL_1_bp = 1              ; Channel generator select bit 1 position
.equ EVSYS_CHANNEL_2_bm = (1<<2)         ; Channel generator select bit 2 mask
.equ EVSYS_CHANNEL_2_bp = 2              ; Channel generator select bit 2 position
.equ EVSYS_CHANNEL_3_bm = (1<<3)         ; Channel generator select bit 3 mask
.equ EVSYS_CHANNEL_3_bp = 3              ; Channel generator select bit 3 position
.equ EVSYS_CHANNEL_4_bm = (1<<4)         ; Channel generator select bit 4 mask
.equ EVSYS_CHANNEL_4_bp = 4              ; Channel generator select bit 4 position
.equ EVSYS_CHANNEL_5_bm = (1<<5)         ; Channel generator select bit 5 mask
.equ EVSYS_CHANNEL_5_bp = 5              ; Channel generator select bit 5 position
.equ EVSYS_CHANNEL_6_bm = (1<<6)         ; Channel generator select bit 6 mask
.equ EVSYS_CHANNEL_6_bp = 6              ; Channel generator select bit 6 position
.equ EVSYS_CHANNEL_7_bm = (1<<7)         ; Channel generator select bit 7 mask
.equ EVSYS_CHANNEL_7_bp = 7              ; Channel generator select bit 7 position

; EVSYS_CHANNEL1 masks
; Masks for EVSYS_CHANNEL already defined

; EVSYS_CHANNEL2 masks
; Masks for EVSYS_CHANNEL already defined

; EVSYS_CHANNEL3 masks
; Masks for EVSYS_CHANNEL already defined

; EVSYS_CHANNEL4 masks
; Masks for EVSYS_CHANNEL already defined

; EVSYS_CHANNEL5 masks
; Masks for EVSYS_CHANNEL already defined

; EVSYS_USERCCLLUT0A masks
.equ EVSYS_USER_gm = 0xFF                ; User channel select group mask
.equ EVSYS_USER_gp = 0                   ; User channel select group position
.equ EVSYS_USER_0_bm = (1<<0)            ; User channel select bit 0 mask
.equ EVSYS_USER_0_bp = 0                 ; User channel select bit 0 position
.equ EVSYS_USER_1_bm = (1<<1)            ; User channel select bit 1 mask
.equ EVSYS_USER_1_bp = 1                 ; User channel select bit 1 position
.equ EVSYS_USER_2_bm = (1<<2)            ; User channel select bit 2 mask
.equ EVSYS_USER_2_bp = 2                 ; User channel select bit 2 position
.equ EVSYS_USER_3_bm = (1<<3)            ; User channel select bit 3 mask
.equ EVSYS_USER_3_bp = 3                 ; User channel select bit 3 position
.equ EVSYS_USER_4_bm = (1<<4)            ; User channel select bit 4 mask
.equ EVSYS_USER_4_bp = 4                 ; User channel select bit 4 position
.equ EVSYS_USER_5_bm = (1<<5)            ; User channel select bit 5 mask
.equ EVSYS_USER_5_bp = 5                 ; User channel select bit 5 position
.equ EVSYS_USER_6_bm = (1<<6)            ; User channel select bit 6 mask
.equ EVSYS_USER_6_bp = 6                 ; User channel select bit 6 position
.equ EVSYS_USER_7_bm = (1<<7)            ; User channel select bit 7 mask
.equ EVSYS_USER_7_bp = 7                 ; User channel select bit 7 position

; EVSYS_USERCCLLUT0B masks
; Masks for EVSYS_USER already defined

; EVSYS_USERCCLLUT1A masks
; Masks for EVSYS_USER already defined

; EVSYS_USERCCLLUT1B masks
; Masks for EVSYS_USER already defined

; EVSYS_USERCCLLUT2A masks
; Masks for EVSYS_USER already defined

; EVSYS_USERCCLLUT2B masks
; Masks for EVSYS_USER already defined

; EVSYS_USERCCLLUT3A masks
; Masks for EVSYS_USER already defined

; EVSYS_USERCCLLUT3B masks
; Masks for EVSYS_USER already defined

; EVSYS_USERADC0START masks
; Masks for EVSYS_USER already defined

; EVSYS_USEREVSYSEVOUTA masks
; Masks for EVSYS_USER already defined

; EVSYS_USEREVSYSEVOUTD masks
; Masks for EVSYS_USER already defined

; EVSYS_USEREVSYSEVOUTF masks
; Masks for EVSYS_USER already defined

; EVSYS_USERUSART0IRDA masks
; Masks for EVSYS_USER already defined

; EVSYS_USERUSART1IRDA masks
; Masks for EVSYS_USER already defined

; EVSYS_USERTCA0CNTA masks
; Masks for EVSYS_USER already defined

; EVSYS_USERTCA0CNTB masks
; Masks for EVSYS_USER already defined

; EVSYS_USERTCB0CAPT masks
; Masks for EVSYS_USER already defined

; EVSYS_USERTCB0COUNT masks
; Masks for EVSYS_USER already defined

; EVSYS_USERTCB1CAPT masks
; Masks for EVSYS_USER already defined

; EVSYS_USERTCB1COUNT masks
; Masks for EVSYS_USER already defined

; Channel generator select
.equ EVSYS_CHANNEL_OFF_gc = (0x00<<0)    ; Off
.equ EVSYS_CHANNEL_UPDI_SYNCH_gc = (0x01<<0) ; UPDI SYNCH Character
.equ EVSYS_CHANNEL_RTC_OVF_gc = (0x06<<0) ; Real Time Counter Overflow
.equ EVSYS_CHANNEL_RTC_CMP_gc = (0x07<<0) ; Real Time Counter Compare
.equ EVSYS_CHANNEL_RTC_EVGEN0_gc = (0x08<<0) ; Real Time Counter Event Output 0
.equ EVSYS_CHANNEL_RTC_EVGEN1_gc = (0x09<<0) ; Real Time Counter Event Output 1
.equ EVSYS_CHANNEL_CCL_LUT0_gc = (0x10<<0) ; Configurable Custom Logic LUT0
.equ EVSYS_CHANNEL_CCL_LUT1_gc = (0x11<<0) ; Configurable Custom Logic LUT1
.equ EVSYS_CHANNEL_CCL_LUT2_gc = (0x12<<0) ; Configurable Custom Logic LUT2
.equ EVSYS_CHANNEL_CCL_LUT3_gc = (0x13<<0) ; Configurable Custom Logic LUT3
.equ EVSYS_CHANNEL_AC0_OUT_gc = (0x20<<0) ; Analog Comparator 0 Out
.equ EVSYS_CHANNEL_ADC0_RESRDY_gc = (0x24<<0) ; ADC0 Result Ready
.equ EVSYS_CHANNEL_ADC0_SAMPRDY_gc = (0x25<<0) ; ADC0 Sample Ready
.equ EVSYS_CHANNEL_ADC0_WCMP_gc = (0x26<<0) ; ADC0 Window Comparator
.equ EVSYS_CHANNEL_PORTA_EVGEN0_gc = (0x40<<0) ; Port A Event 0
.equ EVSYS_CHANNEL_PORTA_EVGEN1_gc = (0x41<<0) ; Port A Event 1
.equ EVSYS_CHANNEL_PORTC_EVGEN0_gc = (0x44<<0) ; Port C Event 0
.equ EVSYS_CHANNEL_PORTC_EVGEN1_gc = (0x45<<0) ; Port C Event 1
.equ EVSYS_CHANNEL_PORTD_EVGEN0_gc = (0x46<<0) ; Port D Event 0
.equ EVSYS_CHANNEL_PORTD_EVGEN1_gc = (0x47<<0) ; Port D Event 1
.equ EVSYS_CHANNEL_PORTF_EVGEN0_gc = (0x4A<<0) ; Port F Event 0
.equ EVSYS_CHANNEL_PORTF_EVGEN1_gc = (0x4B<<0) ; Port F Event 1
.equ EVSYS_CHANNEL_USART0_XCK_gc = (0x60<<0) ; USART 0 XCK
.equ EVSYS_CHANNEL_USART1_XCK_gc = (0x61<<0) ; USART 1 XCK
.equ EVSYS_CHANNEL_SPI0_SCK_gc = (0x68<<0) ; SPI 0 SCK
.equ EVSYS_CHANNEL_TCA0_OVF_LUNF_gc = (0x80<<0) ; Timer/Counter A0 Overflow / Low Byte Timer Underflow
.equ EVSYS_CHANNEL_TCA0_HUNF_gc = (0x81<<0) ; Timer/Counter A0 High Byte Timer Underflow
.equ EVSYS_CHANNEL_TCA0_CMP0_LCMP0_gc = (0x84<<0) ; Timer/Counter A0 Compare 0 / Low Byte Compare 0
.equ EVSYS_CHANNEL_TCA0_CMP1_LCMP1_gc = (0x85<<0) ; Timer/Counter A0 Compare 1 / Low Byte Compare 1
.equ EVSYS_CHANNEL_TCA0_CMP2_LCMP2_gc = (0x86<<0) ; Timer/Counter A0 Compare 2 / Low Byte Compare 2
.equ EVSYS_CHANNEL_TCB0_CAPT_gc = (0xA0<<0) ; Timer/Counter B0 Capture
.equ EVSYS_CHANNEL_TCB0_OVF_gc = (0xA1<<0) ; Timer/Counter B0 Overflow
.equ EVSYS_CHANNEL_TCB1_CAPT_gc = (0xA2<<0) ; Timer/Counter B1 Capture
.equ EVSYS_CHANNEL_TCB1_OVF_gc = (0xA3<<0) ; Timer/Counter B1 Overflow
.equ EVSYS_CHANNEL_USB0_SETUP_gc = (0xC0<<0) ; USB0 Setup Received
.equ EVSYS_CHANNEL_USB0_SOF_gc = (0xC1<<0) ; USB0 SOF Received
.equ EVSYS_CHANNEL_USB0_CRC_gc = (0xC2<<0) ; USB0 CRC Error
.equ EVSYS_CHANNEL_USB0_UNFOVF_gc = (0xC3<<0) ; USB0 Underflow / Overflow
.equ EVSYS_CHANNEL_USB0_RX_gc = (0xC4<<0) ; USB0 Data Byte Received
.equ EVSYS_CHANNEL_USB0_TX_gc = (0xC5<<0) ; USB0 Data Byte Transmitted

; Software event on channel select
.equ EVSYS_SWEVENTA_CH0_gc = (0x01<<0)   ; Software event on channel 0
.equ EVSYS_SWEVENTA_CH1_gc = (0x02<<0)   ; Software event on channel 1
.equ EVSYS_SWEVENTA_CH2_gc = (0x04<<0)   ; Software event on channel 2
.equ EVSYS_SWEVENTA_CH3_gc = (0x08<<0)   ; Software event on channel 3
.equ EVSYS_SWEVENTA_CH4_gc = (0x10<<0)   ; Software event on channel 4
.equ EVSYS_SWEVENTA_CH5_gc = (0x20<<0)   ; Software event on channel 5
.equ EVSYS_SWEVENTA_CH6_gc = (0x40<<0)   ; Software event on channel 6
.equ EVSYS_SWEVENTA_CH7_gc = (0x80<<0)   ; Software event on channel 7

; User channel select
.equ EVSYS_USER_OFF_gc = (0x00<<0)       ; Off
.equ EVSYS_USER_CHANNEL0_gc = (0x01<<0)  ; Connect user to event channel 0
.equ EVSYS_USER_CHANNEL1_gc = (0x02<<0)  ; Connect user to event channel 1
.equ EVSYS_USER_CHANNEL2_gc = (0x03<<0)  ; Connect user to event channel 2
.equ EVSYS_USER_CHANNEL3_gc = (0x04<<0)  ; Connect user to event channel 3
.equ EVSYS_USER_CHANNEL4_gc = (0x05<<0)  ; Connect user to event channel 4
.equ EVSYS_USER_CHANNEL5_gc = (0x06<<0)  ; Connect user to event channel 5


;*************************************************************************
;** FUSE - Fuses
;*************************************************************************

; FUSE_WDTCFG masks
.equ FUSE_PERIOD_gm = 0x0F               ; Watchdog Timeout Period group mask
.equ FUSE_PERIOD_gp = 0                  ; Watchdog Timeout Period group position
.equ FUSE_PERIOD_0_bm = (1<<0)           ; Watchdog Timeout Period bit 0 mask
.equ FUSE_PERIOD_0_bp = 0                ; Watchdog Timeout Period bit 0 position
.equ FUSE_PERIOD_1_bm = (1<<1)           ; Watchdog Timeout Period bit 1 mask
.equ FUSE_PERIOD_1_bp = 1                ; Watchdog Timeout Period bit 1 position
.equ FUSE_PERIOD_2_bm = (1<<2)           ; Watchdog Timeout Period bit 2 mask
.equ FUSE_PERIOD_2_bp = 2                ; Watchdog Timeout Period bit 2 position
.equ FUSE_PERIOD_3_bm = (1<<3)           ; Watchdog Timeout Period bit 3 mask
.equ FUSE_PERIOD_3_bp = 3                ; Watchdog Timeout Period bit 3 position
.equ FUSE_WINDOW_gm = 0xF0               ; Watchdog Window Timeout Period group mask
.equ FUSE_WINDOW_gp = 4                  ; Watchdog Window Timeout Period group position
.equ FUSE_WINDOW_0_bm = (1<<4)           ; Watchdog Window Timeout Period bit 0 mask
.equ FUSE_WINDOW_0_bp = 4                ; Watchdog Window Timeout Period bit 0 position
.equ FUSE_WINDOW_1_bm = (1<<5)           ; Watchdog Window Timeout Period bit 1 mask
.equ FUSE_WINDOW_1_bp = 5                ; Watchdog Window Timeout Period bit 1 position
.equ FUSE_WINDOW_2_bm = (1<<6)           ; Watchdog Window Timeout Period bit 2 mask
.equ FUSE_WINDOW_2_bp = 6                ; Watchdog Window Timeout Period bit 2 position
.equ FUSE_WINDOW_3_bm = (1<<7)           ; Watchdog Window Timeout Period bit 3 mask
.equ FUSE_WINDOW_3_bp = 7                ; Watchdog Window Timeout Period bit 3 position

; FUSE_BODCFG masks
.equ FUSE_SLEEP_gm = 0x03                ; BOD Operation in Sleep Mode group mask
.equ FUSE_SLEEP_gp = 0                   ; BOD Operation in Sleep Mode group position
.equ FUSE_SLEEP_0_bm = (1<<0)            ; BOD Operation in Sleep Mode bit 0 mask
.equ FUSE_SLEEP_0_bp = 0                 ; BOD Operation in Sleep Mode bit 0 position
.equ FUSE_SLEEP_1_bm = (1<<1)            ; BOD Operation in Sleep Mode bit 1 mask
.equ FUSE_SLEEP_1_bp = 1                 ; BOD Operation in Sleep Mode bit 1 position
.equ FUSE_ACTIVE_gm = 0x0C               ; BOD Operation in Active Mode group mask
.equ FUSE_ACTIVE_gp = 2                  ; BOD Operation in Active Mode group position
.equ FUSE_ACTIVE_0_bm = (1<<2)           ; BOD Operation in Active Mode bit 0 mask
.equ FUSE_ACTIVE_0_bp = 2                ; BOD Operation in Active Mode bit 0 position
.equ FUSE_ACTIVE_1_bm = (1<<3)           ; BOD Operation in Active Mode bit 1 mask
.equ FUSE_ACTIVE_1_bp = 3                ; BOD Operation in Active Mode bit 1 position
.equ FUSE_SAMPFREQ_bm = 0x10             ; BOD Sample Frequency bit mask
.equ FUSE_SAMPFREQ_bp = 4                ; BOD Sample Frequency bit position
.equ FUSE_LVL_gm = 0xE0                  ; BOD Level group mask
.equ FUSE_LVL_gp = 5                     ; BOD Level group position
.equ FUSE_LVL_0_bm = (1<<5)              ; BOD Level bit 0 mask
.equ FUSE_LVL_0_bp = 5                   ; BOD Level bit 0 position
.equ FUSE_LVL_1_bm = (1<<6)              ; BOD Level bit 1 mask
.equ FUSE_LVL_1_bp = 6                   ; BOD Level bit 1 position
.equ FUSE_LVL_2_bm = (1<<7)              ; BOD Level bit 2 mask
.equ FUSE_LVL_2_bp = 7                   ; BOD Level bit 2 position

; FUSE_OSCCFG masks
.equ FUSE_CLKSEL_gm = 0x07               ; Frequency Select group mask
.equ FUSE_CLKSEL_gp = 0                  ; Frequency Select group position
.equ FUSE_CLKSEL_0_bm = (1<<0)           ; Frequency Select bit 0 mask
.equ FUSE_CLKSEL_0_bp = 0                ; Frequency Select bit 0 position
.equ FUSE_CLKSEL_1_bm = (1<<1)           ; Frequency Select bit 1 mask
.equ FUSE_CLKSEL_1_bp = 1                ; Frequency Select bit 1 position
.equ FUSE_CLKSEL_2_bm = (1<<2)           ; Frequency Select bit 2 mask
.equ FUSE_CLKSEL_2_bp = 2                ; Frequency Select bit 2 position

; FUSE_SYSCFG0 masks
.equ FUSE_EESAVE_bm = 0x01               ; EEPROM Save bit mask
.equ FUSE_EESAVE_bp = 0                  ; EEPROM Save bit position
.equ FUSE_BROWSAVE_bm = 0x02             ; Boot Row Save bit mask
.equ FUSE_BROWSAVE_bp = 1                ; Boot Row Save bit position
.equ FUSE_RSTPINCFG_bm = 0x08            ; Reset Pin Configuration bit mask
.equ FUSE_RSTPINCFG_bp = 3               ; Reset Pin Configuration bit position
.equ FUSE_UPDIPINCFG_bm = 0x10           ; UPDI Pin Configuration bit mask
.equ FUSE_UPDIPINCFG_bp = 4              ; UPDI Pin Configuration bit position
.equ FUSE_CRCSEL_bm = 0x20               ; CRC Select bit mask
.equ FUSE_CRCSEL_bp = 5                  ; CRC Select bit position
.equ FUSE_CRCSRC_gm = 0xC0               ; CRC Source group mask
.equ FUSE_CRCSRC_gp = 6                  ; CRC Source group position
.equ FUSE_CRCSRC_0_bm = (1<<6)           ; CRC Source bit 0 mask
.equ FUSE_CRCSRC_0_bp = 6                ; CRC Source bit 0 position
.equ FUSE_CRCSRC_1_bm = (1<<7)           ; CRC Source bit 1 mask
.equ FUSE_CRCSRC_1_bp = 7                ; CRC Source bit 1 position

; FUSE_SYSCFG1 masks
.equ FUSE_SUT_gm = 0x07                  ; Startup Time group mask
.equ FUSE_SUT_gp = 0                     ; Startup Time group position
.equ FUSE_SUT_0_bm = (1<<0)              ; Startup Time bit 0 mask
.equ FUSE_SUT_0_bp = 0                   ; Startup Time bit 0 position
.equ FUSE_SUT_1_bm = (1<<1)              ; Startup Time bit 1 mask
.equ FUSE_SUT_1_bp = 1                   ; Startup Time bit 1 position
.equ FUSE_SUT_2_bm = (1<<2)              ; Startup Time bit 2 mask
.equ FUSE_SUT_2_bp = 2                   ; Startup Time bit 2 position
.equ FUSE_USBSINK_bm = 0x08              ; USB Voltage Regulator Current Sink Enable bit mask
.equ FUSE_USBSINK_bp = 3                 ; USB Voltage Regulator Current Sink Enable bit position

; FUSE_PDICFG masks
.equ FUSE_LEVEL_gm = 0x03                ; Protection Level group mask
.equ FUSE_LEVEL_gp = 0                   ; Protection Level group position
.equ FUSE_LEVEL_0_bm = (1<<0)            ; Protection Level bit 0 mask
.equ FUSE_LEVEL_0_bp = 0                 ; Protection Level bit 0 position
.equ FUSE_LEVEL_1_bm = (1<<1)            ; Protection Level bit 1 mask
.equ FUSE_LEVEL_1_bp = 1                 ; Protection Level bit 1 position
.equ FUSE_KEY_gm = 0xFFF0                ; NVM Protection Activation Key group mask
.equ FUSE_KEY_gp = 4                     ; NVM Protection Activation Key group position
.equ FUSE_KEY_0_bm = (1<<4)              ; NVM Protection Activation Key bit 0 mask
.equ FUSE_KEY_0_bp = 4                   ; NVM Protection Activation Key bit 0 position
.equ FUSE_KEY_1_bm = (1<<5)              ; NVM Protection Activation Key bit 1 mask
.equ FUSE_KEY_1_bp = 5                   ; NVM Protection Activation Key bit 1 position
.equ FUSE_KEY_2_bm = (1<<6)              ; NVM Protection Activation Key bit 2 mask
.equ FUSE_KEY_2_bp = 6                   ; NVM Protection Activation Key bit 2 position
.equ FUSE_KEY_3_bm = (1<<7)              ; NVM Protection Activation Key bit 3 mask
.equ FUSE_KEY_3_bp = 7                   ; NVM Protection Activation Key bit 3 position
.equ FUSE_KEY_4_bm = (1<<8)              ; NVM Protection Activation Key bit 4 mask
.equ FUSE_KEY_4_bp = 8                   ; NVM Protection Activation Key bit 4 position
.equ FUSE_KEY_5_bm = (1<<9)              ; NVM Protection Activation Key bit 5 mask
.equ FUSE_KEY_5_bp = 9                   ; NVM Protection Activation Key bit 5 position
.equ FUSE_KEY_6_bm = (1<<10)             ; NVM Protection Activation Key bit 6 mask
.equ FUSE_KEY_6_bp = 10                  ; NVM Protection Activation Key bit 6 position
.equ FUSE_KEY_7_bm = (1<<11)             ; NVM Protection Activation Key bit 7 mask
.equ FUSE_KEY_7_bp = 11                  ; NVM Protection Activation Key bit 7 position
.equ FUSE_KEY_8_bm = (1<<12)             ; NVM Protection Activation Key bit 8 mask
.equ FUSE_KEY_8_bp = 12                  ; NVM Protection Activation Key bit 8 position
.equ FUSE_KEY_9_bm = (1<<13)             ; NVM Protection Activation Key bit 9 mask
.equ FUSE_KEY_9_bp = 13                  ; NVM Protection Activation Key bit 9 position
.equ FUSE_KEY_10_bm = (1<<14)            ; NVM Protection Activation Key bit 10 mask
.equ FUSE_KEY_10_bp = 14                 ; NVM Protection Activation Key bit 10 position
.equ FUSE_KEY_11_bm = (1<<15)            ; NVM Protection Activation Key bit 11 mask
.equ FUSE_KEY_11_bp = 15                 ; NVM Protection Activation Key bit 11 position

; BOD Operation in Active Mode select
.equ FUSE_ACTIVE_DISABLE_gc = (0x00<<2)  ; BOD disabled
.equ FUSE_ACTIVE_ENABLE_gc = (0x01<<2)   ; BOD enabled in continuous mode
.equ FUSE_ACTIVE_SAMPLE_gc = (0x02<<2)   ; BOD enabled in sampled mode
.equ FUSE_ACTIVE_ENABLEWAIT_gc = (0x03<<2) ; BOD enabled in continuous mode. Execution is halted at wake-up until BOD is running.

; BOD Level select
.equ FUSE_LVL_BODLEVEL0_gc = (0x00<<5)   ; 1.9V
.equ FUSE_LVL_BODLEVEL1_gc = (0x01<<5)   ; 2.45V
.equ FUSE_LVL_BODLEVEL2_gc = (0x02<<5)   ; 2.7V
.equ FUSE_LVL_BODLEVEL3_gc = (0x03<<5)   ; 2.85V

; BOD Sample Frequency select
.equ FUSE_SAMPFREQ_128Hz_gc = (0x00<<4)  ; Sample frequency is 128 Hz
.equ FUSE_SAMPFREQ_32Hz_gc = (0x01<<4)   ; Sample frequency is 32 Hz

; BOD Operation in Sleep Mode select
.equ FUSE_SLEEP_DISABLE_gc = (0x00<<0)   ; BOD disabled
.equ FUSE_SLEEP_ENABLE_gc = (0x01<<0)    ; BOD enabled in continuous mode
.equ FUSE_SLEEP_SAMPLE_gc = (0x02<<0)    ; BOD enabled in sampled mode

; Frequency Select
.equ FUSE_CLKSEL_OSCHF_gc = (0x00<<0)    ; 1-32MHz internal oscillator
.equ FUSE_CLKSEL_OSC32K_gc = (0x01<<0)   ; 32.768kHz internal oscillator

; NVM Protection Activation Key select
.equ FUSE_KEY_NOTACT_gc = (0x00<<4)      ; Not Active
.equ FUSE_KEY_NVMACT_gc = (0xB45<<4)     ; NVM Protection Active

; Protection Level select
.equ FUSE_LEVEL_NVMACCDIS_gc = (0x01<<0) ; NVM Access through UPDI disabled
.equ FUSE_LEVEL_BASIC_gc = (0x03<<0)     ; UPDI and UPDI pins working normally

; CRC Select
.equ FUSE_CRCSEL_CRC16_gc = (0x00<<5)    ; Enable CRC16
.equ FUSE_CRCSEL_CRC32_gc = (0x01<<5)    ; Enable CRC32

; CRC Source select
.equ FUSE_CRCSRC_FLASH_gc = (0x00<<6)    ; CRC of full Flash (boot, application code and application data)
.equ FUSE_CRCSRC_BOOT_gc = (0x01<<6)     ; CRC of boot section
.equ FUSE_CRCSRC_BOOTAPP_gc = (0x02<<6)  ; CRC of application code and boot sections
.equ FUSE_CRCSRC_NOCRC_gc = (0x03<<6)    ; No CRC

; Reset Pin Configuration select
.equ FUSE_RSTPINCFG_GPIO_gc = (0x00<<3)  ; GPIO mode
.equ FUSE_RSTPINCFG_RST_gc = (0x01<<3)   ; Reset mode

; UPDI Pin Configuration select
.equ FUSE_UPDIPINCFG_GPIO_gc = (0x00<<4) ; GPIO Mode
.equ FUSE_UPDIPINCFG_UPDI_gc = (0x01<<4) ; UPDI Mode

; Startup Time select
.equ FUSE_SUT_0MS_gc = (0x00<<0)         ; 0 ms
.equ FUSE_SUT_1MS_gc = (0x01<<0)         ; 1 ms
.equ FUSE_SUT_2MS_gc = (0x02<<0)         ; 2 ms
.equ FUSE_SUT_4MS_gc = (0x03<<0)         ; 4 ms
.equ FUSE_SUT_8MS_gc = (0x04<<0)         ; 8 ms
.equ FUSE_SUT_16MS_gc = (0x05<<0)        ; 16 ms
.equ FUSE_SUT_32MS_gc = (0x06<<0)        ; 32 ms
.equ FUSE_SUT_64MS_gc = (0x07<<0)        ; 64 ms

; USB Voltage Regulator Current Sink Enable select
.equ FUSE_USBSINK_DISABLE_gc = (0x00<<3) ; USB VREG can not sink current
.equ FUSE_USBSINK_ENABLE_gc = (0x01<<3)  ; USB VREG can sink current

; Watchdog Timeout Period select
.equ FUSE_PERIOD_OFF_gc = (0x00<<0)      ; Watch-Dog timer Off
.equ FUSE_PERIOD_8CLK_gc = (0x01<<0)     ; 8 cycles (8ms)
.equ FUSE_PERIOD_16CLK_gc = (0x02<<0)    ; 16 cycles (16ms)
.equ FUSE_PERIOD_32CLK_gc = (0x03<<0)    ; 32 cycles (32ms)
.equ FUSE_PERIOD_64CLK_gc = (0x04<<0)    ; 64 cycles (64ms)
.equ FUSE_PERIOD_128CLK_gc = (0x05<<0)   ; 128 cycles (0.128s)
.equ FUSE_PERIOD_256CLK_gc = (0x06<<0)   ; 256 cycles (0.256s)
.equ FUSE_PERIOD_512CLK_gc = (0x07<<0)   ; 512 cycles (0.512s)
.equ FUSE_PERIOD_1KCLK_gc = (0x08<<0)    ; 1K cycles (1.0s)
.equ FUSE_PERIOD_2KCLK_gc = (0x09<<0)    ; 2K cycles (2.0s)
.equ FUSE_PERIOD_4KCLK_gc = (0x0A<<0)    ; 4K cycles (4.0s)
.equ FUSE_PERIOD_8KCLK_gc = (0x0B<<0)    ; 8K cycles (8.0s)

; Watchdog Window Timeout Period select
.equ FUSE_WINDOW_OFF_gc = (0x00<<4)      ; Window mode off
.equ FUSE_WINDOW_8CLK_gc = (0x01<<4)     ; 8 cycles (8ms)
.equ FUSE_WINDOW_16CLK_gc = (0x02<<4)    ; 16 cycles (16ms)
.equ FUSE_WINDOW_32CLK_gc = (0x03<<4)    ; 32 cycles (32ms)
.equ FUSE_WINDOW_64CLK_gc = (0x04<<4)    ; 64 cycles (64ms)
.equ FUSE_WINDOW_128CLK_gc = (0x05<<4)   ; 128 cycles (0.128s)
.equ FUSE_WINDOW_256CLK_gc = (0x06<<4)   ; 256 cycles (0.256s)
.equ FUSE_WINDOW_512CLK_gc = (0x07<<4)   ; 512 cycles (0.512s)
.equ FUSE_WINDOW_1KCLK_gc = (0x08<<4)    ; 1K cycles (1.0s)
.equ FUSE_WINDOW_2KCLK_gc = (0x09<<4)    ; 2K cycles (2.0s)
.equ FUSE_WINDOW_4KCLK_gc = (0x0A<<4)    ; 4K cycles (4.0s)
.equ FUSE_WINDOW_8KCLK_gc = (0x0B<<4)    ; 8K cycles (8.0s)


;*************************************************************************
;** GPR - General Purpose Registers
;*************************************************************************


;*************************************************************************
;** LOCK - Lockbits
;*************************************************************************

; LOCK_KEY masks
.equ LOCK_KEY_gm = 0xFFFFFFFF            ; Lock Key group mask
.equ LOCK_KEY_gp = 0                     ; Lock Key group position
.equ LOCK_KEY_0_bm = (1<<0)              ; Lock Key bit 0 mask
.equ LOCK_KEY_0_bp = 0                   ; Lock Key bit 0 position
.equ LOCK_KEY_1_bm = (1<<1)              ; Lock Key bit 1 mask
.equ LOCK_KEY_1_bp = 1                   ; Lock Key bit 1 position
.equ LOCK_KEY_2_bm = (1<<2)              ; Lock Key bit 2 mask
.equ LOCK_KEY_2_bp = 2                   ; Lock Key bit 2 position
.equ LOCK_KEY_3_bm = (1<<3)              ; Lock Key bit 3 mask
.equ LOCK_KEY_3_bp = 3                   ; Lock Key bit 3 position
.equ LOCK_KEY_4_bm = (1<<4)              ; Lock Key bit 4 mask
.equ LOCK_KEY_4_bp = 4                   ; Lock Key bit 4 position
.equ LOCK_KEY_5_bm = (1<<5)              ; Lock Key bit 5 mask
.equ LOCK_KEY_5_bp = 5                   ; Lock Key bit 5 position
.equ LOCK_KEY_6_bm = (1<<6)              ; Lock Key bit 6 mask
.equ LOCK_KEY_6_bp = 6                   ; Lock Key bit 6 position
.equ LOCK_KEY_7_bm = (1<<7)              ; Lock Key bit 7 mask
.equ LOCK_KEY_7_bp = 7                   ; Lock Key bit 7 position
.equ LOCK_KEY_8_bm = (1<<8)              ; Lock Key bit 8 mask
.equ LOCK_KEY_8_bp = 8                   ; Lock Key bit 8 position
.equ LOCK_KEY_9_bm = (1<<9)              ; Lock Key bit 9 mask
.equ LOCK_KEY_9_bp = 9                   ; Lock Key bit 9 position
.equ LOCK_KEY_10_bm = (1<<10)            ; Lock Key bit 10 mask
.equ LOCK_KEY_10_bp = 10                 ; Lock Key bit 10 position
.equ LOCK_KEY_11_bm = (1<<11)            ; Lock Key bit 11 mask
.equ LOCK_KEY_11_bp = 11                 ; Lock Key bit 11 position
.equ LOCK_KEY_12_bm = (1<<12)            ; Lock Key bit 12 mask
.equ LOCK_KEY_12_bp = 12                 ; Lock Key bit 12 position
.equ LOCK_KEY_13_bm = (1<<13)            ; Lock Key bit 13 mask
.equ LOCK_KEY_13_bp = 13                 ; Lock Key bit 13 position
.equ LOCK_KEY_14_bm = (1<<14)            ; Lock Key bit 14 mask
.equ LOCK_KEY_14_bp = 14                 ; Lock Key bit 14 position
.equ LOCK_KEY_15_bm = (1<<15)            ; Lock Key bit 15 mask
.equ LOCK_KEY_15_bp = 15                 ; Lock Key bit 15 position
.equ LOCK_KEY_16_bm = (1<<16)            ; Lock Key bit 16 mask
.equ LOCK_KEY_16_bp = 16                 ; Lock Key bit 16 position
.equ LOCK_KEY_17_bm = (1<<17)            ; Lock Key bit 17 mask
.equ LOCK_KEY_17_bp = 17                 ; Lock Key bit 17 position
.equ LOCK_KEY_18_bm = (1<<18)            ; Lock Key bit 18 mask
.equ LOCK_KEY_18_bp = 18                 ; Lock Key bit 18 position
.equ LOCK_KEY_19_bm = (1<<19)            ; Lock Key bit 19 mask
.equ LOCK_KEY_19_bp = 19                 ; Lock Key bit 19 position
.equ LOCK_KEY_20_bm = (1<<20)            ; Lock Key bit 20 mask
.equ LOCK_KEY_20_bp = 20                 ; Lock Key bit 20 position
.equ LOCK_KEY_21_bm = (1<<21)            ; Lock Key bit 21 mask
.equ LOCK_KEY_21_bp = 21                 ; Lock Key bit 21 position
.equ LOCK_KEY_22_bm = (1<<22)            ; Lock Key bit 22 mask
.equ LOCK_KEY_22_bp = 22                 ; Lock Key bit 22 position
.equ LOCK_KEY_23_bm = (1<<23)            ; Lock Key bit 23 mask
.equ LOCK_KEY_23_bp = 23                 ; Lock Key bit 23 position
.equ LOCK_KEY_24_bm = (1<<24)            ; Lock Key bit 24 mask
.equ LOCK_KEY_24_bp = 24                 ; Lock Key bit 24 position
.equ LOCK_KEY_25_bm = (1<<25)            ; Lock Key bit 25 mask
.equ LOCK_KEY_25_bp = 25                 ; Lock Key bit 25 position
.equ LOCK_KEY_26_bm = (1<<26)            ; Lock Key bit 26 mask
.equ LOCK_KEY_26_bp = 26                 ; Lock Key bit 26 position
.equ LOCK_KEY_27_bm = (1<<27)            ; Lock Key bit 27 mask
.equ LOCK_KEY_27_bp = 27                 ; Lock Key bit 27 position
.equ LOCK_KEY_28_bm = (1<<28)            ; Lock Key bit 28 mask
.equ LOCK_KEY_28_bp = 28                 ; Lock Key bit 28 position
.equ LOCK_KEY_29_bm = (1<<29)            ; Lock Key bit 29 mask
.equ LOCK_KEY_29_bp = 29                 ; Lock Key bit 29 position
.equ LOCK_KEY_30_bm = (1<<30)            ; Lock Key bit 30 mask
.equ LOCK_KEY_30_bp = 30                 ; Lock Key bit 30 position
.equ LOCK_KEY_31_bm = (1<<31)            ; Lock Key bit 31 mask
.equ LOCK_KEY_31_bp = 31                 ; Lock Key bit 31 position

; Lock Key select
.equ LOCK_KEY_NOLOCK_gc = (0x5CC5C55C<<0) ; No locks
.equ LOCK_KEY_RWLOCK_gc = (0xA33A3AA3<<0) ; Read and write lock


;*************************************************************************
;** NVMCTRL - Non-volatile Memory Controller
;*************************************************************************

; NVMCTRL_CTRLA masks
.equ NVMCTRL_CMD_gm = 0x7F               ; Command group mask
.equ NVMCTRL_CMD_gp = 0                  ; Command group position
.equ NVMCTRL_CMD_0_bm = (1<<0)           ; Command bit 0 mask
.equ NVMCTRL_CMD_0_bp = 0                ; Command bit 0 position
.equ NVMCTRL_CMD_1_bm = (1<<1)           ; Command bit 1 mask
.equ NVMCTRL_CMD_1_bp = 1                ; Command bit 1 position
.equ NVMCTRL_CMD_2_bm = (1<<2)           ; Command bit 2 mask
.equ NVMCTRL_CMD_2_bp = 2                ; Command bit 2 position
.equ NVMCTRL_CMD_3_bm = (1<<3)           ; Command bit 3 mask
.equ NVMCTRL_CMD_3_bp = 3                ; Command bit 3 position
.equ NVMCTRL_CMD_4_bm = (1<<4)           ; Command bit 4 mask
.equ NVMCTRL_CMD_4_bp = 4                ; Command bit 4 position
.equ NVMCTRL_CMD_5_bm = (1<<5)           ; Command bit 5 mask
.equ NVMCTRL_CMD_5_bp = 5                ; Command bit 5 position
.equ NVMCTRL_CMD_6_bm = (1<<6)           ; Command bit 6 mask
.equ NVMCTRL_CMD_6_bp = 6                ; Command bit 6 position

; NVMCTRL_CTRLB masks
.equ NVMCTRL_APPCODEWP_bm = 0x01         ; Application Code Write Protect bit mask
.equ NVMCTRL_APPCODEWP_bp = 0            ; Application Code Write Protect bit position
.equ NVMCTRL_BOOTRP_bm = 0x02            ; Boot Read Protect bit mask
.equ NVMCTRL_BOOTRP_bp = 1               ; Boot Read Protect bit position
.equ NVMCTRL_APPDATAWP_bm = 0x04         ; Application Data Write Protect bit mask
.equ NVMCTRL_APPDATAWP_bp = 2            ; Application Data Write Protect bit position
.equ NVMCTRL_EEWP_bm = 0x08              ; EEPROM Write Protect bit mask
.equ NVMCTRL_EEWP_bp = 3                 ; EEPROM Write Protect bit position
.equ NVMCTRL_FLMAP_gm = 0x30             ; Flash Mapping in Data space group mask
.equ NVMCTRL_FLMAP_gp = 4                ; Flash Mapping in Data space group position
.equ NVMCTRL_FLMAP_0_bm = (1<<4)         ; Flash Mapping in Data space bit 0 mask
.equ NVMCTRL_FLMAP_0_bp = 4              ; Flash Mapping in Data space bit 0 position
.equ NVMCTRL_FLMAP_1_bm = (1<<5)         ; Flash Mapping in Data space bit 1 mask
.equ NVMCTRL_FLMAP_1_bp = 5              ; Flash Mapping in Data space bit 1 position
.equ NVMCTRL_FLMAPLOCK_bm = 0x80         ; Flash Mapping Lock bit mask
.equ NVMCTRL_FLMAPLOCK_bp = 7            ; Flash Mapping Lock bit position

; NVMCTRL_CTRLC masks
.equ NVMCTRL_UROWWP_bm = 0x01            ; User Row Write Protect bit mask
.equ NVMCTRL_UROWWP_bp = 0               ; User Row Write Protect bit position
.equ NVMCTRL_BOOTROWWP_bm = 0x02         ; Boot Row Write Protect bit mask
.equ NVMCTRL_BOOTROWWP_bp = 1            ; Boot Row Write Protect bit position

; NVMCTRL_INTCTRL masks
.equ NVMCTRL_EEREADY_bm = 0x01           ; EEPROM Ready bit mask
.equ NVMCTRL_EEREADY_bp = 0              ; EEPROM Ready bit position
.equ NVMCTRL_FLREADY_bm = 0x02           ; Flash Ready bit mask
.equ NVMCTRL_FLREADY_bp = 1              ; Flash Ready bit position

; NVMCTRL_INTFLAGS masks
; Masks for NVMCTRL_EEREADY already defined
; Masks for NVMCTRL_FLREADY already defined

; NVMCTRL_STATUS masks
.equ NVMCTRL_EEBUSY_bm = 0x01            ; EEPROM busy bit mask
.equ NVMCTRL_EEBUSY_bp = 0               ; EEPROM busy bit position
.equ NVMCTRL_FLBUSY_bm = 0x02            ; Flash busy bit mask
.equ NVMCTRL_FLBUSY_bp = 1               ; Flash busy bit position
.equ NVMCTRL_ERROR_gm = 0x70             ; Write error group mask
.equ NVMCTRL_ERROR_gp = 4                ; Write error group position
.equ NVMCTRL_ERROR_0_bm = (1<<4)         ; Write error bit 0 mask
.equ NVMCTRL_ERROR_0_bp = 4              ; Write error bit 0 position
.equ NVMCTRL_ERROR_1_bm = (1<<5)         ; Write error bit 1 mask
.equ NVMCTRL_ERROR_1_bp = 5              ; Write error bit 1 position
.equ NVMCTRL_ERROR_2_bm = (1<<6)         ; Write error bit 2 mask
.equ NVMCTRL_ERROR_2_bp = 6              ; Write error bit 2 position

; Command select
.equ NVMCTRL_CMD_NONE_gc = (0x00<<0)     ; No Command
.equ NVMCTRL_CMD_NOOP_gc = (0x01<<0)     ; No Operation
.equ NVMCTRL_CMD_FLWR_gc = (0x02<<0)     ; Flash Write
.equ NVMCTRL_CMD_FLPER_gc = (0x08<<0)    ; Flash Page Erase
.equ NVMCTRL_CMD_FLMPER2_gc = (0x09<<0)  ; Flash Multi-Page Erase 2 pages
.equ NVMCTRL_CMD_FLMPER4_gc = (0x0A<<0)  ; Flash Multi-Page Erase 4 pages
.equ NVMCTRL_CMD_FLMPER8_gc = (0x0B<<0)  ; Flash Multi-Page Erase 8 pages
.equ NVMCTRL_CMD_FLMPER16_gc = (0x0C<<0) ; Flash Multi-Page Erase 16 pages
.equ NVMCTRL_CMD_FLMPER32_gc = (0x0D<<0) ; Flash Multi-Page Erase 32 pages
.equ NVMCTRL_CMD_EEWR_gc = (0x12<<0)     ; EEPROM Write
.equ NVMCTRL_CMD_EEERWR_gc = (0x13<<0)   ; EEPROM Erase and Write
.equ NVMCTRL_CMD_EEBER_gc = (0x18<<0)    ; EEPROM Byte Erase
.equ NVMCTRL_CMD_EEMBER2_gc = (0x19<<0)  ; EEPROM Multi-Byte Erase 2 bytes
.equ NVMCTRL_CMD_EEMBER4_gc = (0x1A<<0)  ; EEPROM Multi-Byte Erase 4 bytes
.equ NVMCTRL_CMD_EEMBER8_gc = (0x1B<<0)  ; EEPROM Multi-Byte Erase 8 bytes
.equ NVMCTRL_CMD_EEMBER16_gc = (0x1C<<0) ; EEPROM Multi-Byte Erase 16 bytes
.equ NVMCTRL_CMD_EEMBER32_gc = (0x1D<<0) ; EEPROM Multi-Byte Erase 32 bytes
.equ NVMCTRL_CMD_CHER_gc = (0x20<<0)     ; Chip Erase Command
.equ NVMCTRL_CMD_EECHER_gc = (0x30<<0)   ; EEPROM Erase Command

; Flash Mapping in Data space select
.equ NVMCTRL_FLMAP_SECTION0_gc = (0x00<<4) ; Flash section 0
.equ NVMCTRL_FLMAP_SECTION1_gc = (0x01<<4) ; Flash section 1
.equ NVMCTRL_FLMAP_SECTION2_gc = (0x02<<4) ; Flash section 2
.equ NVMCTRL_FLMAP_SECTION3_gc = (0x03<<4) ; Flash section 3

; Write error select
.equ NVMCTRL_ERROR_NOERROR_gc = (0x00<<4) ; No Error
.equ NVMCTRL_ERROR_INVALIDCMD_gc = (0x01<<4) ; Write command not selected or not valid
.equ NVMCTRL_ERROR_WRITEPROTECT_gc = (0x02<<4) ; Write to section not allowed
.equ NVMCTRL_ERROR_CMDCOLLISION_gc = (0x03<<4) ; Selecting new write command while programming is ongoing


;*************************************************************************
;** PORT - I/O Ports
;*************************************************************************

; PORT_INTFLAGS masks
.equ PORT_INT_gm = 0xFF                  ; Pin Interrupt Flag group mask
.equ PORT_INT_gp = 0                     ; Pin Interrupt Flag group position
.equ PORT_INT_0_bm = (1<<0)              ; Pin Interrupt Flag bit 0 mask
.equ PORT_INT_0_bp = 0                   ; Pin Interrupt Flag bit 0 position
.equ PORT_INT_1_bm = (1<<1)              ; Pin Interrupt Flag bit 1 mask
.equ PORT_INT_1_bp = 1                   ; Pin Interrupt Flag bit 1 position
.equ PORT_INT_2_bm = (1<<2)              ; Pin Interrupt Flag bit 2 mask
.equ PORT_INT_2_bp = 2                   ; Pin Interrupt Flag bit 2 position
.equ PORT_INT_3_bm = (1<<3)              ; Pin Interrupt Flag bit 3 mask
.equ PORT_INT_3_bp = 3                   ; Pin Interrupt Flag bit 3 position
.equ PORT_INT_4_bm = (1<<4)              ; Pin Interrupt Flag bit 4 mask
.equ PORT_INT_4_bp = 4                   ; Pin Interrupt Flag bit 4 position
.equ PORT_INT_5_bm = (1<<5)              ; Pin Interrupt Flag bit 5 mask
.equ PORT_INT_5_bp = 5                   ; Pin Interrupt Flag bit 5 position
.equ PORT_INT_6_bm = (1<<6)              ; Pin Interrupt Flag bit 6 mask
.equ PORT_INT_6_bp = 6                   ; Pin Interrupt Flag bit 6 position
.equ PORT_INT_7_bm = (1<<7)              ; Pin Interrupt Flag bit 7 mask
.equ PORT_INT_7_bp = 7                   ; Pin Interrupt Flag bit 7 position

; PORT_PORTCTRL masks
.equ PORT_SRL_bm = 0x01                  ; Slew Rate Limit Enable bit mask
.equ PORT_SRL_bp = 0                     ; Slew Rate Limit Enable bit position

; PORT_PINCONFIG masks
.equ PORT_ISC_gm = 0x07                  ; Input/Sense Configuration group mask
.equ PORT_ISC_gp = 0                     ; Input/Sense Configuration group position
.equ PORT_ISC_0_bm = (1<<0)              ; Input/Sense Configuration bit 0 mask
.equ PORT_ISC_0_bp = 0                   ; Input/Sense Configuration bit 0 position
.equ PORT_ISC_1_bm = (1<<1)              ; Input/Sense Configuration bit 1 mask
.equ PORT_ISC_1_bp = 1                   ; Input/Sense Configuration bit 1 position
.equ PORT_ISC_2_bm = (1<<2)              ; Input/Sense Configuration bit 2 mask
.equ PORT_ISC_2_bp = 2                   ; Input/Sense Configuration bit 2 position
.equ PORT_PULLUPEN_bm = 0x08             ; Pullup enable bit mask
.equ PORT_PULLUPEN_bp = 3                ; Pullup enable bit position
.equ PORT_INLVL_bm = 0x40                ; Input Level Select bit mask
.equ PORT_INLVL_bp = 6                   ; Input Level Select bit position
.equ PORT_INVEN_bm = 0x80                ; Inverted I/O Enable bit mask
.equ PORT_INVEN_bp = 7                   ; Inverted I/O Enable bit position

; PORT_PIN0CTRL masks
; Masks for PORT_ISC already defined
; Masks for PORT_PULLUPEN already defined
; Masks for PORT_INLVL already defined
; Masks for PORT_INVEN already defined

; PORT_PIN1CTRL masks
; Masks for PORT_ISC already defined
; Masks for PORT_PULLUPEN already defined
; Masks for PORT_INLVL already defined
; Masks for PORT_INVEN already defined

; PORT_PIN2CTRL masks
; Masks for PORT_ISC already defined
; Masks for PORT_PULLUPEN already defined
; Masks for PORT_INLVL already defined
; Masks for PORT_INVEN already defined

; PORT_PIN3CTRL masks
; Masks for PORT_ISC already defined
; Masks for PORT_PULLUPEN already defined
; Masks for PORT_INLVL already defined
; Masks for PORT_INVEN already defined

; PORT_PIN4CTRL masks
; Masks for PORT_ISC already defined
; Masks for PORT_PULLUPEN already defined
; Masks for PORT_INLVL already defined
; Masks for PORT_INVEN already defined

; PORT_PIN5CTRL masks
; Masks for PORT_ISC already defined
; Masks for PORT_PULLUPEN already defined
; Masks for PORT_INLVL already defined
; Masks for PORT_INVEN already defined

; PORT_PIN6CTRL masks
; Masks for PORT_ISC already defined
; Masks for PORT_PULLUPEN already defined
; Masks for PORT_INLVL already defined
; Masks for PORT_INVEN already defined

; PORT_PIN7CTRL masks
; Masks for PORT_ISC already defined
; Masks for PORT_PULLUPEN already defined
; Masks for PORT_INLVL already defined
; Masks for PORT_INVEN already defined

; PORT_EVGENCTRLA masks
.equ PORT_EVGEN0SEL_gm = 0x07            ; Event Generator 0 Select group mask
.equ PORT_EVGEN0SEL_gp = 0               ; Event Generator 0 Select group position
.equ PORT_EVGEN0SEL_0_bm = (1<<0)        ; Event Generator 0 Select bit 0 mask
.equ PORT_EVGEN0SEL_0_bp = 0             ; Event Generator 0 Select bit 0 position
.equ PORT_EVGEN0SEL_1_bm = (1<<1)        ; Event Generator 0 Select bit 1 mask
.equ PORT_EVGEN0SEL_1_bp = 1             ; Event Generator 0 Select bit 1 position
.equ PORT_EVGEN0SEL_2_bm = (1<<2)        ; Event Generator 0 Select bit 2 mask
.equ PORT_EVGEN0SEL_2_bp = 2             ; Event Generator 0 Select bit 2 position
.equ PORT_EVGEN1SEL_gm = 0x70            ; Event Generator 1 Select group mask
.equ PORT_EVGEN1SEL_gp = 4               ; Event Generator 1 Select group position
.equ PORT_EVGEN1SEL_0_bm = (1<<4)        ; Event Generator 1 Select bit 0 mask
.equ PORT_EVGEN1SEL_0_bp = 4             ; Event Generator 1 Select bit 0 position
.equ PORT_EVGEN1SEL_1_bm = (1<<5)        ; Event Generator 1 Select bit 1 mask
.equ PORT_EVGEN1SEL_1_bp = 5             ; Event Generator 1 Select bit 1 position
.equ PORT_EVGEN1SEL_2_bm = (1<<6)        ; Event Generator 1 Select bit 2 mask
.equ PORT_EVGEN1SEL_2_bp = 6             ; Event Generator 1 Select bit 2 position

; Event Generator 0 Select
.equ PORT_EVGEN0SEL_PIN0_gc = (0x00<<0)  ; Pin 0 used as event generator
.equ PORT_EVGEN0SEL_PIN1_gc = (0x01<<0)  ; Pin 1 used as event generator
.equ PORT_EVGEN0SEL_PIN2_gc = (0x02<<0)  ; Pin 2 used as event generator
.equ PORT_EVGEN0SEL_PIN3_gc = (0x03<<0)  ; Pin 3 used as event generator
.equ PORT_EVGEN0SEL_PIN4_gc = (0x04<<0)  ; Pin 4 used as event generator
.equ PORT_EVGEN0SEL_PIN5_gc = (0x05<<0)  ; Pin 5 used as event generator
.equ PORT_EVGEN0SEL_PIN6_gc = (0x06<<0)  ; Pin 6 used as event generator
.equ PORT_EVGEN0SEL_PIN7_gc = (0x07<<0)  ; Pin 7 used as event generator

; Event Generator 1 Select
.equ PORT_EVGEN1SEL_PIN0_gc = (0x00<<4)  ; Pin 0 used as event generator
.equ PORT_EVGEN1SEL_PIN1_gc = (0x01<<4)  ; Pin 1 used as event generator
.equ PORT_EVGEN1SEL_PIN2_gc = (0x02<<4)  ; Pin 2 used as event generator
.equ PORT_EVGEN1SEL_PIN3_gc = (0x03<<4)  ; Pin 3 used as event generator
.equ PORT_EVGEN1SEL_PIN4_gc = (0x04<<4)  ; Pin 4 used as event generator
.equ PORT_EVGEN1SEL_PIN5_gc = (0x05<<4)  ; Pin 5 used as event generator
.equ PORT_EVGEN1SEL_PIN6_gc = (0x06<<4)  ; Pin 6 used as event generator
.equ PORT_EVGEN1SEL_PIN7_gc = (0x07<<4)  ; Pin 7 used as event generator

; Input Level Select
.equ PORT_INLVL_ST_gc = (0x00<<6)        ; Schmitt-Trigger input level
.equ PORT_INLVL_TTL_gc = (0x01<<6)       ; TTL Input level

; Input/Sense Configuration select
.equ PORT_ISC_INTDISABLE_gc = (0x00<<0)  ; Interrupt disabled but input buffer enabled
.equ PORT_ISC_BOTHEDGES_gc = (0x01<<0)   ; Sense Both Edges
.equ PORT_ISC_RISING_gc = (0x02<<0)      ; Sense Rising Edge
.equ PORT_ISC_FALLING_gc = (0x03<<0)     ; Sense Falling Edge
.equ PORT_ISC_INPUT_DISABLE_gc = (0x04<<0) ; Digital Input Buffer disabled
.equ PORT_ISC_LEVEL_gc = (0x05<<0)       ; Sense low Level


;*************************************************************************
;** PORTMUX - Port Multiplexer
;*************************************************************************

; PORTMUX_EVSYSROUTEA masks
.equ PORTMUX_EVOUTA_bm = 0x01            ; Event Output A bit mask
.equ PORTMUX_EVOUTA_bp = 0               ; Event Output A bit position
.equ PORTMUX_EVOUTD_bm = 0x08            ; Event Output D bit mask
.equ PORTMUX_EVOUTD_bp = 3               ; Event Output D bit position
.equ PORTMUX_EVOUTF_bm = 0x20            ; Event Output F bit mask
.equ PORTMUX_EVOUTF_bp = 5               ; Event Output F bit position

; PORTMUX_CCLROUTEA masks
.equ PORTMUX_LUT0_bm = 0x01              ; CCL Look-Up Table 0 Signals bit mask
.equ PORTMUX_LUT0_bp = 0                 ; CCL Look-Up Table 0 Signals bit position
.equ PORTMUX_LUT1_bm = 0x02              ; CCL Look-Up Table 1 Signals bit mask
.equ PORTMUX_LUT1_bp = 1                 ; CCL Look-Up Table 1 Signals bit position
.equ PORTMUX_LUT2_bm = 0x04              ; CCL Look-Up Table 2 Signals bit mask
.equ PORTMUX_LUT2_bp = 2                 ; CCL Look-Up Table 2 Signals bit position
.equ PORTMUX_LUT3_bm = 0x08              ; CCL Look-Up Table 3 Signals bit mask
.equ PORTMUX_LUT3_bp = 3                 ; CCL Look-Up Table 3 Signals bit position

; PORTMUX_USARTROUTEA masks
.equ PORTMUX_USART0_gm = 0x07            ; USART0 Signals group mask
.equ PORTMUX_USART0_gp = 0               ; USART0 Signals group position
.equ PORTMUX_USART0_0_bm = (1<<0)        ; USART0 Signals bit 0 mask
.equ PORTMUX_USART0_0_bp = 0             ; USART0 Signals bit 0 position
.equ PORTMUX_USART0_1_bm = (1<<1)        ; USART0 Signals bit 1 mask
.equ PORTMUX_USART0_1_bp = 1             ; USART0 Signals bit 1 position
.equ PORTMUX_USART0_2_bm = (1<<2)        ; USART0 Signals bit 2 mask
.equ PORTMUX_USART0_2_bp = 2             ; USART0 Signals bit 2 position
.equ PORTMUX_USART1_gm = 0x18            ; USART1 Signals group mask
.equ PORTMUX_USART1_gp = 3               ; USART1 Signals group position
.equ PORTMUX_USART1_0_bm = (1<<3)        ; USART1 Signals bit 0 mask
.equ PORTMUX_USART1_0_bp = 3             ; USART1 Signals bit 0 position
.equ PORTMUX_USART1_1_bm = (1<<4)        ; USART1 Signals bit 1 mask
.equ PORTMUX_USART1_1_bp = 4             ; USART1 Signals bit 1 position

; PORTMUX_SPIROUTEA masks
.equ PORTMUX_SPI0_gm = 0x07              ; SPI0 Signals group mask
.equ PORTMUX_SPI0_gp = 0                 ; SPI0 Signals group position
.equ PORTMUX_SPI0_0_bm = (1<<0)          ; SPI0 Signals bit 0 mask
.equ PORTMUX_SPI0_0_bp = 0               ; SPI0 Signals bit 0 position
.equ PORTMUX_SPI0_1_bm = (1<<1)          ; SPI0 Signals bit 1 mask
.equ PORTMUX_SPI0_1_bp = 1               ; SPI0 Signals bit 1 position
.equ PORTMUX_SPI0_2_bm = (1<<2)          ; SPI0 Signals bit 2 mask
.equ PORTMUX_SPI0_2_bp = 2               ; SPI0 Signals bit 2 position

; PORTMUX_TWIROUTEA masks
.equ PORTMUX_TWI0_gm = 0x03              ; TWI0 Signals group mask
.equ PORTMUX_TWI0_gp = 0                 ; TWI0 Signals group position
.equ PORTMUX_TWI0_0_bm = (1<<0)          ; TWI0 Signals bit 0 mask
.equ PORTMUX_TWI0_0_bp = 0               ; TWI0 Signals bit 0 position
.equ PORTMUX_TWI0_1_bm = (1<<1)          ; TWI0 Signals bit 1 mask
.equ PORTMUX_TWI0_1_bp = 1               ; TWI0 Signals bit 1 position

; PORTMUX_TCAROUTEA masks
.equ PORTMUX_TCA0_gm = 0x07              ; TCA0 Signals group mask
.equ PORTMUX_TCA0_gp = 0                 ; TCA0 Signals group position
.equ PORTMUX_TCA0_0_bm = (1<<0)          ; TCA0 Signals bit 0 mask
.equ PORTMUX_TCA0_0_bp = 0               ; TCA0 Signals bit 0 position
.equ PORTMUX_TCA0_1_bm = (1<<1)          ; TCA0 Signals bit 1 mask
.equ PORTMUX_TCA0_1_bp = 1               ; TCA0 Signals bit 1 position
.equ PORTMUX_TCA0_2_bm = (1<<2)          ; TCA0 Signals bit 2 mask
.equ PORTMUX_TCA0_2_bp = 2               ; TCA0 Signals bit 2 position

; PORTMUX_TCBROUTEA masks
.equ PORTMUX_TCB0_bm = 0x01              ; TCB0 Output bit mask
.equ PORTMUX_TCB0_bp = 0                 ; TCB0 Output bit position
.equ PORTMUX_TCB1_bm = 0x02              ; TCB1 Output bit mask
.equ PORTMUX_TCB1_bp = 1                 ; TCB1 Output bit position

; CCL Look-Up Table 0 Signals select
.equ PORTMUX_LUT0_DEFAULT_gc = (0x00<<0) ; In: PA0, PA1, PA2, Out: PA3
.equ PORTMUX_LUT0_ALT1_gc = (0x01<<0)    ; In: PA0, PA1, PA2, Out: PA6

; CCL Look-Up Table 1 Signals select
.equ PORTMUX_LUT1_DEFAULT_gc = (0x00<<1) ; In: -, -, -, Out: PC3

; CCL Look-Up Table 2 Signals select
.equ PORTMUX_LUT2_DEFAULT_gc = (0x00<<2) ; In: PD0, PD1, PD2, Out: PD3
.equ PORTMUX_LUT2_ALT1_gc = (0x01<<2)    ; In: PD0, PD1, PD2, Out: PD6

; CCL Look-Up Table 3 Signals select
.equ PORTMUX_LUT3_DEFAULT_gc = (0x00<<3) ; In: PF0, PF1, PF2, Out: PF3

; Event Output A select
.equ PORTMUX_EVOUTA_DEFAULT_gc = (0x00<<0) ; EVOUTA: PA2
.equ PORTMUX_EVOUTA_ALT1_gc = (0x01<<0)  ; EVOUTA: PA7

; Event Output D select
.equ PORTMUX_EVOUTD_DEFAULT_gc = (0x00<<3) ; EVOUTD: PD2
.equ PORTMUX_EVOUTD_ALT1_gc = (0x01<<3)  ; EVOUTD: PD7

; Event Output F select
.equ PORTMUX_EVOUTF_DEFAULT_gc = (0x00<<5) ; EVOUTF: PF2
.equ PORTMUX_EVOUTF_ALT1_gc = (0x01<<5)  ; EVOUTF: PF7

; SPI0 Signals select
.equ PORTMUX_SPI0_DEFAULT_gc = (0x00<<0) ; MOSI: PA4, MISO: PA5, SCK: PA6, SS: PA7
.equ PORTMUX_SPI0_ALT4_gc = (0x04<<0)    ; MOSI: PD4, MISO: PD5, SCK: PD6, SS: PD7
.equ PORTMUX_SPI0_NONE_gc = (0x07<<0)    ; Not connected to any pins, SS set to 1

; TCA0 Signals select
.equ PORTMUX_TCA0_PORTA_gc = (0x00<<0)   ; WOn: PA0, PA1, PA2, PA3, PA4, PA5
.equ PORTMUX_TCA0_PORTC_gc = (0x02<<0)   ; WOn: -, -, -, PC3, -, -
.equ PORTMUX_TCA0_PORTD_gc = (0x03<<0)   ; WOn: PD0, PD1, PD2, PD3, PD4, PD5
.equ PORTMUX_TCA0_PORTF_gc = (0x05<<0)   ; WOn: PF0, PF1, PF2, PF3, PF4, PF5

; TCB0 Output select
.equ PORTMUX_TCB0_DEFAULT_gc = (0x00<<0) ; WO: PA2
.equ PORTMUX_TCB0_ALT1_gc = (0x01<<0)    ; WO: PF4

; TCB1 Output select
.equ PORTMUX_TCB1_DEFAULT_gc = (0x00<<1) ; WO: PA3
.equ PORTMUX_TCB1_ALT1_gc = (0x01<<1)    ; WO: PF5

; TWI0 Signals select
.equ PORTMUX_TWI0_DEFAULT_gc = (0x00<<0) ; SDA: PA2, SCL: PA3
.equ PORTMUX_TWI0_ALT3_gc = (0x03<<0)    ; SDA: PA0, SCL: PA1

; USART0 Signals select
.equ PORTMUX_USART0_DEFAULT_gc = (0x00<<0) ; TxD: PA0, RxD: PA1, XCK: PA2, XDIR: PA3
.equ PORTMUX_USART0_ALT1_gc = (0x01<<0)  ; TxD: PA4, RxD: PA5, XCK: PA6, XDIR: PA7
.equ PORTMUX_USART0_ALT2_gc = (0x02<<0)  ; TxD: PA2, RxD: PA3, XCK: -, XDIR: -
.equ PORTMUX_USART0_ALT3_gc = (0x03<<0)  ; TxD: PD4, RxD: PD5, XCK: PD6, XDIR: PD7
.equ PORTMUX_USART0_NONE_gc = (0x05<<0)  ; Not connected to any pins

; USART1 Signals select
.equ PORTMUX_USART1_DEFAULT_gc = (0x00<<3) ; Not connected to any pins
.equ PORTMUX_USART1_ALT2_gc = (0x02<<3)  ; TxD: PD6, RxD: PD7, XCK: -, XDIR: -


;*************************************************************************
;** RSTCTRL - Reset controller
;*************************************************************************

; RSTCTRL_RSTFR masks
.equ RSTCTRL_PORF_bm = 0x01              ; Power on Reset flag bit mask
.equ RSTCTRL_PORF_bp = 0                 ; Power on Reset flag bit position
.equ RSTCTRL_BORF_bm = 0x02              ; Brown out detector Reset flag bit mask
.equ RSTCTRL_BORF_bp = 1                 ; Brown out detector Reset flag bit position
.equ RSTCTRL_EXTRF_bm = 0x04             ; External Reset flag bit mask
.equ RSTCTRL_EXTRF_bp = 2                ; External Reset flag bit position
.equ RSTCTRL_WDRF_bm = 0x08              ; Watch dog Reset flag bit mask
.equ RSTCTRL_WDRF_bp = 3                 ; Watch dog Reset flag bit position
.equ RSTCTRL_SWRF_bm = 0x10              ; Software Reset flag bit mask
.equ RSTCTRL_SWRF_bp = 4                 ; Software Reset flag bit position
.equ RSTCTRL_UPDIRF_bm = 0x20            ; UPDI Reset flag bit mask
.equ RSTCTRL_UPDIRF_bp = 5               ; UPDI Reset flag bit position

; RSTCTRL_SWRR masks
.equ RSTCTRL_SWRST_bm = 0x01             ; Software reset enable bit mask
.equ RSTCTRL_SWRST_bp = 0                ; Software reset enable bit position


;*************************************************************************
;** RTC - Real-Time Counter
;*************************************************************************

; RTC_CTRLA masks
.equ RTC_RTCEN_bm = 0x01                 ; Enable bit mask
.equ RTC_RTCEN_bp = 0                    ; Enable bit position
.equ RTC_CORREN_bm = 0x04                ; Correction enable bit mask
.equ RTC_CORREN_bp = 2                   ; Correction enable bit position
.equ RTC_PRESCALER_gm = 0x78             ; Prescaling Factor group mask
.equ RTC_PRESCALER_gp = 3                ; Prescaling Factor group position
.equ RTC_PRESCALER_0_bm = (1<<3)         ; Prescaling Factor bit 0 mask
.equ RTC_PRESCALER_0_bp = 3              ; Prescaling Factor bit 0 position
.equ RTC_PRESCALER_1_bm = (1<<4)         ; Prescaling Factor bit 1 mask
.equ RTC_PRESCALER_1_bp = 4              ; Prescaling Factor bit 1 position
.equ RTC_PRESCALER_2_bm = (1<<5)         ; Prescaling Factor bit 2 mask
.equ RTC_PRESCALER_2_bp = 5              ; Prescaling Factor bit 2 position
.equ RTC_PRESCALER_3_bm = (1<<6)         ; Prescaling Factor bit 3 mask
.equ RTC_PRESCALER_3_bp = 6              ; Prescaling Factor bit 3 position
.equ RTC_RUNSTDBY_bm = 0x80              ; Run In Standby bit mask
.equ RTC_RUNSTDBY_bp = 7                 ; Run In Standby bit position

; RTC_STATUS masks
.equ RTC_CTRLABUSY_bm = 0x01             ; CTRLA Synchronization Busy Flag bit mask
.equ RTC_CTRLABUSY_bp = 0                ; CTRLA Synchronization Busy Flag bit position
.equ RTC_CNTBUSY_bm = 0x02               ; Count Synchronization Busy Flag bit mask
.equ RTC_CNTBUSY_bp = 1                  ; Count Synchronization Busy Flag bit position
.equ RTC_PERBUSY_bm = 0x04               ; Period Synchronization Busy Flag bit mask
.equ RTC_PERBUSY_bp = 2                  ; Period Synchronization Busy Flag bit position
.equ RTC_CMPBUSY_bm = 0x08               ; Comparator Synchronization Busy Flag bit mask
.equ RTC_CMPBUSY_bp = 3                  ; Comparator Synchronization Busy Flag bit position

; RTC_INTCTRL masks
.equ RTC_OVF_bm = 0x01                   ; Overflow Interrupt enable bit mask
.equ RTC_OVF_bp = 0                      ; Overflow Interrupt enable bit position
.equ RTC_CMP_bm = 0x02                   ; Compare Match Interrupt enable bit mask
.equ RTC_CMP_bp = 1                      ; Compare Match Interrupt enable bit position

; RTC_INTFLAGS masks
; Masks for RTC_OVF already defined
; Masks for RTC_CMP already defined

; RTC_DBGCTRL masks
.equ RTC_DBGRUN_bm = 0x01                ; Run in debug bit mask
.equ RTC_DBGRUN_bp = 0                   ; Run in debug bit position

; RTC_CALIB masks
.equ RTC_ERROR_gm = 0x7F                 ; Error Correction Value group mask
.equ RTC_ERROR_gp = 0                    ; Error Correction Value group position
.equ RTC_ERROR_0_bm = (1<<0)             ; Error Correction Value bit 0 mask
.equ RTC_ERROR_0_bp = 0                  ; Error Correction Value bit 0 position
.equ RTC_ERROR_1_bm = (1<<1)             ; Error Correction Value bit 1 mask
.equ RTC_ERROR_1_bp = 1                  ; Error Correction Value bit 1 position
.equ RTC_ERROR_2_bm = (1<<2)             ; Error Correction Value bit 2 mask
.equ RTC_ERROR_2_bp = 2                  ; Error Correction Value bit 2 position
.equ RTC_ERROR_3_bm = (1<<3)             ; Error Correction Value bit 3 mask
.equ RTC_ERROR_3_bp = 3                  ; Error Correction Value bit 3 position
.equ RTC_ERROR_4_bm = (1<<4)             ; Error Correction Value bit 4 mask
.equ RTC_ERROR_4_bp = 4                  ; Error Correction Value bit 4 position
.equ RTC_ERROR_5_bm = (1<<5)             ; Error Correction Value bit 5 mask
.equ RTC_ERROR_5_bp = 5                  ; Error Correction Value bit 5 position
.equ RTC_ERROR_6_bm = (1<<6)             ; Error Correction Value bit 6 mask
.equ RTC_ERROR_6_bp = 6                  ; Error Correction Value bit 6 position
.equ RTC_SIGN_bm = 0x80                  ; Error Correction Sign Bit bit mask
.equ RTC_SIGN_bp = 7                     ; Error Correction Sign Bit bit position

; RTC_CLKSEL masks
.equ RTC_CLKSEL_gm = 0x03                ; Clock Select group mask
.equ RTC_CLKSEL_gp = 0                   ; Clock Select group position
.equ RTC_CLKSEL_0_bm = (1<<0)            ; Clock Select bit 0 mask
.equ RTC_CLKSEL_0_bp = 0                 ; Clock Select bit 0 position
.equ RTC_CLKSEL_1_bm = (1<<1)            ; Clock Select bit 1 mask
.equ RTC_CLKSEL_1_bp = 1                 ; Clock Select bit 1 position

; RTC_PITCTRLA masks
.equ RTC_PITEN_bm = 0x01                 ; Enable bit mask
.equ RTC_PITEN_bp = 0                    ; Enable bit position
.equ RTC_PERIOD_gm = 0x78                ; Period group mask
.equ RTC_PERIOD_gp = 3                   ; Period group position
.equ RTC_PERIOD_0_bm = (1<<3)            ; Period bit 0 mask
.equ RTC_PERIOD_0_bp = 3                 ; Period bit 0 position
.equ RTC_PERIOD_1_bm = (1<<4)            ; Period bit 1 mask
.equ RTC_PERIOD_1_bp = 4                 ; Period bit 1 position
.equ RTC_PERIOD_2_bm = (1<<5)            ; Period bit 2 mask
.equ RTC_PERIOD_2_bp = 5                 ; Period bit 2 position
.equ RTC_PERIOD_3_bm = (1<<6)            ; Period bit 3 mask
.equ RTC_PERIOD_3_bp = 6                 ; Period bit 3 position

; RTC_PITSTATUS masks
.equ RTC_CTRLBUSY_bm = 0x01              ; CTRLA Synchronization Busy Flag bit mask
.equ RTC_CTRLBUSY_bp = 0                 ; CTRLA Synchronization Busy Flag bit position

; RTC_PITINTCTRL masks
.equ RTC_PI_bm = 0x01                    ; Periodic Interrupt bit mask
.equ RTC_PI_bp = 0                       ; Periodic Interrupt bit position

; RTC_PITINTFLAGS masks
; Masks for RTC_PI already defined

; RTC_PITDBGCTRL masks
; Masks for RTC_DBGRUN already defined

; RTC_PITEVGENCTRLA masks
.equ RTC_EVGEN0SEL_gm = 0x0F             ; Event Generation 0 Select group mask
.equ RTC_EVGEN0SEL_gp = 0                ; Event Generation 0 Select group position
.equ RTC_EVGEN0SEL_0_bm = (1<<0)         ; Event Generation 0 Select bit 0 mask
.equ RTC_EVGEN0SEL_0_bp = 0              ; Event Generation 0 Select bit 0 position
.equ RTC_EVGEN0SEL_1_bm = (1<<1)         ; Event Generation 0 Select bit 1 mask
.equ RTC_EVGEN0SEL_1_bp = 1              ; Event Generation 0 Select bit 1 position
.equ RTC_EVGEN0SEL_2_bm = (1<<2)         ; Event Generation 0 Select bit 2 mask
.equ RTC_EVGEN0SEL_2_bp = 2              ; Event Generation 0 Select bit 2 position
.equ RTC_EVGEN0SEL_3_bm = (1<<3)         ; Event Generation 0 Select bit 3 mask
.equ RTC_EVGEN0SEL_3_bp = 3              ; Event Generation 0 Select bit 3 position
.equ RTC_EVGEN1SEL_gm = 0xF0             ; Event Generation 1 Select group mask
.equ RTC_EVGEN1SEL_gp = 4                ; Event Generation 1 Select group position
.equ RTC_EVGEN1SEL_0_bm = (1<<4)         ; Event Generation 1 Select bit 0 mask
.equ RTC_EVGEN1SEL_0_bp = 4              ; Event Generation 1 Select bit 0 position
.equ RTC_EVGEN1SEL_1_bm = (1<<5)         ; Event Generation 1 Select bit 1 mask
.equ RTC_EVGEN1SEL_1_bp = 5              ; Event Generation 1 Select bit 1 position
.equ RTC_EVGEN1SEL_2_bm = (1<<6)         ; Event Generation 1 Select bit 2 mask
.equ RTC_EVGEN1SEL_2_bp = 6              ; Event Generation 1 Select bit 2 position
.equ RTC_EVGEN1SEL_3_bm = (1<<7)         ; Event Generation 1 Select bit 3 mask
.equ RTC_EVGEN1SEL_3_bp = 7              ; Event Generation 1 Select bit 3 position

; Clock Select
.equ RTC_CLKSEL_OSC32K_gc = (0x00<<0)    ; Internal 32.768 kHz Oscillator Divided by 32
.equ RTC_CLKSEL_OSC1K_gc = (0x01<<0)     ; 32.768 kHz Crystal Oscillator
.equ RTC_CLKSEL_XOSC32K_gc = (0x02<<0)   ; Internal 32.768 kHz Oscillator
.equ RTC_CLKSEL_EXTCLK_gc = (0x03<<0)    ; External Clock

; Prescaling Factor select
.equ RTC_PRESCALER_DIV1_gc = (0x00<<3)   ; RTC Clock / 1
.equ RTC_PRESCALER_DIV2_gc = (0x01<<3)   ; RTC Clock / 2
.equ RTC_PRESCALER_DIV4_gc = (0x02<<3)   ; RTC Clock / 4
.equ RTC_PRESCALER_DIV8_gc = (0x03<<3)   ; RTC Clock / 8
.equ RTC_PRESCALER_DIV16_gc = (0x04<<3)  ; RTC Clock / 16
.equ RTC_PRESCALER_DIV32_gc = (0x05<<3)  ; RTC Clock / 32
.equ RTC_PRESCALER_DIV64_gc = (0x06<<3)  ; RTC Clock / 64
.equ RTC_PRESCALER_DIV128_gc = (0x07<<3) ; RTC Clock / 128
.equ RTC_PRESCALER_DIV256_gc = (0x08<<3) ; RTC Clock / 256
.equ RTC_PRESCALER_DIV512_gc = (0x09<<3) ; RTC Clock / 512
.equ RTC_PRESCALER_DIV1024_gc = (0x0A<<3) ; RTC Clock / 1024
.equ RTC_PRESCALER_DIV2048_gc = (0x0B<<3) ; RTC Clock / 2048
.equ RTC_PRESCALER_DIV4096_gc = (0x0C<<3) ; RTC Clock / 4096
.equ RTC_PRESCALER_DIV8192_gc = (0x0D<<3) ; RTC Clock / 8192
.equ RTC_PRESCALER_DIV16384_gc = (0x0E<<3) ; RTC Clock / 16384
.equ RTC_PRESCALER_DIV32768_gc = (0x0F<<3) ; RTC Clock / 32768

; Period select
.equ RTC_PERIOD_OFF_gc = (0x00<<3)       ; Off
.equ RTC_PERIOD_CYC4_gc = (0x01<<3)      ; RTC Clock Cycles 4
.equ RTC_PERIOD_CYC8_gc = (0x02<<3)      ; RTC Clock Cycles 8
.equ RTC_PERIOD_CYC16_gc = (0x03<<3)     ; RTC Clock Cycles 16
.equ RTC_PERIOD_CYC32_gc = (0x04<<3)     ; RTC Clock Cycles 32
.equ RTC_PERIOD_CYC64_gc = (0x05<<3)     ; RTC Clock Cycles 64
.equ RTC_PERIOD_CYC128_gc = (0x06<<3)    ; RTC Clock Cycles 128
.equ RTC_PERIOD_CYC256_gc = (0x07<<3)    ; RTC Clock Cycles 256
.equ RTC_PERIOD_CYC512_gc = (0x08<<3)    ; RTC Clock Cycles 512
.equ RTC_PERIOD_CYC1024_gc = (0x09<<3)   ; RTC Clock Cycles 1024
.equ RTC_PERIOD_CYC2048_gc = (0x0A<<3)   ; RTC Clock Cycles 2048
.equ RTC_PERIOD_CYC4096_gc = (0x0B<<3)   ; RTC Clock Cycles 4096
.equ RTC_PERIOD_CYC8192_gc = (0x0C<<3)   ; RTC Clock Cycles 8192
.equ RTC_PERIOD_CYC16384_gc = (0x0D<<3)  ; RTC Clock Cycles 16384
.equ RTC_PERIOD_CYC32768_gc = (0x0E<<3)  ; RTC Clock Cycles 32768

; Event Generation 0 Select
.equ RTC_EVGEN0SEL_OFF_gc = (0x00<<0)    ; No Event Generated
.equ RTC_EVGEN0SEL_DIV4_gc = (0x01<<0)   ; CLK_RTC divided by 4
.equ RTC_EVGEN0SEL_DIV8_gc = (0x02<<0)   ; CLK_RTC divided by 8
.equ RTC_EVGEN0SEL_DIV16_gc = (0x03<<0)  ; CLK_RTC divided by 16
.equ RTC_EVGEN0SEL_DIV32_gc = (0x04<<0)  ; CLK_RTC divided by 32
.equ RTC_EVGEN0SEL_DIV64_gc = (0x05<<0)  ; CLK_RTC divided by 64
.equ RTC_EVGEN0SEL_DIV128_gc = (0x06<<0) ; CLK_RTC divided by 128
.equ RTC_EVGEN0SEL_DIV256_gc = (0x07<<0) ; CLK_RTC divided by 256
.equ RTC_EVGEN0SEL_DIV512_gc = (0x08<<0) ; CLK_RTC divided by 512
.equ RTC_EVGEN0SEL_DIV1024_gc = (0x09<<0) ; CLK_RTC divided by 1024
.equ RTC_EVGEN0SEL_DIV2048_gc = (0x0A<<0) ; CLK_RTC divided by 2048
.equ RTC_EVGEN0SEL_DIV4096_gc = (0x0B<<0) ; CLK_RTC divided by 4096
.equ RTC_EVGEN0SEL_DIV8192_gc = (0x0C<<0) ; CLK_RTC divided by 8192
.equ RTC_EVGEN0SEL_DIV16384_gc = (0x0D<<0) ; CLK_RTC divided by 16384
.equ RTC_EVGEN0SEL_DIV32768_gc = (0x0E<<0) ; CLK_RTC divided by 32768

; Event Generation 1 Select
.equ RTC_EVGEN1SEL_OFF_gc = (0x00<<4)    ; No Event Generated
.equ RTC_EVGEN1SEL_DIV4_gc = (0x01<<4)   ; CLK_RTC divided by 4
.equ RTC_EVGEN1SEL_DIV8_gc = (0x02<<4)   ; CLK_RTC divided by 8
.equ RTC_EVGEN1SEL_DIV16_gc = (0x03<<4)  ; CLK_RTC divided by 16
.equ RTC_EVGEN1SEL_DIV32_gc = (0x04<<4)  ; CLK_RTC divided by 32
.equ RTC_EVGEN1SEL_DIV64_gc = (0x05<<4)  ; CLK_RTC divided by 64
.equ RTC_EVGEN1SEL_DIV128_gc = (0x06<<4) ; CLK_RTC divided by 128
.equ RTC_EVGEN1SEL_DIV256_gc = (0x07<<4) ; CLK_RTC divided by 256
.equ RTC_EVGEN1SEL_DIV512_gc = (0x08<<4) ; CLK_RTC divided by 512
.equ RTC_EVGEN1SEL_DIV1024_gc = (0x09<<4) ; CLK_RTC divided by 1024
.equ RTC_EVGEN1SEL_DIV2048_gc = (0x0A<<4) ; CLK_RTC divided by 2048
.equ RTC_EVGEN1SEL_DIV4096_gc = (0x0B<<4) ; CLK_RTC divided by 4096
.equ RTC_EVGEN1SEL_DIV8192_gc = (0x0C<<4) ; CLK_RTC divided by 8192
.equ RTC_EVGEN1SEL_DIV16384_gc = (0x0D<<4) ; CLK_RTC divided by 16384
.equ RTC_EVGEN1SEL_DIV32768_gc = (0x0E<<4) ; CLK_RTC divided by 32768


;*************************************************************************
;** SIGROW - Signature row
;*************************************************************************

; SIGROW_TEMPSENSE0 masks
.equ SIGROW_TEMPSENSE0_gm = 0xFFFF       ; Temperature Calibration 0 group mask
.equ SIGROW_TEMPSENSE0_gp = 0            ; Temperature Calibration 0 group position
.equ SIGROW_TEMPSENSE0_0_bm = (1<<0)     ; Temperature Calibration 0 bit 0 mask
.equ SIGROW_TEMPSENSE0_0_bp = 0          ; Temperature Calibration 0 bit 0 position
.equ SIGROW_TEMPSENSE0_1_bm = (1<<1)     ; Temperature Calibration 0 bit 1 mask
.equ SIGROW_TEMPSENSE0_1_bp = 1          ; Temperature Calibration 0 bit 1 position
.equ SIGROW_TEMPSENSE0_2_bm = (1<<2)     ; Temperature Calibration 0 bit 2 mask
.equ SIGROW_TEMPSENSE0_2_bp = 2          ; Temperature Calibration 0 bit 2 position
.equ SIGROW_TEMPSENSE0_3_bm = (1<<3)     ; Temperature Calibration 0 bit 3 mask
.equ SIGROW_TEMPSENSE0_3_bp = 3          ; Temperature Calibration 0 bit 3 position
.equ SIGROW_TEMPSENSE0_4_bm = (1<<4)     ; Temperature Calibration 0 bit 4 mask
.equ SIGROW_TEMPSENSE0_4_bp = 4          ; Temperature Calibration 0 bit 4 position
.equ SIGROW_TEMPSENSE0_5_bm = (1<<5)     ; Temperature Calibration 0 bit 5 mask
.equ SIGROW_TEMPSENSE0_5_bp = 5          ; Temperature Calibration 0 bit 5 position
.equ SIGROW_TEMPSENSE0_6_bm = (1<<6)     ; Temperature Calibration 0 bit 6 mask
.equ SIGROW_TEMPSENSE0_6_bp = 6          ; Temperature Calibration 0 bit 6 position
.equ SIGROW_TEMPSENSE0_7_bm = (1<<7)     ; Temperature Calibration 0 bit 7 mask
.equ SIGROW_TEMPSENSE0_7_bp = 7          ; Temperature Calibration 0 bit 7 position
.equ SIGROW_TEMPSENSE0_8_bm = (1<<8)     ; Temperature Calibration 0 bit 8 mask
.equ SIGROW_TEMPSENSE0_8_bp = 8          ; Temperature Calibration 0 bit 8 position
.equ SIGROW_TEMPSENSE0_9_bm = (1<<9)     ; Temperature Calibration 0 bit 9 mask
.equ SIGROW_TEMPSENSE0_9_bp = 9          ; Temperature Calibration 0 bit 9 position
.equ SIGROW_TEMPSENSE0_10_bm = (1<<10)   ; Temperature Calibration 0 bit 10 mask
.equ SIGROW_TEMPSENSE0_10_bp = 10        ; Temperature Calibration 0 bit 10 position
.equ SIGROW_TEMPSENSE0_11_bm = (1<<11)   ; Temperature Calibration 0 bit 11 mask
.equ SIGROW_TEMPSENSE0_11_bp = 11        ; Temperature Calibration 0 bit 11 position
.equ SIGROW_TEMPSENSE0_12_bm = (1<<12)   ; Temperature Calibration 0 bit 12 mask
.equ SIGROW_TEMPSENSE0_12_bp = 12        ; Temperature Calibration 0 bit 12 position
.equ SIGROW_TEMPSENSE0_13_bm = (1<<13)   ; Temperature Calibration 0 bit 13 mask
.equ SIGROW_TEMPSENSE0_13_bp = 13        ; Temperature Calibration 0 bit 13 position
.equ SIGROW_TEMPSENSE0_14_bm = (1<<14)   ; Temperature Calibration 0 bit 14 mask
.equ SIGROW_TEMPSENSE0_14_bp = 14        ; Temperature Calibration 0 bit 14 position
.equ SIGROW_TEMPSENSE0_15_bm = (1<<15)   ; Temperature Calibration 0 bit 15 mask
.equ SIGROW_TEMPSENSE0_15_bp = 15        ; Temperature Calibration 0 bit 15 position

; SIGROW_TEMPSENSE1 masks
.equ SIGROW_TEMPSENSE1_gm = 0xFFFF       ; Temperature Calibration 1 group mask
.equ SIGROW_TEMPSENSE1_gp = 0            ; Temperature Calibration 1 group position
.equ SIGROW_TEMPSENSE1_0_bm = (1<<0)     ; Temperature Calibration 1 bit 0 mask
.equ SIGROW_TEMPSENSE1_0_bp = 0          ; Temperature Calibration 1 bit 0 position
.equ SIGROW_TEMPSENSE1_1_bm = (1<<1)     ; Temperature Calibration 1 bit 1 mask
.equ SIGROW_TEMPSENSE1_1_bp = 1          ; Temperature Calibration 1 bit 1 position
.equ SIGROW_TEMPSENSE1_2_bm = (1<<2)     ; Temperature Calibration 1 bit 2 mask
.equ SIGROW_TEMPSENSE1_2_bp = 2          ; Temperature Calibration 1 bit 2 position
.equ SIGROW_TEMPSENSE1_3_bm = (1<<3)     ; Temperature Calibration 1 bit 3 mask
.equ SIGROW_TEMPSENSE1_3_bp = 3          ; Temperature Calibration 1 bit 3 position
.equ SIGROW_TEMPSENSE1_4_bm = (1<<4)     ; Temperature Calibration 1 bit 4 mask
.equ SIGROW_TEMPSENSE1_4_bp = 4          ; Temperature Calibration 1 bit 4 position
.equ SIGROW_TEMPSENSE1_5_bm = (1<<5)     ; Temperature Calibration 1 bit 5 mask
.equ SIGROW_TEMPSENSE1_5_bp = 5          ; Temperature Calibration 1 bit 5 position
.equ SIGROW_TEMPSENSE1_6_bm = (1<<6)     ; Temperature Calibration 1 bit 6 mask
.equ SIGROW_TEMPSENSE1_6_bp = 6          ; Temperature Calibration 1 bit 6 position
.equ SIGROW_TEMPSENSE1_7_bm = (1<<7)     ; Temperature Calibration 1 bit 7 mask
.equ SIGROW_TEMPSENSE1_7_bp = 7          ; Temperature Calibration 1 bit 7 position
.equ SIGROW_TEMPSENSE1_8_bm = (1<<8)     ; Temperature Calibration 1 bit 8 mask
.equ SIGROW_TEMPSENSE1_8_bp = 8          ; Temperature Calibration 1 bit 8 position
.equ SIGROW_TEMPSENSE1_9_bm = (1<<9)     ; Temperature Calibration 1 bit 9 mask
.equ SIGROW_TEMPSENSE1_9_bp = 9          ; Temperature Calibration 1 bit 9 position
.equ SIGROW_TEMPSENSE1_10_bm = (1<<10)   ; Temperature Calibration 1 bit 10 mask
.equ SIGROW_TEMPSENSE1_10_bp = 10        ; Temperature Calibration 1 bit 10 position
.equ SIGROW_TEMPSENSE1_11_bm = (1<<11)   ; Temperature Calibration 1 bit 11 mask
.equ SIGROW_TEMPSENSE1_11_bp = 11        ; Temperature Calibration 1 bit 11 position
.equ SIGROW_TEMPSENSE1_12_bm = (1<<12)   ; Temperature Calibration 1 bit 12 mask
.equ SIGROW_TEMPSENSE1_12_bp = 12        ; Temperature Calibration 1 bit 12 position
.equ SIGROW_TEMPSENSE1_13_bm = (1<<13)   ; Temperature Calibration 1 bit 13 mask
.equ SIGROW_TEMPSENSE1_13_bp = 13        ; Temperature Calibration 1 bit 13 position
.equ SIGROW_TEMPSENSE1_14_bm = (1<<14)   ; Temperature Calibration 1 bit 14 mask
.equ SIGROW_TEMPSENSE1_14_bp = 14        ; Temperature Calibration 1 bit 14 position
.equ SIGROW_TEMPSENSE1_15_bm = (1<<15)   ; Temperature Calibration 1 bit 15 mask
.equ SIGROW_TEMPSENSE1_15_bp = 15        ; Temperature Calibration 1 bit 15 position


;*************************************************************************
;** SLPCTRL - Sleep Controller
;*************************************************************************

; SLPCTRL_CTRLA masks
.equ SLPCTRL_SEN_bm = 0x01               ; Sleep enable bit mask
.equ SLPCTRL_SEN_bp = 0                  ; Sleep enable bit position
.equ SLPCTRL_SMODE_gm = 0x06             ; Sleep mode group mask
.equ SLPCTRL_SMODE_gp = 1                ; Sleep mode group position
.equ SLPCTRL_SMODE_0_bm = (1<<1)         ; Sleep mode bit 0 mask
.equ SLPCTRL_SMODE_0_bp = 1              ; Sleep mode bit 0 position
.equ SLPCTRL_SMODE_1_bm = (1<<2)         ; Sleep mode bit 1 mask
.equ SLPCTRL_SMODE_1_bp = 2              ; Sleep mode bit 1 position

; SLPCTRL_VREGCTRL masks
.equ SLPCTRL_PMODE_gm = 0x07             ; Performance Mode group mask
.equ SLPCTRL_PMODE_gp = 0                ; Performance Mode group position
.equ SLPCTRL_PMODE_0_bm = (1<<0)         ; Performance Mode bit 0 mask
.equ SLPCTRL_PMODE_0_bp = 0              ; Performance Mode bit 0 position
.equ SLPCTRL_PMODE_1_bm = (1<<1)         ; Performance Mode bit 1 mask
.equ SLPCTRL_PMODE_1_bp = 1              ; Performance Mode bit 1 position
.equ SLPCTRL_PMODE_2_bm = (1<<2)         ; Performance Mode bit 2 mask
.equ SLPCTRL_PMODE_2_bp = 2              ; Performance Mode bit 2 position
.equ SLPCTRL_HTLLEN_bm = 0x10            ; High Temperature Low Leakage Enable bit mask
.equ SLPCTRL_HTLLEN_bp = 4               ; High Temperature Low Leakage Enable bit position

; Sleep mode select
.equ SLPCTRL_SMODE_IDLE_gc = (0x00<<1)   ; Idle mode
.equ SLPCTRL_SMODE_STDBY_gc = (0x01<<1)  ; Standby Mode
.equ SLPCTRL_SMODE_PDOWN_gc = (0x02<<1)  ; Power-down Mode

; High Temperature Low Leakage Enable select
.equ SLPCTRL_HTLLEN_OFF_gc = (0x00<<4)   ; Disabled
.equ SLPCTRL_HTLLEN_ON_gc = (0x01<<4)    ; Enabled

; Performance Mode select
.equ SLPCTRL_PMODE_AUTO_gc = (0x00<<0)   ; 
.equ SLPCTRL_PMODE_FULL_gc = (0x01<<0)   ; 


;*************************************************************************
;** SPI - Serial Peripheral Interface
;*************************************************************************

; SPI_CTRLA masks
.equ SPI_ENABLE_bm = 0x01                ; Enable Module bit mask
.equ SPI_ENABLE_bp = 0                   ; Enable Module bit position
.equ SPI_PRESC_gm = 0x06                 ; Prescaler group mask
.equ SPI_PRESC_gp = 1                    ; Prescaler group position
.equ SPI_PRESC_0_bm = (1<<1)             ; Prescaler bit 0 mask
.equ SPI_PRESC_0_bp = 1                  ; Prescaler bit 0 position
.equ SPI_PRESC_1_bm = (1<<2)             ; Prescaler bit 1 mask
.equ SPI_PRESC_1_bp = 2                  ; Prescaler bit 1 position
.equ SPI_CLK2X_bm = 0x10                 ; Enable Double Speed bit mask
.equ SPI_CLK2X_bp = 4                    ; Enable Double Speed bit position
.equ SPI_MASTER_bm = 0x20                ; Host Operation Enable bit mask
.equ SPI_MASTER_bp = 5                   ; Host Operation Enable bit position
.equ SPI_DORD_bm = 0x40                  ; Data Order Setting bit mask
.equ SPI_DORD_bp = 6                     ; Data Order Setting bit position

; SPI_CTRLB masks
.equ SPI_MODE_gm = 0x03                  ; SPI Mode group mask
.equ SPI_MODE_gp = 0                     ; SPI Mode group position
.equ SPI_MODE_0_bm = (1<<0)              ; SPI Mode bit 0 mask
.equ SPI_MODE_0_bp = 0                   ; SPI Mode bit 0 position
.equ SPI_MODE_1_bm = (1<<1)              ; SPI Mode bit 1 mask
.equ SPI_MODE_1_bp = 1                   ; SPI Mode bit 1 position
.equ SPI_SSD_bm = 0x04                   ; SPI Select Disable bit mask
.equ SPI_SSD_bp = 2                      ; SPI Select Disable bit position
.equ SPI_BUFWR_bm = 0x40                 ; Buffer Mode Wait for Receive bit mask
.equ SPI_BUFWR_bp = 6                    ; Buffer Mode Wait for Receive bit position
.equ SPI_BUFEN_bm = 0x80                 ; Buffer Mode Enable bit mask
.equ SPI_BUFEN_bp = 7                    ; Buffer Mode Enable bit position

; SPI_INTCTRL masks
.equ SPI_IE_bm = 0x01                    ; Interrupt Enable bit mask
.equ SPI_IE_bp = 0                       ; Interrupt Enable bit position
.equ SPI_SSIE_bm = 0x10                  ; SPI Select Trigger Interrupt Enable bit mask
.equ SPI_SSIE_bp = 4                     ; SPI Select Trigger Interrupt Enable bit position
.equ SPI_DREIE_bm = 0x20                 ; Data Register Empty Interrupt Enable bit mask
.equ SPI_DREIE_bp = 5                    ; Data Register Empty Interrupt Enable bit position
.equ SPI_TXCIE_bm = 0x40                 ; Transfer Complete Interrupt Enable bit mask
.equ SPI_TXCIE_bp = 6                    ; Transfer Complete Interrupt Enable bit position
.equ SPI_RXCIE_bm = 0x80                 ; Receive Complete Interrupt Enable bit mask
.equ SPI_RXCIE_bp = 7                    ; Receive Complete Interrupt Enable bit position

; SPI_INTFLAGS masks
.equ SPI_BUFOVF_bm = 0x01                ; Buffer Overflow bit mask
.equ SPI_BUFOVF_bp = 0                   ; Buffer Overflow bit position
.equ SPI_SSIF_bm = 0x10                  ; SPI Select Trigger Interrupt Flag bit mask
.equ SPI_SSIF_bp = 4                     ; SPI Select Trigger Interrupt Flag bit position
.equ SPI_DREIF_bm = 0x20                 ; Data Register Empty Interrupt Flag bit mask
.equ SPI_DREIF_bp = 5                    ; Data Register Empty Interrupt Flag bit position
.equ SPI_TXCIF_bm = 0x40                 ; Transfer Complete Interrupt Flag bit mask
.equ SPI_TXCIF_bp = 6                    ; Transfer Complete Interrupt Flag bit position
.equ SPI_WRCOL_bm = 0x40                 ; Write Collision bit mask
.equ SPI_WRCOL_bp = 6                    ; Write Collision bit position
.equ SPI_RXCIF_bm = 0x80                 ; Receive Complete Interrupt Flag bit mask
.equ SPI_RXCIF_bp = 7                    ; Receive Complete Interrupt Flag bit position
.equ SPI_IF_bm = 0x80                    ; Interrupt Flag bit mask
.equ SPI_IF_bp = 7                       ; Interrupt Flag bit position

; Prescaler select
.equ SPI_PRESC_DIV4_gc = (0x00<<1)       ; CLK_PER / 4
.equ SPI_PRESC_DIV16_gc = (0x01<<1)      ; CLK_PER / 16
.equ SPI_PRESC_DIV64_gc = (0x02<<1)      ; CLK_PER / 64
.equ SPI_PRESC_DIV128_gc = (0x03<<1)     ; CLK_PER / 128

; SPI Mode select
.equ SPI_MODE_0_gc = (0x00<<0)           ; SPI Mode 0
.equ SPI_MODE_1_gc = (0x01<<0)           ; SPI Mode 1
.equ SPI_MODE_2_gc = (0x02<<0)           ; SPI Mode 2
.equ SPI_MODE_3_gc = (0x03<<0)           ; SPI Mode 3


;*************************************************************************
;** SYSCFG - System Configuration Registers
;*************************************************************************

; SYSCFG_VUSBCTRL masks
.equ SYSCFG_USBVREG_bm = 0x01            ; USB Voltage Regulator bit mask
.equ SYSCFG_USBVREG_bp = 0               ; USB Voltage Regulator bit position

; USB Voltage Regulator select
.equ SYSCFG_USBVREG_DISABLE_gc = (0x00<<0) ; USBVREG is disabled
.equ SYSCFG_USBVREG_ENABLE_gc = (0x01<<0) ; USBVREG is enabled


;*************************************************************************
;** TCA - 16-bit Timer/Counter Type A
;*************************************************************************

; TCA_SINGLE_CTRLA masks
.equ TCA_SINGLE_ENABLE_bm = 0x01         ; Module Enable bit mask
.equ TCA_SINGLE_ENABLE_bp = 0            ; Module Enable bit position
.equ TCA_SINGLE_CLKSEL_gm = 0x0E         ; Clock Selection group mask
.equ TCA_SINGLE_CLKSEL_gp = 1            ; Clock Selection group position
.equ TCA_SINGLE_CLKSEL_0_bm = (1<<1)     ; Clock Selection bit 0 mask
.equ TCA_SINGLE_CLKSEL_0_bp = 1          ; Clock Selection bit 0 position
.equ TCA_SINGLE_CLKSEL_1_bm = (1<<2)     ; Clock Selection bit 1 mask
.equ TCA_SINGLE_CLKSEL_1_bp = 2          ; Clock Selection bit 1 position
.equ TCA_SINGLE_CLKSEL_2_bm = (1<<3)     ; Clock Selection bit 2 mask
.equ TCA_SINGLE_CLKSEL_2_bp = 3          ; Clock Selection bit 2 position
.equ TCA_SINGLE_RUNSTDBY_bm = 0x80       ; Run in Standby bit mask
.equ TCA_SINGLE_RUNSTDBY_bp = 7          ; Run in Standby bit position

; TCA_SINGLE_CTRLB masks
.equ TCA_SINGLE_WGMODE_gm = 0x07         ; Waveform generation mode group mask
.equ TCA_SINGLE_WGMODE_gp = 0            ; Waveform generation mode group position
.equ TCA_SINGLE_WGMODE_0_bm = (1<<0)     ; Waveform generation mode bit 0 mask
.equ TCA_SINGLE_WGMODE_0_bp = 0          ; Waveform generation mode bit 0 position
.equ TCA_SINGLE_WGMODE_1_bm = (1<<1)     ; Waveform generation mode bit 1 mask
.equ TCA_SINGLE_WGMODE_1_bp = 1          ; Waveform generation mode bit 1 position
.equ TCA_SINGLE_WGMODE_2_bm = (1<<2)     ; Waveform generation mode bit 2 mask
.equ TCA_SINGLE_WGMODE_2_bp = 2          ; Waveform generation mode bit 2 position
.equ TCA_SINGLE_ALUPD_bm = 0x08          ; Auto Lock Update bit mask
.equ TCA_SINGLE_ALUPD_bp = 3             ; Auto Lock Update bit position
.equ TCA_SINGLE_CMP0EN_bm = 0x10         ; Compare 0 Enable bit mask
.equ TCA_SINGLE_CMP0EN_bp = 4            ; Compare 0 Enable bit position
.equ TCA_SINGLE_CMP1EN_bm = 0x20         ; Compare 1 Enable bit mask
.equ TCA_SINGLE_CMP1EN_bp = 5            ; Compare 1 Enable bit position
.equ TCA_SINGLE_CMP2EN_bm = 0x40         ; Compare 2 Enable bit mask
.equ TCA_SINGLE_CMP2EN_bp = 6            ; Compare 2 Enable bit position

; TCA_SINGLE_CTRLC masks
.equ TCA_SINGLE_CMP0OV_bm = 0x01         ; Compare 0 Waveform Output Value bit mask
.equ TCA_SINGLE_CMP0OV_bp = 0            ; Compare 0 Waveform Output Value bit position
.equ TCA_SINGLE_CMP1OV_bm = 0x02         ; Compare 1 Waveform Output Value bit mask
.equ TCA_SINGLE_CMP1OV_bp = 1            ; Compare 1 Waveform Output Value bit position
.equ TCA_SINGLE_CMP2OV_bm = 0x04         ; Compare 2 Waveform Output Value bit mask
.equ TCA_SINGLE_CMP2OV_bp = 2            ; Compare 2 Waveform Output Value bit position

; TCA_SINGLE_CTRLD masks
.equ TCA_SINGLE_SPLITM_bm = 0x01         ; Split Mode Enable bit mask
.equ TCA_SINGLE_SPLITM_bp = 0            ; Split Mode Enable bit position

; TCA_SINGLE_CTRLECLR masks
.equ TCA_SINGLE_DIR_bm = 0x01            ; Direction bit mask
.equ TCA_SINGLE_DIR_bp = 0               ; Direction bit position
.equ TCA_SINGLE_LUPD_bm = 0x02           ; Lock Update bit mask
.equ TCA_SINGLE_LUPD_bp = 1              ; Lock Update bit position
.equ TCA_SINGLE_CMD_gm = 0x0C            ; Command group mask
.equ TCA_SINGLE_CMD_gp = 2               ; Command group position
.equ TCA_SINGLE_CMD_0_bm = (1<<2)        ; Command bit 0 mask
.equ TCA_SINGLE_CMD_0_bp = 2             ; Command bit 0 position
.equ TCA_SINGLE_CMD_1_bm = (1<<3)        ; Command bit 1 mask
.equ TCA_SINGLE_CMD_1_bp = 3             ; Command bit 1 position

; TCA_SINGLE_CTRLESET masks
; Masks for TCA_SINGLE_DIR already defined
; Masks for TCA_SINGLE_LUPD already defined
; Masks for TCA_SINGLE_CMD already defined

; TCA_SINGLE_CTRLFCLR masks
.equ TCA_SINGLE_PERBV_bm = 0x01          ; Period Buffer Valid bit mask
.equ TCA_SINGLE_PERBV_bp = 0             ; Period Buffer Valid bit position
.equ TCA_SINGLE_CMP0BV_bm = 0x02         ; Compare 0 Buffer Valid bit mask
.equ TCA_SINGLE_CMP0BV_bp = 1            ; Compare 0 Buffer Valid bit position
.equ TCA_SINGLE_CMP1BV_bm = 0x04         ; Compare 1 Buffer Valid bit mask
.equ TCA_SINGLE_CMP1BV_bp = 2            ; Compare 1 Buffer Valid bit position
.equ TCA_SINGLE_CMP2BV_bm = 0x08         ; Compare 2 Buffer Valid bit mask
.equ TCA_SINGLE_CMP2BV_bp = 3            ; Compare 2 Buffer Valid bit position

; TCA_SINGLE_CTRLFSET masks
; Masks for TCA_SINGLE_PERBV already defined
; Masks for TCA_SINGLE_CMP0BV already defined
; Masks for TCA_SINGLE_CMP1BV already defined
; Masks for TCA_SINGLE_CMP2BV already defined

; TCA_SINGLE_EVCTRL masks
.equ TCA_SINGLE_CNTAEI_bm = 0x01         ; Count on Event Input A bit mask
.equ TCA_SINGLE_CNTAEI_bp = 0            ; Count on Event Input A bit position
.equ TCA_SINGLE_EVACTA_gm = 0x0E         ; Event Action A group mask
.equ TCA_SINGLE_EVACTA_gp = 1            ; Event Action A group position
.equ TCA_SINGLE_EVACTA_0_bm = (1<<1)     ; Event Action A bit 0 mask
.equ TCA_SINGLE_EVACTA_0_bp = 1          ; Event Action A bit 0 position
.equ TCA_SINGLE_EVACTA_1_bm = (1<<2)     ; Event Action A bit 1 mask
.equ TCA_SINGLE_EVACTA_1_bp = 2          ; Event Action A bit 1 position
.equ TCA_SINGLE_EVACTA_2_bm = (1<<3)     ; Event Action A bit 2 mask
.equ TCA_SINGLE_EVACTA_2_bp = 3          ; Event Action A bit 2 position
.equ TCA_SINGLE_CNTBEI_bm = 0x10         ; Count on Event Input B bit mask
.equ TCA_SINGLE_CNTBEI_bp = 4            ; Count on Event Input B bit position
.equ TCA_SINGLE_EVACTB_gm = 0xE0         ; Event Action B group mask
.equ TCA_SINGLE_EVACTB_gp = 5            ; Event Action B group position
.equ TCA_SINGLE_EVACTB_0_bm = (1<<5)     ; Event Action B bit 0 mask
.equ TCA_SINGLE_EVACTB_0_bp = 5          ; Event Action B bit 0 position
.equ TCA_SINGLE_EVACTB_1_bm = (1<<6)     ; Event Action B bit 1 mask
.equ TCA_SINGLE_EVACTB_1_bp = 6          ; Event Action B bit 1 position
.equ TCA_SINGLE_EVACTB_2_bm = (1<<7)     ; Event Action B bit 2 mask
.equ TCA_SINGLE_EVACTB_2_bp = 7          ; Event Action B bit 2 position

; TCA_SINGLE_INTCTRL masks
.equ TCA_SINGLE_OVF_bm = 0x01            ; Overflow Interrupt bit mask
.equ TCA_SINGLE_OVF_bp = 0               ; Overflow Interrupt bit position
.equ TCA_SINGLE_CMP0_bm = 0x10           ; Compare 0 Interrupt bit mask
.equ TCA_SINGLE_CMP0_bp = 4              ; Compare 0 Interrupt bit position
.equ TCA_SINGLE_CMP1_bm = 0x20           ; Compare 1 Interrupt bit mask
.equ TCA_SINGLE_CMP1_bp = 5              ; Compare 1 Interrupt bit position
.equ TCA_SINGLE_CMP2_bm = 0x40           ; Compare 2 Interrupt bit mask
.equ TCA_SINGLE_CMP2_bp = 6              ; Compare 2 Interrupt bit position

; TCA_SINGLE_INTFLAGS masks
; Masks for TCA_SINGLE_OVF already defined
; Masks for TCA_SINGLE_CMP0 already defined
; Masks for TCA_SINGLE_CMP1 already defined
; Masks for TCA_SINGLE_CMP2 already defined

; TCA_SINGLE_DBGCTRL masks
.equ TCA_SINGLE_DBGRUN_bm = 0x01         ; Debug Run bit mask
.equ TCA_SINGLE_DBGRUN_bp = 0            ; Debug Run bit position

; Masks for CTRLA already defined
; Masks for CTRLB already defined
; Masks for CTRLC already defined
; Masks for CTRLD already defined
; Masks for CTRLECLR already defined
; Masks for CTRLESET already defined
; Masks for INTCTRL already defined
; Masks for INTFLAGS already defined
; Masks for DBGCTRL already defined
; TCA_SPLIT_CTRLA masks
.equ TCA_SPLIT_ENABLE_bm = 0x01          ; Module Enable bit mask
.equ TCA_SPLIT_ENABLE_bp = 0             ; Module Enable bit position
.equ TCA_SPLIT_CLKSEL_gm = 0x0E          ; Clock Selection group mask
.equ TCA_SPLIT_CLKSEL_gp = 1             ; Clock Selection group position
.equ TCA_SPLIT_CLKSEL_0_bm = (1<<1)      ; Clock Selection bit 0 mask
.equ TCA_SPLIT_CLKSEL_0_bp = 1           ; Clock Selection bit 0 position
.equ TCA_SPLIT_CLKSEL_1_bm = (1<<2)      ; Clock Selection bit 1 mask
.equ TCA_SPLIT_CLKSEL_1_bp = 2           ; Clock Selection bit 1 position
.equ TCA_SPLIT_CLKSEL_2_bm = (1<<3)      ; Clock Selection bit 2 mask
.equ TCA_SPLIT_CLKSEL_2_bp = 3           ; Clock Selection bit 2 position
.equ TCA_SPLIT_RUNSTDBY_bm = 0x80        ; Run in Standby bit mask
.equ TCA_SPLIT_RUNSTDBY_bp = 7           ; Run in Standby bit position

; TCA_SPLIT_CTRLB masks
.equ TCA_SPLIT_LCMP0EN_bm = 0x01         ; Low Compare 0 Enable bit mask
.equ TCA_SPLIT_LCMP0EN_bp = 0            ; Low Compare 0 Enable bit position
.equ TCA_SPLIT_LCMP1EN_bm = 0x02         ; Low Compare 1 Enable bit mask
.equ TCA_SPLIT_LCMP1EN_bp = 1            ; Low Compare 1 Enable bit position
.equ TCA_SPLIT_LCMP2EN_bm = 0x04         ; Low Compare 2 Enable bit mask
.equ TCA_SPLIT_LCMP2EN_bp = 2            ; Low Compare 2 Enable bit position
.equ TCA_SPLIT_HCMP0EN_bm = 0x10         ; High Compare 0 Enable bit mask
.equ TCA_SPLIT_HCMP0EN_bp = 4            ; High Compare 0 Enable bit position
.equ TCA_SPLIT_HCMP1EN_bm = 0x20         ; High Compare 1 Enable bit mask
.equ TCA_SPLIT_HCMP1EN_bp = 5            ; High Compare 1 Enable bit position
.equ TCA_SPLIT_HCMP2EN_bm = 0x40         ; High Compare 2 Enable bit mask
.equ TCA_SPLIT_HCMP2EN_bp = 6            ; High Compare 2 Enable bit position

; TCA_SPLIT_CTRLC masks
.equ TCA_SPLIT_LCMP0OV_bm = 0x01         ; Low Compare 0 Output Value bit mask
.equ TCA_SPLIT_LCMP0OV_bp = 0            ; Low Compare 0 Output Value bit position
.equ TCA_SPLIT_LCMP1OV_bm = 0x02         ; Low Compare 1 Output Value bit mask
.equ TCA_SPLIT_LCMP1OV_bp = 1            ; Low Compare 1 Output Value bit position
.equ TCA_SPLIT_LCMP2OV_bm = 0x04         ; Low Compare 2 Output Value bit mask
.equ TCA_SPLIT_LCMP2OV_bp = 2            ; Low Compare 2 Output Value bit position
.equ TCA_SPLIT_HCMP0OV_bm = 0x10         ; High Compare 0 Output Value bit mask
.equ TCA_SPLIT_HCMP0OV_bp = 4            ; High Compare 0 Output Value bit position
.equ TCA_SPLIT_HCMP1OV_bm = 0x20         ; High Compare 1 Output Value bit mask
.equ TCA_SPLIT_HCMP1OV_bp = 5            ; High Compare 1 Output Value bit position
.equ TCA_SPLIT_HCMP2OV_bm = 0x40         ; High Compare 2 Output Value bit mask
.equ TCA_SPLIT_HCMP2OV_bp = 6            ; High Compare 2 Output Value bit position

; TCA_SPLIT_CTRLD masks
.equ TCA_SPLIT_SPLITM_bm = 0x01          ; Split Mode Enable bit mask
.equ TCA_SPLIT_SPLITM_bp = 0             ; Split Mode Enable bit position

; TCA_SPLIT_CTRLECLR masks
.equ TCA_SPLIT_CMDEN_gm = 0x03           ; Command Enable group mask
.equ TCA_SPLIT_CMDEN_gp = 0              ; Command Enable group position
.equ TCA_SPLIT_CMDEN_0_bm = (1<<0)       ; Command Enable bit 0 mask
.equ TCA_SPLIT_CMDEN_0_bp = 0            ; Command Enable bit 0 position
.equ TCA_SPLIT_CMDEN_1_bm = (1<<1)       ; Command Enable bit 1 mask
.equ TCA_SPLIT_CMDEN_1_bp = 1            ; Command Enable bit 1 position
.equ TCA_SPLIT_CMD_gm = 0x0C             ; Command group mask
.equ TCA_SPLIT_CMD_gp = 2                ; Command group position
.equ TCA_SPLIT_CMD_0_bm = (1<<2)         ; Command bit 0 mask
.equ TCA_SPLIT_CMD_0_bp = 2              ; Command bit 0 position
.equ TCA_SPLIT_CMD_1_bm = (1<<3)         ; Command bit 1 mask
.equ TCA_SPLIT_CMD_1_bp = 3              ; Command bit 1 position

; TCA_SPLIT_CTRLESET masks
; Masks for TCA_SPLIT_CMDEN already defined
; Masks for TCA_SPLIT_CMD already defined

; TCA_SPLIT_INTCTRL masks
.equ TCA_SPLIT_LUNF_bm = 0x01            ; Low Underflow Interrupt Enable bit mask
.equ TCA_SPLIT_LUNF_bp = 0               ; Low Underflow Interrupt Enable bit position
.equ TCA_SPLIT_HUNF_bm = 0x02            ; High Underflow Interrupt Enable bit mask
.equ TCA_SPLIT_HUNF_bp = 1               ; High Underflow Interrupt Enable bit position
.equ TCA_SPLIT_LCMP0_bm = 0x10           ; Low Compare 0 Interrupt Enable bit mask
.equ TCA_SPLIT_LCMP0_bp = 4              ; Low Compare 0 Interrupt Enable bit position
.equ TCA_SPLIT_LCMP1_bm = 0x20           ; Low Compare 1 Interrupt Enable bit mask
.equ TCA_SPLIT_LCMP1_bp = 5              ; Low Compare 1 Interrupt Enable bit position
.equ TCA_SPLIT_LCMP2_bm = 0x40           ; Low Compare 2 Interrupt Enable bit mask
.equ TCA_SPLIT_LCMP2_bp = 6              ; Low Compare 2 Interrupt Enable bit position

; TCA_SPLIT_INTFLAGS masks
; Masks for TCA_SPLIT_LUNF already defined
; Masks for TCA_SPLIT_HUNF already defined
; Masks for TCA_SPLIT_LCMP0 already defined
; Masks for TCA_SPLIT_LCMP1 already defined
; Masks for TCA_SPLIT_LCMP2 already defined

; TCA_SPLIT_DBGCTRL masks
.equ TCA_SPLIT_DBGRUN_bm = 0x01          ; Debug Run bit mask
.equ TCA_SPLIT_DBGRUN_bp = 0             ; Debug Run bit position

; Clock Selection
.equ TCA_SINGLE_CLKSEL_DIV1_gc = (0x00<<1) ; CLK_PER
.equ TCA_SINGLE_CLKSEL_DIV2_gc = (0x01<<1) ; CLK_PER / 2
.equ TCA_SINGLE_CLKSEL_DIV4_gc = (0x02<<1) ; CLK_PER / 4
.equ TCA_SINGLE_CLKSEL_DIV8_gc = (0x03<<1) ; CLK_PER / 8
.equ TCA_SINGLE_CLKSEL_DIV16_gc = (0x04<<1) ; CLK_PER / 16
.equ TCA_SINGLE_CLKSEL_DIV64_gc = (0x05<<1) ; CLK_PER / 64
.equ TCA_SINGLE_CLKSEL_DIV256_gc = (0x06<<1) ; CLK_PER / 256
.equ TCA_SINGLE_CLKSEL_DIV1024_gc = (0x07<<1) ; CLK_PER / 1024

; Waveform generation mode select
.equ TCA_SINGLE_WGMODE_NORMAL_gc = (0x00<<0) ; Normal Mode
.equ TCA_SINGLE_WGMODE_FRQ_gc = (0x01<<0) ; Frequency Generation Mode
.equ TCA_SINGLE_WGMODE_SINGLESLOPE_gc = (0x03<<0) ; Single Slope PWM
.equ TCA_SINGLE_WGMODE_DSTOP_gc = (0x05<<0) ; Dual Slope PWM, overflow on TOP
.equ TCA_SINGLE_WGMODE_DSBOTH_gc = (0x06<<0) ; Dual Slope PWM, overflow on TOP and BOTTOM
.equ TCA_SINGLE_WGMODE_DSBOTTOM_gc = (0x07<<0) ; Dual Slope PWM, overflow on BOTTOM

; Command select
.equ TCA_SINGLE_CMD_NONE_gc = (0x00<<2)  ; No Command
.equ TCA_SINGLE_CMD_UPDATE_gc = (0x01<<2) ; Force Update
.equ TCA_SINGLE_CMD_RESTART_gc = (0x02<<2) ; Force Restart
.equ TCA_SINGLE_CMD_RESET_gc = (0x03<<2) ; Force Hard Reset

; Direction select
.equ TCA_SINGLE_DIR_UP_gc = (0x00<<0)    ; Count up
.equ TCA_SINGLE_DIR_DOWN_gc = (0x01<<0)  ; Count down

; Event Action A select
.equ TCA_SINGLE_EVACTA_CNT_POSEDGE_gc = (0x00<<1) ; Count on positive edge event
.equ TCA_SINGLE_EVACTA_CNT_ANYEDGE_gc = (0x01<<1) ; Count on any edge event
.equ TCA_SINGLE_EVACTA_CNT_HIGHLVL_gc = (0x02<<1) ; Count on prescaled clock while event line is 1.
.equ TCA_SINGLE_EVACTA_UPDOWN_gc = (0x03<<1) ; Count on prescaled clock. Event controls count direction. Up-count when event line is 0, down-count when event line is 1.

; Event Action B select
.equ TCA_SINGLE_EVACTB_NONE_gc = (0x00<<5) ; No Action
.equ TCA_SINGLE_EVACTB_UPDOWN_gc = (0x03<<5) ; Count on prescaled clock. Event controls count direction. Up-count when event line is 0, down-count when event line is 1.
.equ TCA_SINGLE_EVACTB_RESTART_POSEDGE_gc = (0x04<<5) ; Restart counter at positive edge event
.equ TCA_SINGLE_EVACTB_RESTART_ANYEDGE_gc = (0x05<<5) ; Restart counter on any edge event
.equ TCA_SINGLE_EVACTB_RESTART_HIGHLVL_gc = (0x06<<5) ; Restart counter while event line is 1.

; Clock Selection
.equ TCA_SPLIT_CLKSEL_DIV1_gc = (0x00<<1) ; CLK_PER
.equ TCA_SPLIT_CLKSEL_DIV2_gc = (0x01<<1) ; CLK_PER / 2
.equ TCA_SPLIT_CLKSEL_DIV4_gc = (0x02<<1) ; CLK_PER / 4
.equ TCA_SPLIT_CLKSEL_DIV8_gc = (0x03<<1) ; CLK_PER / 8
.equ TCA_SPLIT_CLKSEL_DIV16_gc = (0x04<<1) ; CLK_PER / 16
.equ TCA_SPLIT_CLKSEL_DIV64_gc = (0x05<<1) ; CLK_PER / 64
.equ TCA_SPLIT_CLKSEL_DIV256_gc = (0x06<<1) ; CLK_PER / 256
.equ TCA_SPLIT_CLKSEL_DIV1024_gc = (0x07<<1) ; CLK_PER / 1024

; Command select
.equ TCA_SPLIT_CMD_NONE_gc = (0x00<<2)   ; No Command
.equ TCA_SPLIT_CMD_UPDATE_gc = (0x01<<2) ; Force Update
.equ TCA_SPLIT_CMD_RESTART_gc = (0x02<<2) ; Force Restart
.equ TCA_SPLIT_CMD_RESET_gc = (0x03<<2)  ; Force Hard Reset

; Command Enable select
.equ TCA_SPLIT_CMDEN_NONE_gc = (0x00<<0) ; None
.equ TCA_SPLIT_CMDEN_BOTH_gc = (0x03<<0) ; Both low byte and high byte counter


;*************************************************************************
;** TCB - 16-bit Timer Type B
;*************************************************************************

; TCB_CTRLA masks
.equ TCB_ENABLE_bm = 0x01                ; Enable bit mask
.equ TCB_ENABLE_bp = 0                   ; Enable bit position
.equ TCB_CLKSEL_gm = 0x0E                ; Clock Select group mask
.equ TCB_CLKSEL_gp = 1                   ; Clock Select group position
.equ TCB_CLKSEL_0_bm = (1<<1)            ; Clock Select bit 0 mask
.equ TCB_CLKSEL_0_bp = 1                 ; Clock Select bit 0 position
.equ TCB_CLKSEL_1_bm = (1<<2)            ; Clock Select bit 1 mask
.equ TCB_CLKSEL_1_bp = 2                 ; Clock Select bit 1 position
.equ TCB_CLKSEL_2_bm = (1<<3)            ; Clock Select bit 2 mask
.equ TCB_CLKSEL_2_bp = 3                 ; Clock Select bit 2 position
.equ TCB_SYNCUPD_bm = 0x10               ; Synchronize Update bit mask
.equ TCB_SYNCUPD_bp = 4                  ; Synchronize Update bit position
.equ TCB_CASCADE_bm = 0x20               ; Cascade two timers bit mask
.equ TCB_CASCADE_bp = 5                  ; Cascade two timers bit position
.equ TCB_RUNSTDBY_bm = 0x40              ; Run Standby bit mask
.equ TCB_RUNSTDBY_bp = 6                 ; Run Standby bit position

; TCB_CTRLB masks
.equ TCB_CNTMODE_gm = 0x07               ; Timer Mode group mask
.equ TCB_CNTMODE_gp = 0                  ; Timer Mode group position
.equ TCB_CNTMODE_0_bm = (1<<0)           ; Timer Mode bit 0 mask
.equ TCB_CNTMODE_0_bp = 0                ; Timer Mode bit 0 position
.equ TCB_CNTMODE_1_bm = (1<<1)           ; Timer Mode bit 1 mask
.equ TCB_CNTMODE_1_bp = 1                ; Timer Mode bit 1 position
.equ TCB_CNTMODE_2_bm = (1<<2)           ; Timer Mode bit 2 mask
.equ TCB_CNTMODE_2_bp = 2                ; Timer Mode bit 2 position
.equ TCB_CCMPEN_bm = 0x10                ; Pin Output Enable bit mask
.equ TCB_CCMPEN_bp = 4                   ; Pin Output Enable bit position
.equ TCB_CCMPINIT_bm = 0x20              ; Pin Initial State bit mask
.equ TCB_CCMPINIT_bp = 5                 ; Pin Initial State bit position
.equ TCB_ASYNC_bm = 0x40                 ; Asynchronous Enable bit mask
.equ TCB_ASYNC_bp = 6                    ; Asynchronous Enable bit position

; TCB_EVCTRL masks
.equ TCB_CAPTEI_bm = 0x01                ; Event Input Enable bit mask
.equ TCB_CAPTEI_bp = 0                   ; Event Input Enable bit position
.equ TCB_EDGE_bm = 0x10                  ; Event Edge bit mask
.equ TCB_EDGE_bp = 4                     ; Event Edge bit position
.equ TCB_FILTER_bm = 0x40                ; Input Capture Noise Cancellation Filter bit mask
.equ TCB_FILTER_bp = 6                   ; Input Capture Noise Cancellation Filter bit position

; TCB_INTCTRL masks
.equ TCB_CAPT_bm = 0x01                  ; Capture or Timeout bit mask
.equ TCB_CAPT_bp = 0                     ; Capture or Timeout bit position
.equ TCB_OVF_bm = 0x02                   ; Overflow bit mask
.equ TCB_OVF_bp = 1                      ; Overflow bit position

; TCB_INTFLAGS masks
; Masks for TCB_CAPT already defined
; Masks for TCB_OVF already defined

; TCB_STATUS masks
.equ TCB_RUN_bm = 0x01                   ; Run bit mask
.equ TCB_RUN_bp = 0                      ; Run bit position

; TCB_DBGCTRL masks
.equ TCB_DBGRUN_bm = 0x01                ; Debug Run bit mask
.equ TCB_DBGRUN_bp = 0                   ; Debug Run bit position

; Clock Select
.equ TCB_CLKSEL_DIV1_gc = (0x00<<1)      ; CLK_PER
.equ TCB_CLKSEL_DIV2_gc = (0x01<<1)      ; CLK_PER/2
.equ TCB_CLKSEL_TCA0_gc = (0x02<<1)      ; Use CLK_TCA from TCA0
.equ TCB_CLKSEL_EVENT_gc = (0x07<<1)     ; Count on event edge

; Timer Mode select
.equ TCB_CNTMODE_INT_gc = (0x00<<0)      ; Periodic Interrupt
.equ TCB_CNTMODE_TIMEOUT_gc = (0x01<<0)  ; Periodic Timeout
.equ TCB_CNTMODE_CAPT_gc = (0x02<<0)     ; Input Capture Event
.equ TCB_CNTMODE_FRQ_gc = (0x03<<0)      ; Input Capture Frequency measurement
.equ TCB_CNTMODE_PW_gc = (0x04<<0)       ; Input Capture Pulse-Width measurement
.equ TCB_CNTMODE_FRQPW_gc = (0x05<<0)    ; Input Capture Frequency and Pulse-Width measurement
.equ TCB_CNTMODE_SINGLE_gc = (0x06<<0)   ; Single Shot
.equ TCB_CNTMODE_PWM8_gc = (0x07<<0)     ; 8-bit PWM


;*************************************************************************
;** TWI - Two-Wire Interface
;*************************************************************************

; TWI_CTRLA masks
.equ TWI_FMPEN_bm = 0x02                 ; Fast-mode Plus Enable bit mask
.equ TWI_FMPEN_bp = 1                    ; Fast-mode Plus Enable bit position
.equ TWI_SDAHOLD_gm = 0x0C               ; SDA Hold Time group mask
.equ TWI_SDAHOLD_gp = 2                  ; SDA Hold Time group position
.equ TWI_SDAHOLD_0_bm = (1<<2)           ; SDA Hold Time bit 0 mask
.equ TWI_SDAHOLD_0_bp = 2                ; SDA Hold Time bit 0 position
.equ TWI_SDAHOLD_1_bm = (1<<3)           ; SDA Hold Time bit 1 mask
.equ TWI_SDAHOLD_1_bp = 3                ; SDA Hold Time bit 1 position
.equ TWI_SDASETUP_bm = 0x10              ; SDA Setup Time bit mask
.equ TWI_SDASETUP_bp = 4                 ; SDA Setup Time bit position
.equ TWI_INPUTLVL_bm = 0x40              ; Input voltage transition level bit mask
.equ TWI_INPUTLVL_bp = 6                 ; Input voltage transition level bit position

; TWI_DBGCTRL masks
.equ TWI_DBGRUN_bm = 0x01                ; Debug Run bit mask
.equ TWI_DBGRUN_bp = 0                   ; Debug Run bit position

; TWI_MCTRLA masks
.equ TWI_ENABLE_bm = 0x01                ; Enable bit mask
.equ TWI_ENABLE_bp = 0                   ; Enable bit position
.equ TWI_SMEN_bm = 0x02                  ; Smart Mode Enable bit mask
.equ TWI_SMEN_bp = 1                     ; Smart Mode Enable bit position
.equ TWI_TIMEOUT_gm = 0x0C               ; Inactive Bus Time-Out group mask
.equ TWI_TIMEOUT_gp = 2                  ; Inactive Bus Time-Out group position
.equ TWI_TIMEOUT_0_bm = (1<<2)           ; Inactive Bus Time-Out bit 0 mask
.equ TWI_TIMEOUT_0_bp = 2                ; Inactive Bus Time-Out bit 0 position
.equ TWI_TIMEOUT_1_bm = (1<<3)           ; Inactive Bus Time-Out bit 1 mask
.equ TWI_TIMEOUT_1_bp = 3                ; Inactive Bus Time-Out bit 1 position
.equ TWI_QCEN_bm = 0x10                  ; Quick Command Enable bit mask
.equ TWI_QCEN_bp = 4                     ; Quick Command Enable bit position
.equ TWI_WIEN_bm = 0x40                  ; Write Interrupt Enable bit mask
.equ TWI_WIEN_bp = 6                     ; Write Interrupt Enable bit position
.equ TWI_RIEN_bm = 0x80                  ; Read Interrupt Enable bit mask
.equ TWI_RIEN_bp = 7                     ; Read Interrupt Enable bit position

; TWI_MCTRLB masks
.equ TWI_MCMD_gm = 0x03                  ; Command group mask
.equ TWI_MCMD_gp = 0                     ; Command group position
.equ TWI_MCMD_0_bm = (1<<0)              ; Command bit 0 mask
.equ TWI_MCMD_0_bp = 0                   ; Command bit 0 position
.equ TWI_MCMD_1_bm = (1<<1)              ; Command bit 1 mask
.equ TWI_MCMD_1_bp = 1                   ; Command bit 1 position
.equ TWI_ACKACT_bm = 0x04                ; Acknowledge Action bit mask
.equ TWI_ACKACT_bp = 2                   ; Acknowledge Action bit position
.equ TWI_FLUSH_bm = 0x08                 ; Flush bit mask
.equ TWI_FLUSH_bp = 3                    ; Flush bit position

; TWI_MSTATUS masks
.equ TWI_BUSSTATE_gm = 0x03              ; Bus State group mask
.equ TWI_BUSSTATE_gp = 0                 ; Bus State group position
.equ TWI_BUSSTATE_0_bm = (1<<0)          ; Bus State bit 0 mask
.equ TWI_BUSSTATE_0_bp = 0               ; Bus State bit 0 position
.equ TWI_BUSSTATE_1_bm = (1<<1)          ; Bus State bit 1 mask
.equ TWI_BUSSTATE_1_bp = 1               ; Bus State bit 1 position
.equ TWI_BUSERR_bm = 0x04                ; Bus Error bit mask
.equ TWI_BUSERR_bp = 2                   ; Bus Error bit position
.equ TWI_ARBLOST_bm = 0x08               ; Arbitration Lost bit mask
.equ TWI_ARBLOST_bp = 3                  ; Arbitration Lost bit position
.equ TWI_RXACK_bm = 0x10                 ; Received Acknowledge bit mask
.equ TWI_RXACK_bp = 4                    ; Received Acknowledge bit position
.equ TWI_CLKHOLD_bm = 0x20               ; Clock Hold bit mask
.equ TWI_CLKHOLD_bp = 5                  ; Clock Hold bit position
.equ TWI_WIF_bm = 0x40                   ; Write Interrupt Flag bit mask
.equ TWI_WIF_bp = 6                      ; Write Interrupt Flag bit position
.equ TWI_RIF_bm = 0x80                   ; Read Interrupt Flag bit mask
.equ TWI_RIF_bp = 7                      ; Read Interrupt Flag bit position

; TWI_MBAUD masks
.equ TWI_BAUD_gm = 0xFF                  ; Baud Rate group mask
.equ TWI_BAUD_gp = 0                     ; Baud Rate group position
.equ TWI_BAUD_0_bm = (1<<0)              ; Baud Rate bit 0 mask
.equ TWI_BAUD_0_bp = 0                   ; Baud Rate bit 0 position
.equ TWI_BAUD_1_bm = (1<<1)              ; Baud Rate bit 1 mask
.equ TWI_BAUD_1_bp = 1                   ; Baud Rate bit 1 position
.equ TWI_BAUD_2_bm = (1<<2)              ; Baud Rate bit 2 mask
.equ TWI_BAUD_2_bp = 2                   ; Baud Rate bit 2 position
.equ TWI_BAUD_3_bm = (1<<3)              ; Baud Rate bit 3 mask
.equ TWI_BAUD_3_bp = 3                   ; Baud Rate bit 3 position
.equ TWI_BAUD_4_bm = (1<<4)              ; Baud Rate bit 4 mask
.equ TWI_BAUD_4_bp = 4                   ; Baud Rate bit 4 position
.equ TWI_BAUD_5_bm = (1<<5)              ; Baud Rate bit 5 mask
.equ TWI_BAUD_5_bp = 5                   ; Baud Rate bit 5 position
.equ TWI_BAUD_6_bm = (1<<6)              ; Baud Rate bit 6 mask
.equ TWI_BAUD_6_bp = 6                   ; Baud Rate bit 6 position
.equ TWI_BAUD_7_bm = (1<<7)              ; Baud Rate bit 7 mask
.equ TWI_BAUD_7_bp = 7                   ; Baud Rate bit 7 position

; TWI_MADDR masks
.equ TWI_ADDR_gm = 0xFF                  ; Address group mask
.equ TWI_ADDR_gp = 0                     ; Address group position
.equ TWI_ADDR_0_bm = (1<<0)              ; Address bit 0 mask
.equ TWI_ADDR_0_bp = 0                   ; Address bit 0 position
.equ TWI_ADDR_1_bm = (1<<1)              ; Address bit 1 mask
.equ TWI_ADDR_1_bp = 1                   ; Address bit 1 position
.equ TWI_ADDR_2_bm = (1<<2)              ; Address bit 2 mask
.equ TWI_ADDR_2_bp = 2                   ; Address bit 2 position
.equ TWI_ADDR_3_bm = (1<<3)              ; Address bit 3 mask
.equ TWI_ADDR_3_bp = 3                   ; Address bit 3 position
.equ TWI_ADDR_4_bm = (1<<4)              ; Address bit 4 mask
.equ TWI_ADDR_4_bp = 4                   ; Address bit 4 position
.equ TWI_ADDR_5_bm = (1<<5)              ; Address bit 5 mask
.equ TWI_ADDR_5_bp = 5                   ; Address bit 5 position
.equ TWI_ADDR_6_bm = (1<<6)              ; Address bit 6 mask
.equ TWI_ADDR_6_bp = 6                   ; Address bit 6 position
.equ TWI_ADDR_7_bm = (1<<7)              ; Address bit 7 mask
.equ TWI_ADDR_7_bp = 7                   ; Address bit 7 position

; TWI_MDATA masks
.equ TWI_DATA_gm = 0xFF                  ; Data group mask
.equ TWI_DATA_gp = 0                     ; Data group position
.equ TWI_DATA_0_bm = (1<<0)              ; Data bit 0 mask
.equ TWI_DATA_0_bp = 0                   ; Data bit 0 position
.equ TWI_DATA_1_bm = (1<<1)              ; Data bit 1 mask
.equ TWI_DATA_1_bp = 1                   ; Data bit 1 position
.equ TWI_DATA_2_bm = (1<<2)              ; Data bit 2 mask
.equ TWI_DATA_2_bp = 2                   ; Data bit 2 position
.equ TWI_DATA_3_bm = (1<<3)              ; Data bit 3 mask
.equ TWI_DATA_3_bp = 3                   ; Data bit 3 position
.equ TWI_DATA_4_bm = (1<<4)              ; Data bit 4 mask
.equ TWI_DATA_4_bp = 4                   ; Data bit 4 position
.equ TWI_DATA_5_bm = (1<<5)              ; Data bit 5 mask
.equ TWI_DATA_5_bp = 5                   ; Data bit 5 position
.equ TWI_DATA_6_bm = (1<<6)              ; Data bit 6 mask
.equ TWI_DATA_6_bp = 6                   ; Data bit 6 position
.equ TWI_DATA_7_bm = (1<<7)              ; Data bit 7 mask
.equ TWI_DATA_7_bp = 7                   ; Data bit 7 position

; TWI_SCTRLA masks
; Masks for TWI_ENABLE already defined
; Masks for TWI_SMEN already defined
.equ TWI_PMEN_bm = 0x04                  ; Address Recognition Mode bit mask
.equ TWI_PMEN_bp = 2                     ; Address Recognition Mode bit position
.equ TWI_PIEN_bm = 0x20                  ; Stop Interrupt Enable bit mask
.equ TWI_PIEN_bp = 5                     ; Stop Interrupt Enable bit position
.equ TWI_APIEN_bm = 0x40                 ; Address or Stop Interrupt Enable bit mask
.equ TWI_APIEN_bp = 6                    ; Address or Stop Interrupt Enable bit position
.equ TWI_DIEN_bm = 0x80                  ; Data Interrupt Enable bit mask
.equ TWI_DIEN_bp = 7                     ; Data Interrupt Enable bit position

; TWI_SCTRLB masks
.equ TWI_SCMD_gm = 0x03                  ; Command group mask
.equ TWI_SCMD_gp = 0                     ; Command group position
.equ TWI_SCMD_0_bm = (1<<0)              ; Command bit 0 mask
.equ TWI_SCMD_0_bp = 0                   ; Command bit 0 position
.equ TWI_SCMD_1_bm = (1<<1)              ; Command bit 1 mask
.equ TWI_SCMD_1_bp = 1                   ; Command bit 1 position
; Masks for TWI_ACKACT already defined

; TWI_SSTATUS masks
.equ TWI_AP_bm = 0x01                    ; Address or Stop bit mask
.equ TWI_AP_bp = 0                       ; Address or Stop bit position
.equ TWI_DIR_bm = 0x02                   ; Read/Write Direction bit mask
.equ TWI_DIR_bp = 1                      ; Read/Write Direction bit position
; Masks for TWI_BUSERR already defined
.equ TWI_COLL_bm = 0x08                  ; Collision bit mask
.equ TWI_COLL_bp = 3                     ; Collision bit position
; Masks for TWI_RXACK already defined
; Masks for TWI_CLKHOLD already defined
.equ TWI_APIF_bm = 0x40                  ; Address or Stop Interrupt Flag bit mask
.equ TWI_APIF_bp = 6                     ; Address or Stop Interrupt Flag bit position
.equ TWI_DIF_bm = 0x80                   ; Data Interrupt Flag bit mask
.equ TWI_DIF_bp = 7                      ; Data Interrupt Flag bit position

; TWI_SADDR masks
; Masks for TWI_ADDR already defined

; TWI_SDATA masks
; Masks for TWI_DATA already defined

; TWI_SADDRMASK masks
.equ TWI_ADDREN_bm = 0x01                ; Address Mask Enable bit mask
.equ TWI_ADDREN_bp = 0                   ; Address Mask Enable bit position
.equ TWI_ADDRMASK_gm = 0xFE              ; Address Mask group mask
.equ TWI_ADDRMASK_gp = 1                 ; Address Mask group position
.equ TWI_ADDRMASK_0_bm = (1<<1)          ; Address Mask bit 0 mask
.equ TWI_ADDRMASK_0_bp = 1               ; Address Mask bit 0 position
.equ TWI_ADDRMASK_1_bm = (1<<2)          ; Address Mask bit 1 mask
.equ TWI_ADDRMASK_1_bp = 2               ; Address Mask bit 1 position
.equ TWI_ADDRMASK_2_bm = (1<<3)          ; Address Mask bit 2 mask
.equ TWI_ADDRMASK_2_bp = 3               ; Address Mask bit 2 position
.equ TWI_ADDRMASK_3_bm = (1<<4)          ; Address Mask bit 3 mask
.equ TWI_ADDRMASK_3_bp = 4               ; Address Mask bit 3 position
.equ TWI_ADDRMASK_4_bm = (1<<5)          ; Address Mask bit 4 mask
.equ TWI_ADDRMASK_4_bp = 5               ; Address Mask bit 4 position
.equ TWI_ADDRMASK_5_bm = (1<<6)          ; Address Mask bit 5 mask
.equ TWI_ADDRMASK_5_bp = 6               ; Address Mask bit 5 position
.equ TWI_ADDRMASK_6_bm = (1<<7)          ; Address Mask bit 6 mask
.equ TWI_ADDRMASK_6_bp = 7               ; Address Mask bit 6 position

; Fast-mode Plus Enable select
.equ TWI_FMPEN_OFF_gc = (0x00<<1)        ; Operating in Standard-mode or Fast-mode
.equ TWI_FMPEN_ON_gc = (0x01<<1)         ; Operating in Fast-mode Plus

; Input voltage transition level select
.equ TWI_INPUTLVL_I2C_gc = (0x00<<6)     ; I2C input voltage transition level
.equ TWI_INPUTLVL_SMBUS_gc = (0x01<<6)   ; SMBus 3.0 input voltage transition level

; SDA Hold Time select
.equ TWI_SDAHOLD_OFF_gc = (0x00<<2)      ; No SDA Hold Delay
.equ TWI_SDAHOLD_50NS_gc = (0x01<<2)     ; Short SDA hold time
.equ TWI_SDAHOLD_300NS_gc = (0x02<<2)    ; Meets SMBUS 2.0 specification under typical conditions
.equ TWI_SDAHOLD_500NS_gc = (0x03<<2)    ; Meets SMBUS 2.0 specificaiton across all corners

; SDA Setup Time select
.equ TWI_SDASETUP_4CYC_gc = (0x00<<4)    ; SDA setup time is four clock cycles
.equ TWI_SDASETUP_8CYC_gc = (0x01<<4)    ; SDA setup time is eight clock cycle

; Debug Run select
.equ TWI_DBGRUN_HALT_gc = (0x00<<0)      ; The peripheral is halted in Break Debug mode and ignores events
.equ TWI_DBGRUN_RUN_gc = (0x01<<0)       ; The peripheral will continue to run in Break Debug mode when the CPU is halted

; Inactive Bus Time-Out select
.equ TWI_TIMEOUT_DISABLED_gc = (0x00<<2) ; Bus time-out disabled. I2C.
.equ TWI_TIMEOUT_50US_gc = (0x01<<2)     ; 50us - SMBus
.equ TWI_TIMEOUT_100US_gc = (0x02<<2)    ; 100us
.equ TWI_TIMEOUT_200US_gc = (0x03<<2)    ; 200us

; Acknowledge Action select
.equ TWI_ACKACT_ACK_gc = (0x00<<2)       ; Send ACK
.equ TWI_ACKACT_NACK_gc = (0x01<<2)      ; Send NACK

; Command select
.equ TWI_MCMD_NOACT_gc = (0x00<<0)       ; No action
.equ TWI_MCMD_REPSTART_gc = (0x01<<0)    ; Execute Acknowledge Action followed by repeated Start.
.equ TWI_MCMD_RECVTRANS_gc = (0x02<<0)   ; Execute Acknowledge Action followed by a byte read/write operation. Read/write is defined by DIR.
.equ TWI_MCMD_STOP_gc = (0x03<<0)        ; Execute Acknowledge Action followed by issuing a Stop condition.

; Bus State select
.equ TWI_BUSSTATE_UNKNOWN_gc = (0x00<<0) ; Unknown bus state
.equ TWI_BUSSTATE_IDLE_gc = (0x01<<0)    ; Bus is idle
.equ TWI_BUSSTATE_OWNER_gc = (0x02<<0)   ; This TWI controls the bus
.equ TWI_BUSSTATE_BUSY_gc = (0x03<<0)    ; The bus is busy

; Command select
.equ TWI_SCMD_NOACT_gc = (0x00<<0)       ; No Action
.equ TWI_SCMD_COMPTRANS_gc = (0x02<<0)   ; Complete transaction
.equ TWI_SCMD_RESPONSE_gc = (0x03<<0)    ; Used in response to an interrupt

; Address or Stop select
.equ TWI_AP_STOP_gc = (0x00<<0)          ; A Stop condition generated the interrupt on APIF flag
.equ TWI_AP_ADR_gc = (0x01<<0)           ; Address detection generated the interrupt on APIF flag


;*************************************************************************
;** USART - Universal Synchronous and Asynchronous Receiver and Transmitter
;*************************************************************************

; USART_RXDATAL masks
.equ USART_DATA_gm = 0xFF                ; RX Data group mask
.equ USART_DATA_gp = 0                   ; RX Data group position
.equ USART_DATA_0_bm = (1<<0)            ; RX Data bit 0 mask
.equ USART_DATA_0_bp = 0                 ; RX Data bit 0 position
.equ USART_DATA_1_bm = (1<<1)            ; RX Data bit 1 mask
.equ USART_DATA_1_bp = 1                 ; RX Data bit 1 position
.equ USART_DATA_2_bm = (1<<2)            ; RX Data bit 2 mask
.equ USART_DATA_2_bp = 2                 ; RX Data bit 2 position
.equ USART_DATA_3_bm = (1<<3)            ; RX Data bit 3 mask
.equ USART_DATA_3_bp = 3                 ; RX Data bit 3 position
.equ USART_DATA_4_bm = (1<<4)            ; RX Data bit 4 mask
.equ USART_DATA_4_bp = 4                 ; RX Data bit 4 position
.equ USART_DATA_5_bm = (1<<5)            ; RX Data bit 5 mask
.equ USART_DATA_5_bp = 5                 ; RX Data bit 5 position
.equ USART_DATA_6_bm = (1<<6)            ; RX Data bit 6 mask
.equ USART_DATA_6_bp = 6                 ; RX Data bit 6 position
.equ USART_DATA_7_bm = (1<<7)            ; RX Data bit 7 mask
.equ USART_DATA_7_bp = 7                 ; RX Data bit 7 position

; USART_RXDATAH masks
.equ USART_DATA8_bm = 0x01               ; Receiver Data Register bit mask
.equ USART_DATA8_bp = 0                  ; Receiver Data Register bit position
.equ USART_PERR_bm = 0x02                ; Parity Error bit mask
.equ USART_PERR_bp = 1                   ; Parity Error bit position
.equ USART_FERR_bm = 0x04                ; Frame Error bit mask
.equ USART_FERR_bp = 2                   ; Frame Error bit position
.equ USART_BUFOVF_bm = 0x40              ; Buffer Overflow bit mask
.equ USART_BUFOVF_bp = 6                 ; Buffer Overflow bit position
.equ USART_RXCIF_bm = 0x80               ; Receive Complete Interrupt Flag bit mask
.equ USART_RXCIF_bp = 7                  ; Receive Complete Interrupt Flag bit position

; USART_TXDATAL masks
; Masks for USART_DATA already defined

; USART_TXDATAH masks
; Masks for USART_DATA8 already defined

; USART_STATUS masks
.equ USART_WFB_bm = 0x01                 ; Wait For Break bit mask
.equ USART_WFB_bp = 0                    ; Wait For Break bit position
.equ USART_BDF_bm = 0x02                 ; Break Detected Flag bit mask
.equ USART_BDF_bp = 1                    ; Break Detected Flag bit position
.equ USART_ISFIF_bm = 0x08               ; Inconsistent Sync Field Interrupt Flag bit mask
.equ USART_ISFIF_bp = 3                  ; Inconsistent Sync Field Interrupt Flag bit position
.equ USART_RXSIF_bm = 0x10               ; Receive Start Interrupt bit mask
.equ USART_RXSIF_bp = 4                  ; Receive Start Interrupt bit position
.equ USART_DREIF_bm = 0x20               ; Data Register Empty Flag bit mask
.equ USART_DREIF_bp = 5                  ; Data Register Empty Flag bit position
.equ USART_TXCIF_bm = 0x40               ; Transmit Interrupt Flag bit mask
.equ USART_TXCIF_bp = 6                  ; Transmit Interrupt Flag bit position
; Masks for USART_RXCIF already defined

; USART_CTRLA masks
.equ USART_RS485_bm = 0x01               ; RS485 Mode internal transmitter bit mask
.equ USART_RS485_bp = 0                  ; RS485 Mode internal transmitter bit position
.equ USART_ABEIE_bm = 0x04               ; Auto-baud Error Interrupt Enable bit mask
.equ USART_ABEIE_bp = 2                  ; Auto-baud Error Interrupt Enable bit position
.equ USART_LBME_bm = 0x08                ; Loop-back Mode Enable bit mask
.equ USART_LBME_bp = 3                   ; Loop-back Mode Enable bit position
.equ USART_RXSIE_bm = 0x10               ; Receiver Start Frame Interrupt Enable bit mask
.equ USART_RXSIE_bp = 4                  ; Receiver Start Frame Interrupt Enable bit position
.equ USART_DREIE_bm = 0x20               ; Data Register Empty Interrupt Enable bit mask
.equ USART_DREIE_bp = 5                  ; Data Register Empty Interrupt Enable bit position
.equ USART_TXCIE_bm = 0x40               ; Transmit Complete Interrupt Enable bit mask
.equ USART_TXCIE_bp = 6                  ; Transmit Complete Interrupt Enable bit position
.equ USART_RXCIE_bm = 0x80               ; Receive Complete Interrupt Enable bit mask
.equ USART_RXCIE_bp = 7                  ; Receive Complete Interrupt Enable bit position

; USART_CTRLB masks
.equ USART_MPCM_bm = 0x01                ; Multi-processor Communication Mode bit mask
.equ USART_MPCM_bp = 0                   ; Multi-processor Communication Mode bit position
.equ USART_RXMODE_gm = 0x06              ; Receiver Mode group mask
.equ USART_RXMODE_gp = 1                 ; Receiver Mode group position
.equ USART_RXMODE_0_bm = (1<<1)          ; Receiver Mode bit 0 mask
.equ USART_RXMODE_0_bp = 1               ; Receiver Mode bit 0 position
.equ USART_RXMODE_1_bm = (1<<2)          ; Receiver Mode bit 1 mask
.equ USART_RXMODE_1_bp = 2               ; Receiver Mode bit 1 position
.equ USART_ODME_bm = 0x08                ; Open Drain Mode Enable bit mask
.equ USART_ODME_bp = 3                   ; Open Drain Mode Enable bit position
.equ USART_SFDEN_bm = 0x10               ; Start Frame Detection Enable bit mask
.equ USART_SFDEN_bp = 4                  ; Start Frame Detection Enable bit position
.equ USART_TXEN_bm = 0x40                ; Transmitter Enable bit mask
.equ USART_TXEN_bp = 6                   ; Transmitter Enable bit position
.equ USART_RXEN_bm = 0x80                ; Reciever enable bit mask
.equ USART_RXEN_bp = 7                   ; Reciever enable bit position

; USART_CTRLC masks
.equ USART_UCPHA_bm = 0x02               ; SPI Host Mode, Clock Phase bit mask
.equ USART_UCPHA_bp = 1                  ; SPI Host Mode, Clock Phase bit position
.equ USART_UDORD_bm = 0x04               ; SPI Host Mode, Data Order bit mask
.equ USART_UDORD_bp = 2                  ; SPI Host Mode, Data Order bit position
.equ USART_CHSIZE_gm = 0x07              ; Character Size group mask
.equ USART_CHSIZE_gp = 0                 ; Character Size group position
.equ USART_CHSIZE_0_bm = (1<<0)          ; Character Size bit 0 mask
.equ USART_CHSIZE_0_bp = 0               ; Character Size bit 0 position
.equ USART_CHSIZE_1_bm = (1<<1)          ; Character Size bit 1 mask
.equ USART_CHSIZE_1_bp = 1               ; Character Size bit 1 position
.equ USART_CHSIZE_2_bm = (1<<2)          ; Character Size bit 2 mask
.equ USART_CHSIZE_2_bp = 2               ; Character Size bit 2 position
.equ USART_SBMODE_bm = 0x08              ; Stop Bit Mode bit mask
.equ USART_SBMODE_bp = 3                 ; Stop Bit Mode bit position
.equ USART_PMODE_gm = 0x30               ; Parity Mode group mask
.equ USART_PMODE_gp = 4                  ; Parity Mode group position
.equ USART_PMODE_0_bm = (1<<4)           ; Parity Mode bit 0 mask
.equ USART_PMODE_0_bp = 4                ; Parity Mode bit 0 position
.equ USART_PMODE_1_bm = (1<<5)           ; Parity Mode bit 1 mask
.equ USART_PMODE_1_bp = 5                ; Parity Mode bit 1 position
.equ USART_CMODE_gm = 0xC0               ; Communication Mode group mask
.equ USART_CMODE_gp = 6                  ; Communication Mode group position
.equ USART_CMODE_0_bm = (1<<6)           ; Communication Mode bit 0 mask
.equ USART_CMODE_0_bp = 6                ; Communication Mode bit 0 position
.equ USART_CMODE_1_bm = (1<<7)           ; Communication Mode bit 1 mask
.equ USART_CMODE_1_bp = 7                ; Communication Mode bit 1 position

; USART_CTRLD masks
.equ USART_ABW_gm = 0xC0                 ; Auto Baud Window group mask
.equ USART_ABW_gp = 6                    ; Auto Baud Window group position
.equ USART_ABW_0_bm = (1<<6)             ; Auto Baud Window bit 0 mask
.equ USART_ABW_0_bp = 6                  ; Auto Baud Window bit 0 position
.equ USART_ABW_1_bm = (1<<7)             ; Auto Baud Window bit 1 mask
.equ USART_ABW_1_bp = 7                  ; Auto Baud Window bit 1 position

; USART_DBGCTRL masks
.equ USART_DBGRUN_bm = 0x01              ; Debug Run bit mask
.equ USART_DBGRUN_bp = 0                 ; Debug Run bit position

; USART_EVCTRL masks
.equ USART_IREI_bm = 0x01                ; IrDA Event Input Enable bit mask
.equ USART_IREI_bp = 0                   ; IrDA Event Input Enable bit position

; USART_TXPLCTRL masks
.equ USART_TXPL_gm = 0xFF                ; Transmit pulse length group mask
.equ USART_TXPL_gp = 0                   ; Transmit pulse length group position
.equ USART_TXPL_0_bm = (1<<0)            ; Transmit pulse length bit 0 mask
.equ USART_TXPL_0_bp = 0                 ; Transmit pulse length bit 0 position
.equ USART_TXPL_1_bm = (1<<1)            ; Transmit pulse length bit 1 mask
.equ USART_TXPL_1_bp = 1                 ; Transmit pulse length bit 1 position
.equ USART_TXPL_2_bm = (1<<2)            ; Transmit pulse length bit 2 mask
.equ USART_TXPL_2_bp = 2                 ; Transmit pulse length bit 2 position
.equ USART_TXPL_3_bm = (1<<3)            ; Transmit pulse length bit 3 mask
.equ USART_TXPL_3_bp = 3                 ; Transmit pulse length bit 3 position
.equ USART_TXPL_4_bm = (1<<4)            ; Transmit pulse length bit 4 mask
.equ USART_TXPL_4_bp = 4                 ; Transmit pulse length bit 4 position
.equ USART_TXPL_5_bm = (1<<5)            ; Transmit pulse length bit 5 mask
.equ USART_TXPL_5_bp = 5                 ; Transmit pulse length bit 5 position
.equ USART_TXPL_6_bm = (1<<6)            ; Transmit pulse length bit 6 mask
.equ USART_TXPL_6_bp = 6                 ; Transmit pulse length bit 6 position
.equ USART_TXPL_7_bm = (1<<7)            ; Transmit pulse length bit 7 mask
.equ USART_TXPL_7_bp = 7                 ; Transmit pulse length bit 7 position

; USART_RXPLCTRL masks
.equ USART_RXPL_gm = 0x7F                ; Receiver Pulse Lenght group mask
.equ USART_RXPL_gp = 0                   ; Receiver Pulse Lenght group position
.equ USART_RXPL_0_bm = (1<<0)            ; Receiver Pulse Lenght bit 0 mask
.equ USART_RXPL_0_bp = 0                 ; Receiver Pulse Lenght bit 0 position
.equ USART_RXPL_1_bm = (1<<1)            ; Receiver Pulse Lenght bit 1 mask
.equ USART_RXPL_1_bp = 1                 ; Receiver Pulse Lenght bit 1 position
.equ USART_RXPL_2_bm = (1<<2)            ; Receiver Pulse Lenght bit 2 mask
.equ USART_RXPL_2_bp = 2                 ; Receiver Pulse Lenght bit 2 position
.equ USART_RXPL_3_bm = (1<<3)            ; Receiver Pulse Lenght bit 3 mask
.equ USART_RXPL_3_bp = 3                 ; Receiver Pulse Lenght bit 3 position
.equ USART_RXPL_4_bm = (1<<4)            ; Receiver Pulse Lenght bit 4 mask
.equ USART_RXPL_4_bp = 4                 ; Receiver Pulse Lenght bit 4 position
.equ USART_RXPL_5_bm = (1<<5)            ; Receiver Pulse Lenght bit 5 mask
.equ USART_RXPL_5_bp = 5                 ; Receiver Pulse Lenght bit 5 position
.equ USART_RXPL_6_bm = (1<<6)            ; Receiver Pulse Lenght bit 6 mask
.equ USART_RXPL_6_bp = 6                 ; Receiver Pulse Lenght bit 6 position

; RS485 Mode internal transmitter select
.equ USART_RS485_DISABLE_gc = (0x00<<0)  ; RS485 Mode disabled
.equ USART_RS485_ENABLE_gc = (0x01<<0)   ; RS485 Mode enabled

; Receiver Mode select
.equ USART_RXMODE_NORMAL_gc = (0x00<<1)  ; Normal mode
.equ USART_RXMODE_CLK2X_gc = (0x01<<1)   ; CLK2x mode
.equ USART_RXMODE_GENAUTO_gc = (0x02<<1) ; Generic autobaud mode
.equ USART_RXMODE_LINAUTO_gc = (0x03<<1) ; LIN constrained autobaud mode

; Communication Mode select
.equ USART_CMODE_ASYNCHRONOUS_gc = (0x00<<6) ; Asynchronous Mode
.equ USART_CMODE_SYNCHRONOUS_gc = (0x01<<6) ; Synchronous Mode
.equ USART_CMODE_IRCOM_gc = (0x02<<6)    ; Infrared Communication
.equ USART_CMODE_MSPI_gc = (0x03<<6)     ; SPI Host Mode

; Character Size select
.equ USART_NORMAL_CHSIZE_5BIT_gc = (0x00<<0) ; Character size: 5 bit
.equ USART_NORMAL_CHSIZE_6BIT_gc = (0x01<<0) ; Character size: 6 bit
.equ USART_NORMAL_CHSIZE_7BIT_gc = (0x02<<0) ; Character size: 7 bit
.equ USART_NORMAL_CHSIZE_8BIT_gc = (0x03<<0) ; Character size: 8 bit
.equ USART_NORMAL_CHSIZE_9BITL_gc = (0x06<<0) ; Character size: 9 bit read low byte first
.equ USART_NORMAL_CHSIZE_9BITH_gc = (0x07<<0) ; Character size: 9 bit read high byte first

; Parity Mode select
.equ USART_NORMAL_PMODE_DISABLED_gc = (0x00<<4) ; No Parity
.equ USART_NORMAL_PMODE_EVEN_gc = (0x02<<4) ; Even Parity
.equ USART_NORMAL_PMODE_ODD_gc = (0x03<<4) ; Odd Parity

; Stop Bit Mode select
.equ USART_NORMAL_SBMODE_1BIT_gc = (0x00<<3) ; 1 stop bit
.equ USART_NORMAL_SBMODE_2BIT_gc = (0x01<<3) ; 2 stop bits

; Auto Baud Window select
.equ USART_ABW_WDW0_gc = (0x00<<6)       ; 18% tolerance
.equ USART_ABW_WDW1_gc = (0x01<<6)       ; 15% tolerance
.equ USART_ABW_WDW2_gc = (0x02<<6)       ; 21% tolerance
.equ USART_ABW_WDW3_gc = (0x03<<6)       ; 25% tolerance


;*************************************************************************
;** USB - USB Device Controller
;*************************************************************************

; USB_EP_STATUS masks
.equ USB_EP_TOGGLE_bm = 0x01             ; Data Toggle bit mask
.equ USB_EP_TOGGLE_bp = 0                ; Data Toggle bit position
.equ USB_EP_BUSNAK_bm = 0x02             ; Data Buffer NAK bit mask
.equ USB_EP_BUSNAK_bp = 1                ; Data Buffer NAK bit position
.equ USB_EP_STALLED_bm = 0x08            ; EP Stalled bit mask
.equ USB_EP_STALLED_bp = 3               ; EP Stalled bit position
.equ USB_EP_EPSETUP_bm = 0x10            ; EP Setup Complete bit mask
.equ USB_EP_EPSETUP_bp = 4               ; EP Setup Complete bit position
.equ USB_EP_TRNCOMPL_bm = 0x20           ; Transaction Complete bit mask
.equ USB_EP_TRNCOMPL_bp = 5              ; Transaction Complete bit position
.equ USB_EP_UNFOVF_bm = 0x40             ; Underflow/Overflow EP bit mask
.equ USB_EP_UNFOVF_bp = 6                ; Underflow/Overflow EP bit position
.equ USB_EP_CRC_bm = 0x80                ; CRC Error bit mask
.equ USB_EP_CRC_bp = 7                   ; CRC Error bit position

; USB_EP_CTRL masks
.equ USB_EP_BUFSIZE_DEFAULT_gm = 0x03    ; Data Size default group mask
.equ USB_EP_BUFSIZE_DEFAULT_gp = 0       ; Data Size default group position
.equ USB_EP_BUFSIZE_DEFAULT_0_bm = (1<<0) ; Data Size default bit 0 mask
.equ USB_EP_BUFSIZE_DEFAULT_0_bp = 0     ; Data Size default bit 0 position
.equ USB_EP_BUFSIZE_DEFAULT_1_bm = (1<<1) ; Data Size default bit 1 mask
.equ USB_EP_BUFSIZE_DEFAULT_1_bp = 1     ; Data Size default bit 1 position
.equ USB_EP_DOSTALL_bm = 0x04            ; Endpoint will respond with STALL bit mask
.equ USB_EP_DOSTALL_bp = 2               ; Endpoint will respond with STALL bit position
.equ USB_EP_BUFSIZE_ISO_gm = 0x07        ; Data Size isochronous group mask
.equ USB_EP_BUFSIZE_ISO_gp = 0           ; Data Size isochronous group position
.equ USB_EP_BUFSIZE_ISO_0_bm = (1<<0)    ; Data Size isochronous bit 0 mask
.equ USB_EP_BUFSIZE_ISO_0_bp = 0         ; Data Size isochronous bit 0 position
.equ USB_EP_BUFSIZE_ISO_1_bm = (1<<1)    ; Data Size isochronous bit 1 mask
.equ USB_EP_BUFSIZE_ISO_1_bp = 1         ; Data Size isochronous bit 1 position
.equ USB_EP_BUFSIZE_ISO_2_bm = (1<<2)    ; Data Size isochronous bit 2 mask
.equ USB_EP_BUFSIZE_ISO_2_bp = 2         ; Data Size isochronous bit 2 position
.equ USB_EP_TCDSBL_bm = 0x08             ; TRNCOMPL Interrupt Disable bit mask
.equ USB_EP_TCDSBL_bp = 3                ; TRNCOMPL Interrupt Disable bit position
.equ USB_EP_AZLP_bm = 0x10               ; Automatic zero length packet bit mask
.equ USB_EP_AZLP_bp = 4                  ; Automatic zero length packet bit position
.equ USB_EP_MULTIPKT_bm = 0x20           ; Multipacket transfer enable bit mask
.equ USB_EP_MULTIPKT_bp = 5              ; Multipacket transfer enable bit position
.equ USB_EP_TYPE_gm = 0xC0               ; Endpoint type group mask
.equ USB_EP_TYPE_gp = 6                  ; Endpoint type group position
.equ USB_EP_TYPE_0_bm = (1<<6)           ; Endpoint type bit 0 mask
.equ USB_EP_TYPE_0_bp = 6                ; Endpoint type bit 0 position
.equ USB_EP_TYPE_1_bm = (1<<7)           ; Endpoint type bit 1 mask
.equ USB_EP_TYPE_1_bp = 7                ; Endpoint type bit 1 position

; USB_EP_CNT masks
.equ USB_EP_CNT_gm = 0xFFFF              ; Endpoint Byte Count group mask
.equ USB_EP_CNT_gp = 0                   ; Endpoint Byte Count group position
.equ USB_EP_CNT_0_bm = (1<<0)            ; Endpoint Byte Count bit 0 mask
.equ USB_EP_CNT_0_bp = 0                 ; Endpoint Byte Count bit 0 position
.equ USB_EP_CNT_1_bm = (1<<1)            ; Endpoint Byte Count bit 1 mask
.equ USB_EP_CNT_1_bp = 1                 ; Endpoint Byte Count bit 1 position
.equ USB_EP_CNT_2_bm = (1<<2)            ; Endpoint Byte Count bit 2 mask
.equ USB_EP_CNT_2_bp = 2                 ; Endpoint Byte Count bit 2 position
.equ USB_EP_CNT_3_bm = (1<<3)            ; Endpoint Byte Count bit 3 mask
.equ USB_EP_CNT_3_bp = 3                 ; Endpoint Byte Count bit 3 position
.equ USB_EP_CNT_4_bm = (1<<4)            ; Endpoint Byte Count bit 4 mask
.equ USB_EP_CNT_4_bp = 4                 ; Endpoint Byte Count bit 4 position
.equ USB_EP_CNT_5_bm = (1<<5)            ; Endpoint Byte Count bit 5 mask
.equ USB_EP_CNT_5_bp = 5                 ; Endpoint Byte Count bit 5 position
.equ USB_EP_CNT_6_bm = (1<<6)            ; Endpoint Byte Count bit 6 mask
.equ USB_EP_CNT_6_bp = 6                 ; Endpoint Byte Count bit 6 position
.equ USB_EP_CNT_7_bm = (1<<7)            ; Endpoint Byte Count bit 7 mask
.equ USB_EP_CNT_7_bp = 7                 ; Endpoint Byte Count bit 7 position
.equ USB_EP_CNT_8_bm = (1<<8)            ; Endpoint Byte Count bit 8 mask
.equ USB_EP_CNT_8_bp = 8                 ; Endpoint Byte Count bit 8 position
.equ USB_EP_CNT_9_bm = (1<<9)            ; Endpoint Byte Count bit 9 mask
.equ USB_EP_CNT_9_bp = 9                 ; Endpoint Byte Count bit 9 position
.equ USB_EP_CNT_10_bm = (1<<10)          ; Endpoint Byte Count bit 10 mask
.equ USB_EP_CNT_10_bp = 10               ; Endpoint Byte Count bit 10 position
.equ USB_EP_CNT_11_bm = (1<<11)          ; Endpoint Byte Count bit 11 mask
.equ USB_EP_CNT_11_bp = 11               ; Endpoint Byte Count bit 11 position
.equ USB_EP_CNT_12_bm = (1<<12)          ; Endpoint Byte Count bit 12 mask
.equ USB_EP_CNT_12_bp = 12               ; Endpoint Byte Count bit 12 position
.equ USB_EP_CNT_13_bm = (1<<13)          ; Endpoint Byte Count bit 13 mask
.equ USB_EP_CNT_13_bp = 13               ; Endpoint Byte Count bit 13 position
.equ USB_EP_CNT_14_bm = (1<<14)          ; Endpoint Byte Count bit 14 mask
.equ USB_EP_CNT_14_bp = 14               ; Endpoint Byte Count bit 14 position
.equ USB_EP_CNT_15_bm = (1<<15)          ; Endpoint Byte Count bit 15 mask
.equ USB_EP_CNT_15_bp = 15               ; Endpoint Byte Count bit 15 position

; USB_EP_DATAPTR masks
.equ USB_EP_DATAPTR_gm = 0xFFFF          ; Endpoint data pointer group mask
.equ USB_EP_DATAPTR_gp = 0               ; Endpoint data pointer group position
.equ USB_EP_DATAPTR_0_bm = (1<<0)        ; Endpoint data pointer bit 0 mask
.equ USB_EP_DATAPTR_0_bp = 0             ; Endpoint data pointer bit 0 position
.equ USB_EP_DATAPTR_1_bm = (1<<1)        ; Endpoint data pointer bit 1 mask
.equ USB_EP_DATAPTR_1_bp = 1             ; Endpoint data pointer bit 1 position
.equ USB_EP_DATAPTR_2_bm = (1<<2)        ; Endpoint data pointer bit 2 mask
.equ USB_EP_DATAPTR_2_bp = 2             ; Endpoint data pointer bit 2 position
.equ USB_EP_DATAPTR_3_bm = (1<<3)        ; Endpoint data pointer bit 3 mask
.equ USB_EP_DATAPTR_3_bp = 3             ; Endpoint data pointer bit 3 position
.equ USB_EP_DATAPTR_4_bm = (1<<4)        ; Endpoint data pointer bit 4 mask
.equ USB_EP_DATAPTR_4_bp = 4             ; Endpoint data pointer bit 4 position
.equ USB_EP_DATAPTR_5_bm = (1<<5)        ; Endpoint data pointer bit 5 mask
.equ USB_EP_DATAPTR_5_bp = 5             ; Endpoint data pointer bit 5 position
.equ USB_EP_DATAPTR_6_bm = (1<<6)        ; Endpoint data pointer bit 6 mask
.equ USB_EP_DATAPTR_6_bp = 6             ; Endpoint data pointer bit 6 position
.equ USB_EP_DATAPTR_7_bm = (1<<7)        ; Endpoint data pointer bit 7 mask
.equ USB_EP_DATAPTR_7_bp = 7             ; Endpoint data pointer bit 7 position
.equ USB_EP_DATAPTR_8_bm = (1<<8)        ; Endpoint data pointer bit 8 mask
.equ USB_EP_DATAPTR_8_bp = 8             ; Endpoint data pointer bit 8 position
.equ USB_EP_DATAPTR_9_bm = (1<<9)        ; Endpoint data pointer bit 9 mask
.equ USB_EP_DATAPTR_9_bp = 9             ; Endpoint data pointer bit 9 position
.equ USB_EP_DATAPTR_10_bm = (1<<10)      ; Endpoint data pointer bit 10 mask
.equ USB_EP_DATAPTR_10_bp = 10           ; Endpoint data pointer bit 10 position
.equ USB_EP_DATAPTR_11_bm = (1<<11)      ; Endpoint data pointer bit 11 mask
.equ USB_EP_DATAPTR_11_bp = 11           ; Endpoint data pointer bit 11 position
.equ USB_EP_DATAPTR_12_bm = (1<<12)      ; Endpoint data pointer bit 12 mask
.equ USB_EP_DATAPTR_12_bp = 12           ; Endpoint data pointer bit 12 position
.equ USB_EP_DATAPTR_13_bm = (1<<13)      ; Endpoint data pointer bit 13 mask
.equ USB_EP_DATAPTR_13_bp = 13           ; Endpoint data pointer bit 13 position
.equ USB_EP_DATAPTR_14_bm = (1<<14)      ; Endpoint data pointer bit 14 mask
.equ USB_EP_DATAPTR_14_bp = 14           ; Endpoint data pointer bit 14 position
.equ USB_EP_DATAPTR_15_bm = (1<<15)      ; Endpoint data pointer bit 15 mask
.equ USB_EP_DATAPTR_15_bp = 15           ; Endpoint data pointer bit 15 position

; USB_EP_MCNT masks
.equ USB_EP_MCNT_gm = 0xFFFF             ; Multi-packet byte count group mask
.equ USB_EP_MCNT_gp = 0                  ; Multi-packet byte count group position
.equ USB_EP_MCNT_0_bm = (1<<0)           ; Multi-packet byte count bit 0 mask
.equ USB_EP_MCNT_0_bp = 0                ; Multi-packet byte count bit 0 position
.equ USB_EP_MCNT_1_bm = (1<<1)           ; Multi-packet byte count bit 1 mask
.equ USB_EP_MCNT_1_bp = 1                ; Multi-packet byte count bit 1 position
.equ USB_EP_MCNT_2_bm = (1<<2)           ; Multi-packet byte count bit 2 mask
.equ USB_EP_MCNT_2_bp = 2                ; Multi-packet byte count bit 2 position
.equ USB_EP_MCNT_3_bm = (1<<3)           ; Multi-packet byte count bit 3 mask
.equ USB_EP_MCNT_3_bp = 3                ; Multi-packet byte count bit 3 position
.equ USB_EP_MCNT_4_bm = (1<<4)           ; Multi-packet byte count bit 4 mask
.equ USB_EP_MCNT_4_bp = 4                ; Multi-packet byte count bit 4 position
.equ USB_EP_MCNT_5_bm = (1<<5)           ; Multi-packet byte count bit 5 mask
.equ USB_EP_MCNT_5_bp = 5                ; Multi-packet byte count bit 5 position
.equ USB_EP_MCNT_6_bm = (1<<6)           ; Multi-packet byte count bit 6 mask
.equ USB_EP_MCNT_6_bp = 6                ; Multi-packet byte count bit 6 position
.equ USB_EP_MCNT_7_bm = (1<<7)           ; Multi-packet byte count bit 7 mask
.equ USB_EP_MCNT_7_bp = 7                ; Multi-packet byte count bit 7 position
.equ USB_EP_MCNT_8_bm = (1<<8)           ; Multi-packet byte count bit 8 mask
.equ USB_EP_MCNT_8_bp = 8                ; Multi-packet byte count bit 8 position
.equ USB_EP_MCNT_9_bm = (1<<9)           ; Multi-packet byte count bit 9 mask
.equ USB_EP_MCNT_9_bp = 9                ; Multi-packet byte count bit 9 position
.equ USB_EP_MCNT_10_bm = (1<<10)         ; Multi-packet byte count bit 10 mask
.equ USB_EP_MCNT_10_bp = 10              ; Multi-packet byte count bit 10 position
.equ USB_EP_MCNT_11_bm = (1<<11)         ; Multi-packet byte count bit 11 mask
.equ USB_EP_MCNT_11_bp = 11              ; Multi-packet byte count bit 11 position
.equ USB_EP_MCNT_12_bm = (1<<12)         ; Multi-packet byte count bit 12 mask
.equ USB_EP_MCNT_12_bp = 12              ; Multi-packet byte count bit 12 position
.equ USB_EP_MCNT_13_bm = (1<<13)         ; Multi-packet byte count bit 13 mask
.equ USB_EP_MCNT_13_bp = 13              ; Multi-packet byte count bit 13 position
.equ USB_EP_MCNT_14_bm = (1<<14)         ; Multi-packet byte count bit 14 mask
.equ USB_EP_MCNT_14_bp = 14              ; Multi-packet byte count bit 14 position
.equ USB_EP_MCNT_15_bm = (1<<15)         ; Multi-packet byte count bit 15 mask
.equ USB_EP_MCNT_15_bp = 15              ; Multi-packet byte count bit 15 position

; USB_EP_TABLE_FIFO masks
.equ USB_EP_TABLE_DIR_bm = 0x08          ; Endpoint Direction bit mask
.equ USB_EP_TABLE_DIR_bp = 3             ; Endpoint Direction bit position
.equ USB_EP_TABLE_EPNUM_gm = 0xF0        ; Endpoint Number group mask
.equ USB_EP_TABLE_EPNUM_gp = 4           ; Endpoint Number group position
.equ USB_EP_TABLE_EPNUM_0_bm = (1<<4)    ; Endpoint Number bit 0 mask
.equ USB_EP_TABLE_EPNUM_0_bp = 4         ; Endpoint Number bit 0 position
.equ USB_EP_TABLE_EPNUM_1_bm = (1<<5)    ; Endpoint Number bit 1 mask
.equ USB_EP_TABLE_EPNUM_1_bp = 5         ; Endpoint Number bit 1 position
.equ USB_EP_TABLE_EPNUM_2_bm = (1<<6)    ; Endpoint Number bit 2 mask
.equ USB_EP_TABLE_EPNUM_2_bp = 6         ; Endpoint Number bit 2 position
.equ USB_EP_TABLE_EPNUM_3_bm = (1<<7)    ; Endpoint Number bit 3 mask
.equ USB_EP_TABLE_EPNUM_3_bp = 7         ; Endpoint Number bit 3 position

; USB_EP_TABLE_FRAMENUM masks
.equ USB_EP_TABLE_FRAMENUM_gm = 0x7FF    ; Frame Number group mask
.equ USB_EP_TABLE_FRAMENUM_gp = 0        ; Frame Number group position
.equ USB_EP_TABLE_FRAMENUM_0_bm = (1<<0) ; Frame Number bit 0 mask
.equ USB_EP_TABLE_FRAMENUM_0_bp = 0      ; Frame Number bit 0 position
.equ USB_EP_TABLE_FRAMENUM_1_bm = (1<<1) ; Frame Number bit 1 mask
.equ USB_EP_TABLE_FRAMENUM_1_bp = 1      ; Frame Number bit 1 position
.equ USB_EP_TABLE_FRAMENUM_2_bm = (1<<2) ; Frame Number bit 2 mask
.equ USB_EP_TABLE_FRAMENUM_2_bp = 2      ; Frame Number bit 2 position
.equ USB_EP_TABLE_FRAMENUM_3_bm = (1<<3) ; Frame Number bit 3 mask
.equ USB_EP_TABLE_FRAMENUM_3_bp = 3      ; Frame Number bit 3 position
.equ USB_EP_TABLE_FRAMENUM_4_bm = (1<<4) ; Frame Number bit 4 mask
.equ USB_EP_TABLE_FRAMENUM_4_bp = 4      ; Frame Number bit 4 position
.equ USB_EP_TABLE_FRAMENUM_5_bm = (1<<5) ; Frame Number bit 5 mask
.equ USB_EP_TABLE_FRAMENUM_5_bp = 5      ; Frame Number bit 5 position
.equ USB_EP_TABLE_FRAMENUM_6_bm = (1<<6) ; Frame Number bit 6 mask
.equ USB_EP_TABLE_FRAMENUM_6_bp = 6      ; Frame Number bit 6 position
.equ USB_EP_TABLE_FRAMENUM_7_bm = (1<<7) ; Frame Number bit 7 mask
.equ USB_EP_TABLE_FRAMENUM_7_bp = 7      ; Frame Number bit 7 position
.equ USB_EP_TABLE_FRAMENUM_8_bm = (1<<8) ; Frame Number bit 8 mask
.equ USB_EP_TABLE_FRAMENUM_8_bp = 8      ; Frame Number bit 8 position
.equ USB_EP_TABLE_FRAMENUM_9_bm = (1<<9) ; Frame Number bit 9 mask
.equ USB_EP_TABLE_FRAMENUM_9_bp = 9      ; Frame Number bit 9 position
.equ USB_EP_TABLE_FRAMENUM_10_bm = (1<<10) ; Frame Number bit 10 mask
.equ USB_EP_TABLE_FRAMENUM_10_bp = 10    ; Frame Number bit 10 position
.equ USB_EP_TABLE_FRAMEERR_bm = 0x8000   ; Frame Error bit mask
.equ USB_EP_TABLE_FRAMEERR_bp = 15       ; Frame Error bit position

; USB_STATUS_OUTCLR masks
.equ USB_STATUS_RMWSTATUS_gm = 0xFF      ; Read-Modify-Write Endpoint STATUS group mask
.equ USB_STATUS_RMWSTATUS_gp = 0         ; Read-Modify-Write Endpoint STATUS group position
.equ USB_STATUS_RMWSTATUS_0_bm = (1<<0)  ; Read-Modify-Write Endpoint STATUS bit 0 mask
.equ USB_STATUS_RMWSTATUS_0_bp = 0       ; Read-Modify-Write Endpoint STATUS bit 0 position
.equ USB_STATUS_RMWSTATUS_1_bm = (1<<1)  ; Read-Modify-Write Endpoint STATUS bit 1 mask
.equ USB_STATUS_RMWSTATUS_1_bp = 1       ; Read-Modify-Write Endpoint STATUS bit 1 position
.equ USB_STATUS_RMWSTATUS_2_bm = (1<<2)  ; Read-Modify-Write Endpoint STATUS bit 2 mask
.equ USB_STATUS_RMWSTATUS_2_bp = 2       ; Read-Modify-Write Endpoint STATUS bit 2 position
.equ USB_STATUS_RMWSTATUS_3_bm = (1<<3)  ; Read-Modify-Write Endpoint STATUS bit 3 mask
.equ USB_STATUS_RMWSTATUS_3_bp = 3       ; Read-Modify-Write Endpoint STATUS bit 3 position
.equ USB_STATUS_RMWSTATUS_4_bm = (1<<4)  ; Read-Modify-Write Endpoint STATUS bit 4 mask
.equ USB_STATUS_RMWSTATUS_4_bp = 4       ; Read-Modify-Write Endpoint STATUS bit 4 position
.equ USB_STATUS_RMWSTATUS_5_bm = (1<<5)  ; Read-Modify-Write Endpoint STATUS bit 5 mask
.equ USB_STATUS_RMWSTATUS_5_bp = 5       ; Read-Modify-Write Endpoint STATUS bit 5 position
.equ USB_STATUS_RMWSTATUS_6_bm = (1<<6)  ; Read-Modify-Write Endpoint STATUS bit 6 mask
.equ USB_STATUS_RMWSTATUS_6_bp = 6       ; Read-Modify-Write Endpoint STATUS bit 6 position
.equ USB_STATUS_RMWSTATUS_7_bm = (1<<7)  ; Read-Modify-Write Endpoint STATUS bit 7 mask
.equ USB_STATUS_RMWSTATUS_7_bp = 7       ; Read-Modify-Write Endpoint STATUS bit 7 position

; USB_STATUS_OUTSET masks
; Masks for USB_STATUS_RMWSTATUS already defined

; USB_STATUS_INCLR masks
; Masks for USB_STATUS_RMWSTATUS already defined

; USB_STATUS_INSET masks
; Masks for USB_STATUS_RMWSTATUS already defined

; USB_CTRLA masks
.equ USB_MAXEP_gm = 0x0F                 ; Maximum Endpoint Address group mask
.equ USB_MAXEP_gp = 0                    ; Maximum Endpoint Address group position
.equ USB_MAXEP_0_bm = (1<<0)             ; Maximum Endpoint Address bit 0 mask
.equ USB_MAXEP_0_bp = 0                  ; Maximum Endpoint Address bit 0 position
.equ USB_MAXEP_1_bm = (1<<1)             ; Maximum Endpoint Address bit 1 mask
.equ USB_MAXEP_1_bp = 1                  ; Maximum Endpoint Address bit 1 position
.equ USB_MAXEP_2_bm = (1<<2)             ; Maximum Endpoint Address bit 2 mask
.equ USB_MAXEP_2_bp = 2                  ; Maximum Endpoint Address bit 2 position
.equ USB_MAXEP_3_bm = (1<<3)             ; Maximum Endpoint Address bit 3 mask
.equ USB_MAXEP_3_bp = 3                  ; Maximum Endpoint Address bit 3 position
.equ USB_STFRNUM_bm = 0x10               ; Store Frame Number Enable bit mask
.equ USB_STFRNUM_bp = 4                  ; Store Frame Number Enable bit position
.equ USB_FIFOEN_bm = 0x20                ; Transaction Complete FIFO Enable bit mask
.equ USB_FIFOEN_bp = 5                   ; Transaction Complete FIFO Enable bit position
.equ USB_ENABLE_bm = 0x80                ; USB Enable bit mask
.equ USB_ENABLE_bp = 7                   ; USB Enable bit position

; USB_CTRLB masks
.equ USB_ATTACH_bm = 0x01                ; Attach bit mask
.equ USB_ATTACH_bp = 0                   ; Attach bit position
.equ USB_GNAK_bm = 0x02                  ; Respond with NAK on all Endpoints bit mask
.equ USB_GNAK_bp = 1                     ; Respond with NAK on all Endpoints bit position
.equ USB_GNAUTO_bm = 0x04                ; Set GNAK Automatically after SETUP bit mask
.equ USB_GNAUTO_bp = 2                   ; Set GNAK Automatically after SETUP bit position
.equ USB_URESUME_bm = 0x08               ; Send Upstream Resume bit mask
.equ USB_URESUME_bp = 3                  ; Send Upstream Resume bit position

; USB_BUSSTATE masks
.equ USB_BUSRST_bm = 0x01                ; Bus Reset bit mask
.equ USB_BUSRST_bp = 0                   ; Bus Reset bit position
.equ USB_SUSPENDED_bm = 0x02             ; Bus Suspended bit mask
.equ USB_SUSPENDED_bp = 1                ; Bus Suspended bit position
.equ USB_DRESUME_bm = 0x04               ; Downstram Resume bit mask
.equ USB_DRESUME_bp = 2                  ; Downstram Resume bit position
; Masks for USB_URESUME already defined
.equ USB_WTRSM_bm = 0x10                 ; Wait Time Resume bit mask
.equ USB_WTRSM_bp = 4                    ; Wait Time Resume bit position

; USB_ADDR masks
.equ USB_ADDR_gm = 0x7F                  ; Device Address group mask
.equ USB_ADDR_gp = 0                     ; Device Address group position
.equ USB_ADDR_0_bm = (1<<0)              ; Device Address bit 0 mask
.equ USB_ADDR_0_bp = 0                   ; Device Address bit 0 position
.equ USB_ADDR_1_bm = (1<<1)              ; Device Address bit 1 mask
.equ USB_ADDR_1_bp = 1                   ; Device Address bit 1 position
.equ USB_ADDR_2_bm = (1<<2)              ; Device Address bit 2 mask
.equ USB_ADDR_2_bp = 2                   ; Device Address bit 2 position
.equ USB_ADDR_3_bm = (1<<3)              ; Device Address bit 3 mask
.equ USB_ADDR_3_bp = 3                   ; Device Address bit 3 position
.equ USB_ADDR_4_bm = (1<<4)              ; Device Address bit 4 mask
.equ USB_ADDR_4_bp = 4                   ; Device Address bit 4 position
.equ USB_ADDR_5_bm = (1<<5)              ; Device Address bit 5 mask
.equ USB_ADDR_5_bp = 5                   ; Device Address bit 5 position
.equ USB_ADDR_6_bm = (1<<6)              ; Device Address bit 6 mask
.equ USB_ADDR_6_bp = 6                   ; Device Address bit 6 position

; USB_FIFOWP masks
.equ USB_FIFOWP_gm = 0x1F                ; FIFO Write Pointer group mask
.equ USB_FIFOWP_gp = 0                   ; FIFO Write Pointer group position
.equ USB_FIFOWP_0_bm = (1<<0)            ; FIFO Write Pointer bit 0 mask
.equ USB_FIFOWP_0_bp = 0                 ; FIFO Write Pointer bit 0 position
.equ USB_FIFOWP_1_bm = (1<<1)            ; FIFO Write Pointer bit 1 mask
.equ USB_FIFOWP_1_bp = 1                 ; FIFO Write Pointer bit 1 position
.equ USB_FIFOWP_2_bm = (1<<2)            ; FIFO Write Pointer bit 2 mask
.equ USB_FIFOWP_2_bp = 2                 ; FIFO Write Pointer bit 2 position
.equ USB_FIFOWP_3_bm = (1<<3)            ; FIFO Write Pointer bit 3 mask
.equ USB_FIFOWP_3_bp = 3                 ; FIFO Write Pointer bit 3 position
.equ USB_FIFOWP_4_bm = (1<<4)            ; FIFO Write Pointer bit 4 mask
.equ USB_FIFOWP_4_bp = 4                 ; FIFO Write Pointer bit 4 position

; USB_FIFORP masks
.equ USB_FIFORP_gm = 0x1F                ; FIFO Read Pointer group mask
.equ USB_FIFORP_gp = 0                   ; FIFO Read Pointer group position
.equ USB_FIFORP_0_bm = (1<<0)            ; FIFO Read Pointer bit 0 mask
.equ USB_FIFORP_0_bp = 0                 ; FIFO Read Pointer bit 0 position
.equ USB_FIFORP_1_bm = (1<<1)            ; FIFO Read Pointer bit 1 mask
.equ USB_FIFORP_1_bp = 1                 ; FIFO Read Pointer bit 1 position
.equ USB_FIFORP_2_bm = (1<<2)            ; FIFO Read Pointer bit 2 mask
.equ USB_FIFORP_2_bp = 2                 ; FIFO Read Pointer bit 2 position
.equ USB_FIFORP_3_bm = (1<<3)            ; FIFO Read Pointer bit 3 mask
.equ USB_FIFORP_3_bp = 3                 ; FIFO Read Pointer bit 3 position
.equ USB_FIFORP_4_bm = (1<<4)            ; FIFO Read Pointer bit 4 mask
.equ USB_FIFORP_4_bp = 4                 ; FIFO Read Pointer bit 4 position

; USB_EPPTR masks
.equ USB_EPPTR_gm = 0xFFFF               ; Endpoint Configuration Table Pointer group mask
.equ USB_EPPTR_gp = 0                    ; Endpoint Configuration Table Pointer group position
.equ USB_EPPTR_0_bm = (1<<0)             ; Endpoint Configuration Table Pointer bit 0 mask
.equ USB_EPPTR_0_bp = 0                  ; Endpoint Configuration Table Pointer bit 0 position
.equ USB_EPPTR_1_bm = (1<<1)             ; Endpoint Configuration Table Pointer bit 1 mask
.equ USB_EPPTR_1_bp = 1                  ; Endpoint Configuration Table Pointer bit 1 position
.equ USB_EPPTR_2_bm = (1<<2)             ; Endpoint Configuration Table Pointer bit 2 mask
.equ USB_EPPTR_2_bp = 2                  ; Endpoint Configuration Table Pointer bit 2 position
.equ USB_EPPTR_3_bm = (1<<3)             ; Endpoint Configuration Table Pointer bit 3 mask
.equ USB_EPPTR_3_bp = 3                  ; Endpoint Configuration Table Pointer bit 3 position
.equ USB_EPPTR_4_bm = (1<<4)             ; Endpoint Configuration Table Pointer bit 4 mask
.equ USB_EPPTR_4_bp = 4                  ; Endpoint Configuration Table Pointer bit 4 position
.equ USB_EPPTR_5_bm = (1<<5)             ; Endpoint Configuration Table Pointer bit 5 mask
.equ USB_EPPTR_5_bp = 5                  ; Endpoint Configuration Table Pointer bit 5 position
.equ USB_EPPTR_6_bm = (1<<6)             ; Endpoint Configuration Table Pointer bit 6 mask
.equ USB_EPPTR_6_bp = 6                  ; Endpoint Configuration Table Pointer bit 6 position
.equ USB_EPPTR_7_bm = (1<<7)             ; Endpoint Configuration Table Pointer bit 7 mask
.equ USB_EPPTR_7_bp = 7                  ; Endpoint Configuration Table Pointer bit 7 position
.equ USB_EPPTR_8_bm = (1<<8)             ; Endpoint Configuration Table Pointer bit 8 mask
.equ USB_EPPTR_8_bp = 8                  ; Endpoint Configuration Table Pointer bit 8 position
.equ USB_EPPTR_9_bm = (1<<9)             ; Endpoint Configuration Table Pointer bit 9 mask
.equ USB_EPPTR_9_bp = 9                  ; Endpoint Configuration Table Pointer bit 9 position
.equ USB_EPPTR_10_bm = (1<<10)           ; Endpoint Configuration Table Pointer bit 10 mask
.equ USB_EPPTR_10_bp = 10                ; Endpoint Configuration Table Pointer bit 10 position
.equ USB_EPPTR_11_bm = (1<<11)           ; Endpoint Configuration Table Pointer bit 11 mask
.equ USB_EPPTR_11_bp = 11                ; Endpoint Configuration Table Pointer bit 11 position
.equ USB_EPPTR_12_bm = (1<<12)           ; Endpoint Configuration Table Pointer bit 12 mask
.equ USB_EPPTR_12_bp = 12                ; Endpoint Configuration Table Pointer bit 12 position
.equ USB_EPPTR_13_bm = (1<<13)           ; Endpoint Configuration Table Pointer bit 13 mask
.equ USB_EPPTR_13_bp = 13                ; Endpoint Configuration Table Pointer bit 13 position
.equ USB_EPPTR_14_bm = (1<<14)           ; Endpoint Configuration Table Pointer bit 14 mask
.equ USB_EPPTR_14_bp = 14                ; Endpoint Configuration Table Pointer bit 14 position
.equ USB_EPPTR_15_bm = (1<<15)           ; Endpoint Configuration Table Pointer bit 15 mask
.equ USB_EPPTR_15_bp = 15                ; Endpoint Configuration Table Pointer bit 15 position

; USB_INTCTRLA masks
.equ USB_OVF_bm = 0x02                   ; Overflow Interrupt Enable bit mask
.equ USB_OVF_bp = 1                      ; Overflow Interrupt Enable bit position
.equ USB_UNF_bm = 0x04                   ; Underflow Interrupt Enable bit mask
.equ USB_UNF_bp = 2                      ; Underflow Interrupt Enable bit position
.equ USB_STALLED_bm = 0x08               ; STALL Interrupt Enable bit mask
.equ USB_STALLED_bp = 3                  ; STALL Interrupt Enable bit position
.equ USB_RESET_bm = 0x10                 ; Reset Interrupt Enable bit mask
.equ USB_RESET_bp = 4                    ; Reset Interrupt Enable bit position
.equ USB_RESUME_bm = 0x20                ; Resume Interrupt Enable bit mask
.equ USB_RESUME_bp = 5                   ; Resume Interrupt Enable bit position
.equ USB_SUSPEND_bm = 0x40               ; Suspend Interrupt Enable bit mask
.equ USB_SUSPEND_bp = 6                  ; Suspend Interrupt Enable bit position
.equ USB_SOF_bm = 0x80                   ; Start Of Frame Interrupt Enable bit mask
.equ USB_SOF_bp = 7                      ; Start Of Frame Interrupt Enable bit position

; USB_INTCTRLB masks
.equ USB_SETUP_bm = 0x01                 ; SETUP Transaction Complete Interrupt Enable bit mask
.equ USB_SETUP_bp = 0                    ; SETUP Transaction Complete Interrupt Enable bit position
.equ USB_GNDONE_bm = 0x02                ; GNAK Operation Done Interrupt Enable bit mask
.equ USB_GNDONE_bp = 1                   ; GNAK Operation Done Interrupt Enable bit position
.equ USB_TRNCOMPL_bm = 0x20              ; Transaction Complete Interrupt Enable bit mask
.equ USB_TRNCOMPL_bp = 5                 ; Transaction Complete Interrupt Enable bit position

; USB_INTFLAGSA masks
; Masks for USB_OVF already defined
; Masks for USB_UNF already defined
; Masks for USB_STALLED already defined
; Masks for USB_RESET already defined
; Masks for USB_RESUME already defined
; Masks for USB_SUSPEND already defined
; Masks for USB_SOF already defined

; USB_INTFLAGSB masks
; Masks for USB_SETUP already defined
; Masks for USB_GNDONE already defined
.equ USB_RMWBUSY_bm = 0x04               ; RMW Busy Flag bit mask
.equ USB_RMWBUSY_bp = 2                  ; RMW Busy Flag bit position
; Masks for USB_TRNCOMPL already defined

; Data Size default select
.equ USB_EP_DEFAULT_BUFSIZE_BUF8_gc = (0x00<<0) ; 8 bytes buffer size
.equ USB_EP_DEFAULT_BUFSIZE_BUF16_gc = (0x01<<0) ; 16 bytes buffer size
.equ USB_EP_DEFAULT_BUFSIZE_BUF32_gc = (0x02<<0) ; 32 bytes buffer size
.equ USB_EP_DEFAULT_BUFSIZE_BUF64_gc = (0x03<<0) ; 64 bytes buffer size

; Endpoint type select
.equ USB_EP_TYPE_DISABLE_gc = (0x00<<6)  ; Endpoint Disabled
.equ USB_EP_TYPE_CONTROL_gc = (0x01<<6)  ; Control
.equ USB_EP_TYPE_BULKINT_gc = (0x02<<6)  ; Bulk or Interrupt
.equ USB_EP_TYPE_ISO_gc = (0x03<<6)      ; Isochronous

; Data Size isochronous select
.equ USB_EP_ISO_BUFSIZE_BUF8_gc = (0x00<<0) ; 8 bytes buffer size
.equ USB_EP_ISO_BUFSIZE_BUF16_gc = (0x01<<0) ; 16 bytes buffer size
.equ USB_EP_ISO_BUFSIZE_BUF32_gc = (0x02<<0) ; 32 bytes buffer size
.equ USB_EP_ISO_BUFSIZE_BUF64_gc = (0x03<<0) ; 64 bytes buffer size
.equ USB_EP_ISO_BUFSIZE_BUF128_gc = (0x04<<0) ; 128 bytes buffer size
.equ USB_EP_ISO_BUFSIZE_BUF256_gc = (0x05<<0) ; 256 bytes buffer size
.equ USB_EP_ISO_BUFSIZE_BUF512_gc = (0x06<<0) ; 512 bytes buffer size
.equ USB_EP_ISO_BUFSIZE_BUF1023_gc = (0x07<<0) ; 1023 bytes buffer size

; Endpoint Direction select
.equ USB_EP_TABLE_DIR_OUT_gc = (0x00<<3) ; OUT Endpoint
.equ USB_EP_TABLE_DIR_IN_gc = (0x01<<3)  ; In Endpoint

; Data Toggle select
.equ USB_EP_DEFAULT_TOGGLE_DATA0_gc = (0x00<<0) ; DATA0 PID in next transaction
.equ USB_EP_DEFAULT_TOGGLE_DATA1_gc = (0x01<<0) ; DATA1 PID in next transaction


;*************************************************************************
;** USERROW - User Row
;*************************************************************************


;*************************************************************************
;** VPORT - Virtual Ports
;*************************************************************************

; VPORT_INTFLAGS masks
.equ VPORT_INT_gm = 0xFF                 ; Pin Interrupt Flag group mask
.equ VPORT_INT_gp = 0                    ; Pin Interrupt Flag group position
.equ VPORT_INT_0_bm = (1<<0)             ; Pin Interrupt Flag bit 0 mask
.equ VPORT_INT_0_bp = 0                  ; Pin Interrupt Flag bit 0 position
.equ VPORT_INT_1_bm = (1<<1)             ; Pin Interrupt Flag bit 1 mask
.equ VPORT_INT_1_bp = 1                  ; Pin Interrupt Flag bit 1 position
.equ VPORT_INT_2_bm = (1<<2)             ; Pin Interrupt Flag bit 2 mask
.equ VPORT_INT_2_bp = 2                  ; Pin Interrupt Flag bit 2 position
.equ VPORT_INT_3_bm = (1<<3)             ; Pin Interrupt Flag bit 3 mask
.equ VPORT_INT_3_bp = 3                  ; Pin Interrupt Flag bit 3 position
.equ VPORT_INT_4_bm = (1<<4)             ; Pin Interrupt Flag bit 4 mask
.equ VPORT_INT_4_bp = 4                  ; Pin Interrupt Flag bit 4 position
.equ VPORT_INT_5_bm = (1<<5)             ; Pin Interrupt Flag bit 5 mask
.equ VPORT_INT_5_bp = 5                  ; Pin Interrupt Flag bit 5 position
.equ VPORT_INT_6_bm = (1<<6)             ; Pin Interrupt Flag bit 6 mask
.equ VPORT_INT_6_bp = 6                  ; Pin Interrupt Flag bit 6 position
.equ VPORT_INT_7_bm = (1<<7)             ; Pin Interrupt Flag bit 7 mask
.equ VPORT_INT_7_bp = 7                  ; Pin Interrupt Flag bit 7 position


;*************************************************************************
;** VREF - Voltage reference
;*************************************************************************

; VREF_ACREF masks
.equ VREF_REFSEL_gm = 0x07               ; Reference select group mask
.equ VREF_REFSEL_gp = 0                  ; Reference select group position
.equ VREF_REFSEL_0_bm = (1<<0)           ; Reference select bit 0 mask
.equ VREF_REFSEL_0_bp = 0                ; Reference select bit 0 position
.equ VREF_REFSEL_1_bm = (1<<1)           ; Reference select bit 1 mask
.equ VREF_REFSEL_1_bp = 1                ; Reference select bit 1 position
.equ VREF_REFSEL_2_bm = (1<<2)           ; Reference select bit 2 mask
.equ VREF_REFSEL_2_bp = 2                ; Reference select bit 2 position
.equ VREF_ALWAYSON_bm = 0x80             ; Always on bit mask
.equ VREF_ALWAYSON_bp = 7                ; Always on bit position

; Reference select
.equ VREF_REFSEL_1V024_gc = (0x00<<0)    ; Internal 1.024V reference
.equ VREF_REFSEL_2V048_gc = (0x01<<0)    ; Internal 2.048V reference
.equ VREF_REFSEL_4V096_gc = (0x02<<0)    ; Internal 4.096V reference
.equ VREF_REFSEL_2V500_gc = (0x03<<0)    ; Internal 2.500V reference
.equ VREF_REFSEL_VDD_gc = (0x05<<0)      ; VDD as reference
.equ VREF_REFSEL_VREFA_gc = (0x06<<0)    ; External reference on VREFA pin


;*************************************************************************
;** WDT - Watch-Dog Timer
;*************************************************************************

; WDT_CTRLA masks
.equ WDT_PERIOD_gm = 0x0F                ; Period group mask
.equ WDT_PERIOD_gp = 0                   ; Period group position
.equ WDT_PERIOD_0_bm = (1<<0)            ; Period bit 0 mask
.equ WDT_PERIOD_0_bp = 0                 ; Period bit 0 position
.equ WDT_PERIOD_1_bm = (1<<1)            ; Period bit 1 mask
.equ WDT_PERIOD_1_bp = 1                 ; Period bit 1 position
.equ WDT_PERIOD_2_bm = (1<<2)            ; Period bit 2 mask
.equ WDT_PERIOD_2_bp = 2                 ; Period bit 2 position
.equ WDT_PERIOD_3_bm = (1<<3)            ; Period bit 3 mask
.equ WDT_PERIOD_3_bp = 3                 ; Period bit 3 position
.equ WDT_WINDOW_gm = 0xF0                ; Window group mask
.equ WDT_WINDOW_gp = 4                   ; Window group position
.equ WDT_WINDOW_0_bm = (1<<4)            ; Window bit 0 mask
.equ WDT_WINDOW_0_bp = 4                 ; Window bit 0 position
.equ WDT_WINDOW_1_bm = (1<<5)            ; Window bit 1 mask
.equ WDT_WINDOW_1_bp = 5                 ; Window bit 1 position
.equ WDT_WINDOW_2_bm = (1<<6)            ; Window bit 2 mask
.equ WDT_WINDOW_2_bp = 6                 ; Window bit 2 position
.equ WDT_WINDOW_3_bm = (1<<7)            ; Window bit 3 mask
.equ WDT_WINDOW_3_bp = 7                 ; Window bit 3 position

; WDT_STATUS masks
.equ WDT_SYNCBUSY_bm = 0x01              ; Syncronization busy bit mask
.equ WDT_SYNCBUSY_bp = 0                 ; Syncronization busy bit position
.equ WDT_LOCK_bm = 0x80                  ; Lock enable bit mask
.equ WDT_LOCK_bp = 7                     ; Lock enable bit position

; Period select
.equ WDT_PERIOD_OFF_gc = (0x00<<0)       ; Off
.equ WDT_PERIOD_8CLK_gc = (0x01<<0)      ; 8 cycles (8ms)
.equ WDT_PERIOD_16CLK_gc = (0x02<<0)     ; 16 cycles (16ms)
.equ WDT_PERIOD_32CLK_gc = (0x03<<0)     ; 32 cycles (32ms)
.equ WDT_PERIOD_64CLK_gc = (0x04<<0)     ; 64 cycles (64ms)
.equ WDT_PERIOD_128CLK_gc = (0x05<<0)    ; 128 cycles (0.128s)
.equ WDT_PERIOD_256CLK_gc = (0x06<<0)    ; 256 cycles (0.256s)
.equ WDT_PERIOD_512CLK_gc = (0x07<<0)    ; 512 cycles (0.512s)
.equ WDT_PERIOD_1KCLK_gc = (0x08<<0)     ; 1K cycles (1.0s)
.equ WDT_PERIOD_2KCLK_gc = (0x09<<0)     ; 2K cycles (2.0s)
.equ WDT_PERIOD_4KCLK_gc = (0x0A<<0)     ; 4K cycles (4.1s)
.equ WDT_PERIOD_8KCLK_gc = (0x0B<<0)     ; 8K cycles (8.2s)

; Window select
.equ WDT_WINDOW_OFF_gc = (0x00<<4)       ; Off
.equ WDT_WINDOW_8CLK_gc = (0x01<<4)      ; 8 cycles (8ms)
.equ WDT_WINDOW_16CLK_gc = (0x02<<4)     ; 16 cycles (16ms)
.equ WDT_WINDOW_32CLK_gc = (0x03<<4)     ; 32 cycles (32ms)
.equ WDT_WINDOW_64CLK_gc = (0x04<<4)     ; 64 cycles (64ms)
.equ WDT_WINDOW_128CLK_gc = (0x05<<4)    ; 128 cycles (0.128s)
.equ WDT_WINDOW_256CLK_gc = (0x06<<4)    ; 256 cycles (0.256s)
.equ WDT_WINDOW_512CLK_gc = (0x07<<4)    ; 512 cycles (0.512s)
.equ WDT_WINDOW_1KCLK_gc = (0x08<<4)     ; 1K cycles (1.0s)
.equ WDT_WINDOW_2KCLK_gc = (0x09<<4)     ; 2K cycles (2.0s)
.equ WDT_WINDOW_4KCLK_gc = (0x0A<<4)     ; 4K cycles (4.1s)
.equ WDT_WINDOW_8KCLK_gc = (0x0B<<4)     ; 8K cycles (8.2s)




; ***** CPU REGISTER DEFINITIONS *****************************************
.def	XH	= r27
.def	XL	= r26
.def	YH	= r29
.def	YL	= r28
.def	ZH	= r31
.def	ZL	= r30


; ***** DATA MEMORY DECLARATIONS *****************************************


#define DATAMEM_START 0x0000
#define DATAMEM_SIZE 0x10000
#define DATAMEM_END (0x0000 + 0x10000 - 1)

#define IO_START 0x0000
#define IO_SIZE 0x103F
#define IO_END (0x0000 + 0x103F - 1)

#define LOCKBITS_START 0x1040
#define LOCKBITS_SIZE 0x0004
#define LOCKBITS_END (0x1040 + 0x0004 - 1)
#define LOCKBITS_PAGE_SIZE 0x01

#define FUSES_START 0x1050
#define FUSES_SIZE 0x0010
#define FUSES_END (0x1050 + 0x0010 - 1)
#define FUSES_PAGE_SIZE 0x01

#define SIGNATURES_START 0x1080
#define SIGNATURES_SIZE 0x0003
#define SIGNATURES_END (0x1080 + 0x0003 - 1)
#define SIGNATURES_PAGE_SIZE 0x80

#define PROD_SIGNATURES_START 0x1083
#define PROD_SIGNATURES_SIZE 0x007D
#define PROD_SIGNATURES_END (0x1083 + 0x007D - 1)
#define PROD_SIGNATURES_PAGE_SIZE 0x80

#define BOOTROW_START 0x1100
#define BOOTROW_SIZE 0x0100
#define BOOTROW_END (0x1100 + 0x0100 - 1)
#define BOOTROW_PAGE_SIZE 0x100

#define USER_SIGNATURES_START 0x1200
#define USER_SIGNATURES_SIZE 0x0200
#define USER_SIGNATURES_END (0x1200 + 0x0200 - 1)
#define USER_SIGNATURES_PAGE_SIZE 0x200

#define EEPROM_START 0x1400
#define EEPROM_SIZE 0x0100
#define EEPROM_END (0x1400 + 0x0100 - 1)
#define EEPROM_PAGE_SIZE 0x01

#define INTERNAL_SRAM_START 0x6000
#define INTERNAL_SRAM_SIZE 0x2000
#define INTERNAL_SRAM_END (0x6000 + 0x2000 - 1)

#define MAPPED_PROGMEM_START 0x8000
#define MAPPED_PROGMEM_SIZE 0x8000
#define MAPPED_PROGMEM_END (0x8000 + 0x8000 - 1)
#define MAPPED_PROGMEM_PAGE_SIZE 0x200

#define PROGMEM_START 0x0000
#define PROGMEM_SIZE 0x10000
#define PROGMEM_END (0x0000 + 0x10000 - 1)
#define PROGMEM_PAGE_SIZE 0x200


; Legacy definitions
.equ    FLASHSTART    = (PROGMEM_START / 2) ; Note: Word address
.equ    FLASHEND      = (PROGMEM_END / 2) ; Note: Word address
.equ    IOEND         = IO_END
.equ    SRAM_START    = INTERNAL_SRAM_START
.equ    SRAM_SIZE     = INTERNAL_SRAM_SIZE
.equ    RAMEND        = INTERNAL_SRAM_END
.equ    E2END         = EEPROM_END
.equ    EEPROMEND     = EEPROM_END


; Definitions used by the assembler
#pragma AVRPART MEMORY PROG_FLASH 0x10000
#pragma AVRPART MEMORY EEPROM 0x0100
#pragma AVRPART MEMORY INT_SRAM SIZE 0x2000
#pragma AVRPART MEMORY INT_SRAM START_ADDR 0x6000

; ***** INTERRUPT VECTORS, ABSOLUTE ADDRESSES ****************************
; NMI interrupt vectors
.equ NMI_vect = 0x0002                   ; 

; BOD interrupt vectors
.equ BOD_VLM_vect = 0x0004               ; 

; CLKCTRL interrupt vectors
.equ CLKCTRL_CFD_vect = 0x0006           ; 

; RTC interrupt vectors
.equ RTC_CNT_vect = 0x0008               ; 
.equ RTC_PIT_vect = 0x000A               ; 

; CCL interrupt vectors
.equ CCL_CCL_vect = 0x000C               ; 

; USB0 interrupt vectors
.equ USB0_BUSEVENT_vect = 0x000E         ; 
.equ USB0_TRNCOMPL_vect = 0x0010         ; 

; PORTA interrupt vectors
.equ PORTA_PORT_vect = 0x0012            ; 

; TCA0 interrupt vectors
.equ TCA0_LUNF_vect = 0x0014             ; 
.equ TCA0_OVF_vect = 0x0014              ; 
.equ TCA0_HUNF_vect = 0x0016             ; 
.equ TCA0_CMP0_vect = 0x0018             ; 
.equ TCA0_LCMP0_vect = 0x0018            ; 
.equ TCA0_CMP1_vect = 0x001A             ; 
.equ TCA0_LCMP1_vect = 0x001A            ; 
.equ TCA0_CMP2_vect = 0x001C             ; 
.equ TCA0_LCMP2_vect = 0x001C            ; 

; TCB0 interrupt vectors
.equ TCB0_INT_vect = 0x001E              ; 

; TWI0 interrupt vectors
.equ TWI0_TWIS_vect = 0x0020             ; 
.equ TWI0_TWIM_vect = 0x0022             ; 

; SPI0 interrupt vectors
.equ SPI0_INT_vect = 0x0024              ; 

; USART0 interrupt vectors
.equ USART0_RXC_vect = 0x0026            ; 
.equ USART0_DRE_vect = 0x0028            ; 
.equ USART0_TXC_vect = 0x002A            ; 

; PORTD interrupt vectors
.equ PORTD_PORT_vect = 0x002C            ; 

; PORTC interrupt vectors
.equ PORTC_PORT_vect = 0x002E            ; 

; PORTF interrupt vectors
.equ PORTF_PORT_vect = 0x0030            ; 

; NVMCTRL interrupt vectors
.equ NVMCTRL_NVMREADY_vect = 0x0032      ; 

; USART1 interrupt vectors
.equ USART1_RXC_vect = 0x0034            ; 
.equ USART1_DRE_vect = 0x0036            ; 
.equ USART1_TXC_vect = 0x0038            ; 

; TCB1 interrupt vectors
.equ TCB1_INT_vect = 0x003A              ; 

; AC0 interrupt vectors
.equ AC0_AC_vect = 0x003C                ; 

; ADC0 interrupt vectors
.equ ADC0_ERROR_vect = 0x003E            ; 
.equ ADC0_RESRDY_vect = 0x0040           ; 
.equ ADC0_SAMPRDY_vect = 0x0042          ; 



; ***** INTERRUPT VECTORS, MODULE BASES **********************************

.equ NMI_vbase = 0x0002
.equ BOD_vbase = 0x0004
.equ CLKCTRL_vbase = 0x0006
.equ RTC_vbase = 0x0008
.equ CCL_vbase = 0x000C
.equ USB0_vbase = 0x000E
.equ PORTA_vbase = 0x0012
.equ TCA0_vbase = 0x0014
.equ TCB0_vbase = 0x001E
.equ TWI0_vbase = 0x0020
.equ SPI0_vbase = 0x0024
.equ USART0_vbase = 0x0026
.equ PORTD_vbase = 0x002C
.equ PORTC_vbase = 0x002E
.equ PORTF_vbase = 0x0030
.equ NVMCTRL_vbase = 0x0032
.equ USART1_vbase = 0x0034
.equ TCB1_vbase = 0x003A
.equ AC0_vbase = 0x003C
.equ ADC0_vbase = 0x003E


; ***** INTERRUPT VECTORS, VECTOR OFFSETS ********************************

; NMI interrupt vector offsets

.equ NMI_voffset = 0

; BOD interrupt vector offsets

.equ BOD_VLM_voffset = 0

; CLKCTRL interrupt vector offsets

.equ CLKCTRL_CFD_voffset = 0

; RTC interrupt vector offsets

.equ RTC_CNT_voffset = 0
.equ RTC_PIT_voffset = 2

; CCL interrupt vector offsets

.equ CCL_CCL_voffset = 0

; USB0 interrupt vector offsets

.equ USB0_BUSEVENT_voffset = 0
.equ USB0_TRNCOMPL_voffset = 2

; PORTA interrupt vector offsets

.equ PORTA_PORT_voffset = 0

; TCA0 interrupt vector offsets

.equ TCA0_LUNF_voffset = 0
.equ TCA0_OVF_voffset = 0
.equ TCA0_HUNF_voffset = 2
.equ TCA0_CMP0_voffset = 4
.equ TCA0_LCMP0_voffset = 4
.equ TCA0_CMP1_voffset = 6
.equ TCA0_LCMP1_voffset = 6
.equ TCA0_CMP2_voffset = 8
.equ TCA0_LCMP2_voffset = 8

; TCB0 interrupt vector offsets

.equ TCB0_INT_voffset = 0

; TWI0 interrupt vector offsets

.equ TWI0_TWIS_voffset = 0
.equ TWI0_TWIM_voffset = 2

; SPI0 interrupt vector offsets

.equ SPI0_INT_voffset = 0

; USART0 interrupt vector offsets

.equ USART0_RXC_voffset = 0
.equ USART0_DRE_voffset = 2
.equ USART0_TXC_voffset = 4

; PORTD interrupt vector offsets

.equ PORTD_PORT_voffset = 0

; PORTC interrupt vector offsets

.equ PORTC_PORT_voffset = 0

; PORTF interrupt vector offsets

.equ PORTF_PORT_voffset = 0

; NVMCTRL interrupt vector offsets

.equ NVMCTRL_NVMREADY_voffset = 0

; USART1 interrupt vector offsets

.equ USART1_RXC_voffset = 0
.equ USART1_DRE_voffset = 2
.equ USART1_TXC_voffset = 4

; TCB1 interrupt vector offsets

.equ TCB1_INT_voffset = 0

; AC0 interrupt vector offsets

.equ AC0_AC_voffset = 0

; ADC0 interrupt vector offsets

.equ ADC0_ERROR_voffset = 0
.equ ADC0_RESRDY_voffset = 2
.equ ADC0_SAMPRDY_voffset = 4



.equ INT_VECTORS_SIZE = 68 ; size in words


#endif /* _AVR64DU32DEF_INC_ */

; ***** END OF FILE ******************************************************



